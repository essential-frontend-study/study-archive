## section 4
### App Router
1. Next.js에서 App Router가 등장하면서 기존의 Page Router 방식과 많은점이 바뀌었다. 

2. 하지만, 네비게이팅, 프리페칭, 사전 렌더링 개념은 바뀌지 않았으며, React 18 신규기능 추가, 데이터 페칭 방식, 레이아웃 설정 방식, 페이지 라우팅 설정 방식과 같은 개념만 바뀌었다.
![](https://lh3.googleusercontent.com/d/1M8c94Nrk7oHodXqYv06kkXVZ43f3-89J)

### 페이지 라우팅 설정하기
1. 페이지 라우팅을 설정하는 방법은 Page Router와 크게 다르지 않다. page.tsx 파일이 곧 페이지 파일이 되고 search page를 만들려면 search 폴더를 만들고 그 하위에 page.tsx 파일을 만들면 된다. 동적 경로 또한 [id]폴더를 만든 뒤, 그 하위에 page.tsx 파일을 만들면 된다.
![](https://lh3.googleusercontent.com/d/1h4Zw3sz4mBXUkrAZt0FjVEgNgxNTMa2F)

2. 쿼리스트링을 꺼내는 방법도 page router와 조금 다른데, 기존 page router는 router 객체를 통해 값을 가져왔지만, app router에서는 쿼리스트링은 해당 페이지의 props로 전달된다.(서버 컴포넌트인 경우에만, 클라이언트 컴포넌트의 경우 useSearchParams() 훅 필요)
    ![](https://lh3.googleusercontent.com/d/13wwLudCz5d_rjdqa2aY3yHWsC_zzHtAV)
    - 위와 같이 app router에서는 url parameter나 쿼리스트링의 값이 props를 통해서 전달이 되고 있다. 쿼리스트링을 가져오려면 searchParams를 통해 실제 쿼리스트링의 값을 꺼내 사용할 수 있다. 주의할 점은 반드시 Promise<id: string>과 같이 Promise로 타입을 정의해야 한다.

3. url parameter를 꺼내는 방법은 위 쿼리스트링을 꺼낼 때 살펴봤던 props의 param의 id를 통해 꺼내올 수 있다. (props.param.id)
    ![](https://lh3.googleusercontent.com/d/1J09J88YDYu_InX7E3EDdC71EBtCAGKHU)

4. 중첩 경로로 설정하기 위해서는 page router 버전에서와 같이 catch all segment 방식으로 폴더명을 설정해준다. [...id]
    ![](https://lh3.googleusercontent.com/d/1Vc03rN9IeNx8DDhnqXpDKe3828w7wpPw)

5. url parameter가 존재하지 않는 /book 과 같은 경로에도 대응하고 싶다면 폴더명을 [[...id]]와 같이 대괄호를 두 번 작성해주면 된다.

### 레이아웃
1. 기존 page router에서는 컴포넌트를 내보내고 _document 파일에서 적용시킬 페이지만 감싸는 방식으로 복잡하게 구성되었지만, app router의 레이아웃은 각 페이지마다 쉽게 설정할 수 있다. 해당 페이지 폴더 내부에 layout.tsx 파일을 생성하면 된다. 즉, /search로 시작하는 모든 페이지의 layout으로 적용이 된다.
![](https://lh3.googleusercontent.com/d/1MJZoLbER3yNHDYw5QbLhYf2q2T0iIOaA)

2. 만약 search 폴더 내부의 layout.tsx 적용하고 또 search 폴더 내부에 있는 settings 폴대 내부에 layout.tsx를 적용하면 이는, 레이아웃이 중첩이 된다.
![](https://lh3.googleusercontent.com/d/180jaVY_4femGKYVplFNPF7AqJ1X6Outs)

3. layout.tsx에 작성된 함수에는 children props로 해당 page가 전달이 된다. 따라서 layout.tsx에서 children을 통해 해당 페이지를 렌더링 시켜줘야 정상적으로 레이아웃이 적용된 페이지가 렌더링 된다.
![](https://lh3.googleusercontent.com/d/1QZMNNuJWe-rScECe_LUJN1msBMydqxjD)


### 라우트 그룹
1. 실습 예제에서 index와 search 페이지에만 서치바 컴포넌트를 적용하고 싶을 땐, 라우트 그룹을 사용해야 한다. 폴더명을 소괄호로 감싸주면 라우트 그룹이 적용된다. 라우트 그룹은 경로상에는 아무 영향을 미치지 않는 폴더이기에 index 페이지 파일이나 search 페이지 폴더 등을 해당 라우트 그룹으로 옮겨도 라우팅에는 아무 영향 없이 기존 방식대로 동작한다. 즉, 경로엔 영향이 없지만 레이아웃을 함께 적용하고 싶을 경우에 라우트 그룹을 사용한다.
![](https://lh3.googleusercontent.com/d/1Llt3Vvg-gd6Oppq7BzVilxAL2Iga-uVT)

### 리액트 서버 컴포넌트 이해하기
1. 서버 컴포넌트란 서버측에서만 실행되는 컴포넌트를 말한다. 즉, 서버가 아닌 브라우저측에서는 실행되지 않는다. 

2. 서버 컴포넌트 등장 전, page router 방식에서는 어떤 문제점이 있었을까? 사전 렌더링 과정 중에 JS 번들에 포함되는 컴포넌트 중 하이드레이션이 필요하지 않은 컴포넌트까지 전부 포함된다는 것이였다. 즉, 하이드레이션이 필요한 컴포넌트만 전달해줘서 하이드레이션 과정을 거치는게 JS 번들 크기를 줄이는데 더 합리적이기 때문에 (그래야 하이드레이션 과정에 필요한 시간도 단축되니까), 서버 컴포넌트가 등장한 것이다.

3. 렌더링 과정에서 다시 살펴보면, 처음 JS가 실행될 때는 서버 컴포넌트던 클라이언트 컴포넌트던 구분하지 않고 모든 컴포넌트를 실행한다.
    ![](https://lh3.googleusercontent.com/d/1-yfJj_eGnmchzyfa4YqEKK1K4tXaciMd)
그리고 하이드레이션 과정을 위해 JS가 실행될 때는 서버 컴포넌트가 제외된다.
    ![](https://lh3.googleusercontent.com/d/1dajqJf5s2TaBU7iHROEKrhGigOOyPsQr)
즉, 클라이언트 컴포넌트만 하이드레이션 과정에 필요한 JS 번들로서 전달되는 것이다.
    ![](https://lh3.googleusercontent.com/d/1RsePjDj2H5C95CyCrxj37I85RVgBIK_F)
이렇게 서버 컴포넌트는 하이드레이션 과정에서 전달되는 JS 번들에서 빠질 뿐만 아니라, 서버에서만 실행되기 때문에 컴포넌트 내부에서 데이터베이스나 API를 직접 호출하며, 환경 변수, API 키 등 민감한 정보를 클라이언트에 노출하지 않고 사용할 수 있다.(민감한 데이터 처리)

4. 마지막으로 서버 컴포넌트와 클라이언트 컴포넌트의 차이를 알아보자. 서버 컴포넌트는 서버측에서 사전 렌더링을 진행할 때 딱 한 번만 실행되지만, 클라이언트 컴포넌트는 사전 렌더링 중 한 번, 하이드레이션 진행할 때 한 번, 총 두 번 실행된다.
![](https://lh3.googleusercontent.com/d/1ca_Rf2sCe5n59_y1-7ErLNR40HKZ8q0_)
따라서 Next.js 공식 문서에서는 페이지의 대부분을 서버 컴포넌트로 구성할 것을 권장한다. 클라이언트 컴포넌트는 꼭 필요한 경우에만 사용하라고 한다. (모든 컴포넌트를 클라이언트 컴포넌트로 구성할거면 서버 컴포넌트 등장 필요 없으니!)
클라이언트 컴포넌트가 꼭 필요한 경우는 onClick, onChange 등 이벤트 리스너를 포함할 때(상호작용), window, document, localStorage 등 브라우저 API를 사용할 때(브라우저 전용 API), useState, useReducer, useEffect 등 상태(State)와 생명주기 관련 훅을 사용할 때(React 훅)등 이다.

5. Next.js의 app router 방식에서는 기본적으로 모든 컴포넌트가 서버 컴포넌트로 동작한다. 따라서 클라이언트 컴포넌트로 만들고 싶다면 코드 최상단에 'use client'를 선언해줘야 한다.

### 서버 컴포넌트 주의사항
1. 서버 컴포넌트는 브라우저에서 실행될 코드가 포함되면 안된다.

2. 클라이언트 컴포넌트는 클라이언트에서만 실행되는 게 아닌, 사전 렌더링 중 한 번, 하이드레이션 중 한 번, 총 두 번이 실행된다.

3. 클라이언트 컴포넌트에서 서버 컴포넌트를 import 할 수 없다.
    ![](https://lh3.googleusercontent.com/d/1rR2hw9C5aN6XwGBkcpT1aALHqMZjkEVI)
    - 서버 컴포넌트는 서버에서만 실행되는데, 클라이언트 컴포넌트는 서버, 클라이언트 모두 실행된다. 따라서 클라이언트에 서버 컴포넌트를 import 하게 되면 해당 import한 서버 컴포넌트는 서버에서 실행되고 클라이언트에서 실행 시도하는 것이다. 이때 에러는 발생하지 않고 서버 컴포넌트는 자동으로 클라이언트 컴포넌트로 변환이 된다.
        ![](https://lh3.googleusercontent.com/d/1Elsx6JFEeebUYmIkGpZRB98rLNK3ApjZ)
        - 사진을 보면, 서버 컴포넌트가 콘솔에 두 번 찍히는 것을 볼 수 있는데, 이는 서버 컴포넌트가 클라이언트 컴포넌트로 바꼈다는 걸 의미한다.
        - 하지만 이는 좋은 방법이 아니다. 클라이언트 컴포넌트에서 서버 컴포넌트를 사용해야할 때, children props를 활용하면 클라이언트 컴포넌트에서 서버 컴포넌트를 사용해도 해당 서버 컴포넌트가 클라이언트 컴포넌트로 변환되지 않게 해줄 수 있다.
            ```tsx
            'use client';

            export default function ClientComponent({
                children
            }: {
                children: ReactNode;
            }) {
                return <div>{children}</div>
            }
            ```
            - 이렇게 클라이언트 컴포넌트에서 children을 렌더링 해주고

            ```tsx
            import ClientComponent from './client-component';
            import ServerComponent from './server-component';

            export default function App() {
                <ClientComponent>
                  <ServerComponent />
                </ClientComponent>
            }
            ```
            - 이렇게 해당 App 컴포넌트에서 클라이언트 컴포넌트의 children으로 서버 컴포넌트를 넘겨주면 된다.
            - 결과적으로 클라이언트 컴포넌트에서 서버 컴포넌트를 사용하더라도 서버 컴포넌트로써 사용할 수 있게 된다.


4. 서버 컴포넌트에서 클라이언트 컴포넌트에게 직렬화되지 않는 props는 전달 할 수 없다.
    - 먼저 직렬화란, 객체, 배열, 클래스 등의 복잡한 구조의 데이터를 네트워크 상으로 전송하기 위해 아주 단순한 형태(문자열, byte)로 변환하는 것을 말한다.
        ```ts
        const person = {
            name: '이정환',
            age: 27,
        }

        -> // 직렬화 
        {"name":"이정환","age":27}
        ```
    - 그렇다면 직렬화되지 않는 데이터에는 무엇이 있을까? 바로 자바스크립트 함수는 직렬화가 불가능하다. 클로저나, 렉시컬 스코프 등 다양한 환경에 의존해 있는 경우가 있기 때문에 그런 모든 정보를 단순한 문자열이나 바이트 형태로 직렬화가 불가능한 것이다. 
    - 즉, 함수는 서버 컴포넌트에서 클라이언트로 전달하는 Props가 될 수 없다.
        ![](https://lh3.googleusercontent.com/d/1oI23RmmErchnE4pH8mk6ET0vUsA1CTwN)
    - 그 이유는 앞서 살펴본 사전 렌더링 방식에서 클라이언트가 접속 요청을 보내면 서버에서 JS를 실행하는 과정에서 모든 컴포넌트가 실행되어 렌더링되고 그 후 하이드레이션 과정을 거친다고 알고 있었는데, 사실은 모든 컴포넌트가 실행되는 과정에서 서버 컴포넌트만 따로 실행되는 과정이 있다.
        ![](https://lh3.googleusercontent.com/d/1fob7rEQGdPVdXHJG3ssfOs8xvouAfplR)
    - 즉, 페이지를 구성하는 모든 컴포넌트들이 실행되는 과정에서 서버 컴포넌트만 먼저 실행되고 그 이후에 클라이언트 컴포넌트가 실행된 후에 완성된 HTML 페이지를 클라이언트에게 보내주는 것이다.
    - 이때, 서버 컴포넌트만 따로 실행하는 과정에서 RSC Payload가 생성되는데, 이는 React Server Component의 순수한 데이터 (결과물)이다. (React Server Component를 직렬화한 것) 이 RSC Payload에는 서버 컴포넌트의 모든 데이터가 들어가 있다. (서버 컴포넌트의 렌더링 결과, 연결된 클라이언트 컴포넌트의 위치, 클라이언트 컴포넌트에게 전달하는 Props 값)
        ![](https://lh3.googleusercontent.com/d/1Zy0hAaE3X8Q4UCmytNc_z2jfNRumcEqB)
    - 결과적으로 이러한 RSC Payload 결과물과 클라이언트 컴포넌트들이 합쳐져서 HTML이 만들어지고 해당 HTML을 클라이언트에게 전달하여 렌더링되는 것이다. 그렇기에 서버 컴포넌트에서 클라이언트 컴포넌트로 함수와 같이 직렬화가 되지 않는 Props를 넘겨준다면, RSC Payload과정에서 직렬화가 되지 않기 때문에 에러가 발생하는 것이다.
        ![](https://lh3.googleusercontent.com/d/15mgITkUVA-jmo94meDCSFUHo2EaIRZMd)

### 네비게이팅
1. 기본적으로 네비게이팅 방식은 Page Router 방식과 비슷하다. App Router 방식에서는 서버 컴포넌트 개념이 등장하면서 하이드레이션 과정에서 전달되는 JS 번들에는 서버 컴포넌트들이 아닌 클라이언트 컴포넌트만 전달된다. 따라서 이때 RSC Payload를 함께 전달해주어, 서버 컴포넌트로 작성된 페이지들도 함께 보내주어 네비게이팅이 정상적으로 작동할 수 있게 해준다.
    ![](https://lh3.googleusercontent.com/d/19pfD3tR4UYXno1fL29PlG_HERcX8XJ7R)

2. 즉, 기본적인 네비게이팅 방식은 Page Router와 같이 클라이언트 측 라우팅을 사용하지만 데이터를 가져오는 방식이 다르다. Pages Router의 경우 페이지 이동 시, 필요한 **데이터 (JSON)**와 전체 JS 번들을 요청하지만, App Router의 경우 페이지 이동 시, Next.js 서버에 새로운 RSC Payload를 요청한다.

3. 또한, App Router 환경에서는 클라이언트로 전달되는 JS 번들에서 서버 컴포넌트(RSC) 코드가 제외된다. 따라서 페이지 이동 시, 서버 컴포넌트로 구성된 새 페이지를 렌더링하기 위해 RSC Payload가 사용된다. 

4. 결과적으로 네비게이팅 시 동작은 클라이언트가 <Link>를 클릭하면, 서버는 이동할 페이지에 필요한 새로운 RSC Payload만 전송한다. 클라이언트는 이 Payload를 사용하여 자바스크립트를 다시 로드할 필요 없이, 기존 DOM 트리의 변경된 부분만 효율적으로 업데이트한다.

5. RSC Payload 덕분에 Next.js는 최소한의 네트워크 전송으로 페이지 이동을 처리한다. 이는 JS 번들을 줄이는 서버 컴포넌트의 장점과 빠른 페이지 전환이라는 CSR의 장점을 모두 결합한 방식이다.

### useSearchParams
1. 쿼리스트링의 값을 꺼내올 때, Page Router의 경우 useRouter()훅에서 query.q 값을 꺼내왔지만 App Router의 경우 query객체를 제공해주지 않기 때문에 useSearchParams().get('q')와 같이 q값을 꺼내와야 한다.
    ```tsx
    'use client';

    import { useRouter, useSearchParams } from 'next/navigation';

    export default function App() {
        const router = useRouter();
        const searchParams = useSearchParams();

        const q = searchParams.get('q');
    }
    ```
2. 반면 서버 컴포넌트에서는 위에서 살펴본 searchParams객체를 props로 받아와서 사용해야 한다.
    ![](https://lh3.googleusercontent.com/d/13wwLudCz5d_rjdqa2aY3yHWsC_zzHtAV)

## section 5
### 데이터 패칭
1. 서버 컴포넌트는 async 키워드를 붙여서 사용할 수 있다. 기존 클리이언트 컴포넌트는 async 키워드가 붙은 비동기 함수로 설정할 수 없었다. 간략하게 설명하자면 props 전달, 메모이제이션 등에서 문제가 발생할 수 있기 떄문이다. 

2. 따라서 서버 컴포넌트 내부에서 직접 await 키워드를 이용해 데이터를 패칭할 수 있다. 즉, 기존의 Page Router 방식에서의 getServerSideProps, getStaticProps 등을 사용하지 않고 컴포넌트 내부에서 직접 컴포넌트가 필요로 하는 데이터를 패칭하여 서용할 수 있는 것이다.

    ```tsx
    export default async function App() {
        const res = await fetch('http://...');
        if (!res.ok) <div>오류 발생</div>;

        const allBooks = res.json();

        return (
            <div>
              {allBooks.map((book) => (
                <BookItem key={book.id} {...book} />
              ))}
            </div>
        )
    }
    ```

3. 추가 팁 .env 파일에 api 서버를 저장해두면 유지보수 편리
    ```.env
    NEXT_PUBLIC_API_SERVER_URL=http://...;
    ```
    - PUBLIC 접두사 필수: 붙이지 않으면 해당하는 환경 변수에 서버측에서만 접근할 수 있도록 설정한다.

### 데이터 캐시
1. 데이터 캐시란 fetch 메서드를 통해 불러온 데이터를 Next 서버에 보관하는 기능이다. 영구적으로 데이터를 보관하거나, 특정 시간을 주기로 데이터를 갱신시킬 수 있다. 결론적으로, 데이터 캐시를 이용해서 불필요한 데이터 요청 수를 줄여서 웹 서비스 성능을 향상시킬 수 있다.

2. fetch 메서드의 두 번째 인수에 객체 형태로 옵션을 설정해줄 수 있다. 지금부터 옵션을 하나씩 살펴보자

3. 'no-store'는 데이터 페칭의 결과를 저장하지 않는 옵션이다. 캐싱을 아예 하지 않도록 하는 것이다.
    ```tsx
    const res = await fetch('http://...', { cache: 'no-store' });
    ```
    - 일반적으로 fetch의 두 번째 인자를 비워두면 사용되는 기본 옵션이다.
        ![](https://lh3.googleusercontent.com/d/1CaWeLA9oYAjXeliEUnx9ysG3IY3Dsaqe)
        - 즉, 데이터 요청을 보낼 때 데이터 캐시를 사용하지 않고 그대로 서버로 요청하여 응답받은 값을 통해 클라이언트에게 전달한다.
    - 실제 동작을 살펴보기 위해 next.config.mjs 파일에 다음과 같이 로깅하도록 설정한다.
        ![](https://lh3.googleusercontent.com/d/1D05csSc9Oy8PTranWda2hl64Hyl-6i9r)
    - 그 후 데이터 패치를 시도하면 아래와 같은 로그가 찍히는 것을 볼 수 있다.
        ![](https://lh3.googleusercontent.com/d/1HKbQ6dYNLlVcwu8OSDTNM69ALnQ3UjuJ)
        - 해당 데이터 요청이 cache skip되었다고 나오며, cache: no-store 옵션이 이유라고 알려주고 있다. 또 아래의 random 요청을 보면, 이 요청에는 아무 옵션을 넣어주지 않았는데, 똑같이 cache skip으로 설정되는걸로 볼 수 있다. 즉, 옵션을 넣지 않으면 기본값이 no-store로 설정된다.

4. 'force-cache'는 데이터 패칭의 결과를 무조건 저장하는 옵션이다. 한 번 호출된 이후로는 다시 호출되지 않는다. 
    ```tsx
    const res = await fetch('http://...', { cache: 'force-cache' });
    ```
    - 즉, 처음 데이터 요청을 서버로 보내고 서버로부터 결과를 받을 때, Next측에서 해당 요청의 결과값을 저장(캐싱)해둔다. 그리고 이후 요청에 대해서는 Next측에 저장된 결과값을 보내준다. 즉, 서버측에 요청이 가지 않는다.
    ![](https://lh3.googleusercontent.com/d/1s5kvJAAYLqiqOEIjdVgqVSuWO8RSmgzH)
    - 로깅 데이터를 살펴보면, 적용된 random 요청에 대한 fetch 결과에서 cache hit이 되어 서버에 요청하는 것이 아닌, Next측에 저장된 값을 돌려주는 것을 볼 수 있다.
    ![](https://lh3.googleusercontent.com/d/14a8kh2RmcIRqeYJCxDLFURKpcBjZcvdx)
    - 추가적으로 캐시된 데이터는 .next/cache/fetch-cache에서 확인할 수 있다.
    ![](https://lh3.googleusercontent.com/d/1uLzhv1aSbnd8-GnkSYLIpvb4jCHWD8Ga)

5. 'revalidate' 옵션은 특정 시간을 주기로 캐시를 업데이트 하는데, 마치 ISR의 동작과정과 비슷하다.
    ```tsx
    const res = await fetch('http://...', { next: { revalidate: 3 } });
    ```
    - 첫 번째 데이터 요청을 보내고 서버에서 응답한 값을 Next측에 저장하고, 지정한 시간이 지난 뒤 다시 요청이 들어오면 데이터 상태를 stale로 변경하고 일단 저장된 값을 보내준뒤, 캐시를 업데이트 한다.
    ![](https://lh3.googleusercontent.com/d/1sYGbn0hwG96jofc6wUWvB57lD8vLAF-I)

6. 마지막 'tag' 옵션은 on-demand revalidate 방식으로 요청이 들어왔을 때, 데이터를 최신화하는 방식이다. on demand isr과 같은 방식으로 동작한다.
    ```tsx
    const res = await fetch('http://...', { next: { tag:['a'] } } );
    ```
    - 실습은 아직 보류!

### 리퀘스트 메모이제이션
1. 리퀘스트 메모이제이션은 말 그대로 요청을 메모이제이션 하는 것이다. 하나의 페이지를 서버측에서 렌더링하는 과정에서 모든 요청들 중 중복된 요청들을 중복 제거를 하여 요청할 수 있게 해주는 기능이다. 여기서 '중복된 요청'이란 URL과 fetch의 옵션 객체가 완전히 동일한 요청을 의미한다.
    ![](https://lh3.googleusercontent.com/d/1ZiLIbhB4qlp6BUOHt-5cePKKj6YY46sr)
    - 처음에는 데이터 패칭 요청을 보낼 때, 리퀘스트 메모이제이션에 저장된 값이 있는지 확인한다. 없다면 데이터 캐시에 저장된 값을 확인한다. 그것마저 없다면 서버에 데이터 요청을 하여 데이터를 받는다. 이때, 데이터 캐시 옵션이 기본값이라고 가정하면(no-store) 리퀘스트 메모이제이션에 해당 값을 저장한다. 그리고 그 이후에 오는 똑같은 요청에 대해서는 리퀘스트 메모이제이션에 저장된 값을 그대로 돌려준다.
    ![](https://lh3.googleusercontent.com/d/19-A_YjPoGEM8465rq8h23bjUIkDzdLp1)
    - 주의 사항으로는 리퀘스트 메모이제이션은 하나의 페이지를 렌더링하는 동안에 중복된 API 요청을 캐싱하기 위한 기능이기 때문에 하나의 페이지가 렌더링이 완료가 되면 해당 리퀘스트 메모이제이션은 초기화된다. 즉, 하나의 페이지가 모두 완료된 후에 api 요청이 들어와도 리퀘스트 메모이제이션은 이미 사라졌기에 리퀘스트 메모이제이션에 저장된 값이 없는 것이다.
    ![](https://lh3.googleusercontent.com/d/1cu2GyQxmiG12SYV3QQfZfr0W0kpq89Ab)
    - 반면 아까 살펴본 데이터 캐시의 경우에는 백엔드 서버로부터 가져온 데이터를 반 영구적으로 보관하기 때문에 서버가 가동중에는 영구적으로 보관된다. (서버 중단 시 초기화)

## section 6
### 풀라우트 캐시
1. 풀라우트 캐시란, Next 서버측에서 빌드 타임 또는 첫 요청 시 특정 페이지 렌더링 결과를 캐싱하는 기능이다. 즉, 데이터 요청을 보내고 받은 응답 값을 풀 라우트 캐시라는 공간에 저장을 한다. 그리고 그 이후에 요청은 풀 라우트 캐시에 저장된 값을 돌려준다.(HIT)
    ![](https://lh3.googleusercontent.com/d/19_J9R6lcELtiV5-eDR8-inwXP_sR8i8v)


2. 풀 라우트 캐시가 적용되려면 페이지가 정적 페이지여야 한다. 동적 페이지에는 적용이 되지 않는다. 이때 동적 페이지란, 특정 페이지가 접속 요청을 받을 때 마다 변화가 생기거나, 데이터가 달라질 경우이다. 즉, 캐시되지 않는 데이터 패칭을 사용하거나, 동적 함수(쿠키, 헤더, 쿼리스트링)을 사용하는 경우이다. 정적 페이지는 동적인 페이지가 아니면 기본적으로 정적 페이지로 설정이 된다. 동적 함수를 사용하지 않고 데이터 캐시를 하는 경우가 정적 페이지에 해당한다. 참고로 클라이언트 컴포넌트는 동적 함수가 사용되기에 풀 라우트 캐시에 해당하지 않는다.

3. 또, 풀 라우트 캐시에도 revalidate를 적용이 되는데, fetch 옵션이 Next:{revalidate: 3}이라먼, 첫 데이터 요청 시 서버로 받은 응답값이 데이터 캐시에 저장되고 풀 라우트 캐시에 저장되어, 3초 안에 또 요청이 온다면 HIT로 저장된 값을 바로 돌려주지만, 3초 이후엔 STALE로 상한 데이터를 일단 주고 서버로부터 새로운 데이터를 가져와 업데이트 한다. 
![](https://lh3.googleusercontent.com/d/1OJOqmD8ojHTkGkBzVZgJSfVLQrgWs9_u)

4. 동적 경로를 갖는 컴포넌트는 기본적으로 동적 페이지로 설정이 되지만, 정적 페이지로 설정하려면 generateStaticParams 함수를 만들어서 해당 함수에서 정적 페이지로 만들 id를 배열 형태로 리턴해주면 빌드 타임에 정적 페이지를 만든다. 
    ```tsx
    export function generateStaticParams() {
        return [{id: '1'}, {id: '2'}, {id: '3'}];
    }
    ```
    - 만약 id가 4번인 페이지에 접속하더라도 해당 페이지는 동적 페이지와 같이 생성한다. 그리고 그 결과를 static하게 저장하여 다음 번에 접속이 들어올 경우 정적 페이지처럼 동작하는 것이다.
    - 주의 사항은 해당 url parameter는 문자열로만 명시를 해줘야 한다.

### 라우트 세그먼트 옵션
1. 라우트 세그먼트 옵션이란, 특정 폴더나 페이지 파일 내부에서 export 구문을 사용하여 해당 세그먼트의 렌더링 방식, 데이터 캐싱 전략, 동적 처리 등을 세부적으로 제어하는 방법이다. 라우트 세그먼트 옵션 중 가장 활발히 사용되는 dynamic에 대해 살펴보자. dynamic이란 해당 페이지를 동적 페이지 혹은, 정적 페이지로 설정할 수 있게 해준다.
    ```tsx
    export const dynamic = 'auto'; // 기본값, 아무것도 강제하지 않음.
    export const dynamic = 'force-dynamic'; // 페이지를 강제로 동적 페이지로 설정
    export const dynamic = 'force-static'; // 페이지를 강제로 정적 페이지로 설정
    export const dynamic = 'error'; // 'error' 옵션은 페이지가 정적 생성될 수 없는 경우에 빌드 에러를 낸다. 예를 들어, searchParams를 사용하는 경우(쿼리스트링은 요청 시점에 동적으로 결정됨), 또는 cookies(), headers() 와 같은 동적 함수를 사용하는 경우 정적 페이지로 만들 수 없으므로 에러를 발생시켜 정적 페이지를 유지하도록 강제
    ```

### 클라이언트 라우터 캐시
1. 클라이언트 라우터 캐시는 네비게이팅 성능을 극대화하기 위해 브라우저(클라이언트) 메모리에 저장하는 캐시이다. 이는 사용자가 아직 방문하지 않은 페이지의 콘텐츠를 미리 가져오거나, 최근 방문했던 페이지의 데이터를 빠르게 재사용하는 역할을 한다.

2. 클라이언트 라우터 캐시는 RSC Payload를 저장하는 공간이다. 서버에서 전송받은 RSC Payload (서버 컴포넌트의 렌더링 결과물)와 HTML 마크업을 저장하고, 사용자가 <Link> 컴포넌트를 사용하여 페이지를 이동할 때, Next.js는 네트워크 요청을 보내기 전에 이 캐시를 먼저 확인한다. 캐시에 데이터가 있다면 즉시 페이지를 렌더링해, 페이지 전환 속도를 매우 빠르게 해준다.

3. 클라이언트 라우터 캐시의 효율성은 프리페칭(Prefetching) 기능에 의해 크게 향상되는데, Next.js는 기본적으로 뷰포트 내에 있는 모든 <Link> 컴포넌트의 대상 페이지를 자동으로 미리 가져와 클라이언트 라우터 캐시에 저장한다. 즉, 사용자가 링크를 클릭하는 순간, 이미 필요한 RSC Payload가 브라우저 메모리에 준비되어 있기 때문에, 네트워크 지연 없이 거의 즉시 새 페이지를 볼 수 있다.

4. 결론적으로, 클라이언트 라우터 캐시는 사용자의 브라우저 메모리에 데이터를 미리 준비해 두어, 페이지 간 이동 시 새 페이지를 즉시 로드할 수 있게 해주는 핵심 성능 최적화 기능이다. 단, 이 캐시는 일시적이며 새로고침하면 사라진다.