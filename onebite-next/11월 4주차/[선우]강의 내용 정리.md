# 🎯 [한 입 크기로 잘라 먹는 Next.js] - 섹션 4: App Router 시작하기
> 수강일: 2025.11.10

---

## 🧩 섹션 개요
- **섹션 목표:**
  - Next.js 13부터 도입된 App Router의 구조와 동작 원리를 이해한다.
  - Page Router와의 차이점을 명확히 구분하고, App Router의 핵심인 React Server Component, 폴더 기반 라우팅, 레이아웃 시스템, 데이터 페칭 구조, 페이지 네비게이션 흐름을 익힌다.
  - App Router의 렌더링 모델을 실제 예제 코드로 확인하며 SSR, CSR 등 렌더링 전략의 차이를 체감한다.
- **핵심 학습 포인트:**
  - App Router의 등장 배경과 구조 이해
  - React Server Component의 동작 원리
  - 동적 라우팅 및 쿼리 처리
  - App Router 기반 네비게이션 흐름과 Pre-Fetching 동작 방식
---

## 📌 강의별 정리

### 🔹 강의 1: App Router 시작하기
- **핵심 내용:**
  - **App Router**
    - Next.js 13에서 새롭게 도입된 라우팅 시스템
    - 기존 **Page Router**를 **완전히 대체하는 차세대 라우팅 방식**
    - React Server Component(RSC)를 기반으로 설계되었다.
  - **App Router에서 변경되거나 추가된 개념**
    - 폴더 기반 라우팅 구조(`app/` 폴더)
      - 파일 기반 라우팅은 유지되지만 방식이 다르다.
      - `/pages`가 아닌 `/app` 폴더가 생성된다.
    - `layout.tsx` 기반의 레이아웃 시스템
    - 데이터 페칭 방식 전면 개편(`fetch`, `async component`)
    - React 18 신규 기능 본격 활용
      - **React Server Component(핵심)**
      - Streaming / Suspense 개선
  - **App Router에서도 유지되는 기능**
    - 네비게이션
    - 프리페칭
    - 사전 렌더링
- **코드 예제:**
  - **프로젝트 생성**
    ```bash
    npx create-next-app@latest project-name
    ```
- **내가 이해한 포인트:**
  - App Router는 RSC 기반이기 때문에 기존 Page Router보다 구조적으로 훨씬 단순하면서도 더 강력한 데이터 페칭ㆍ렌더링 전략을 제공한다.
  - 서버 컴포넌트 중심 설계가 App Router의 핵심이다.

---

### 🔹 강의 2: 페이지 라우팅 설정하기
- **핵심 내용:**
  - **Page Router 라우팅**
    - `pages/` 폴더의 파일 구조가 그대로 라우팅 경로로 매핑된다.
    - 동적 라우팅은 파일명을 `[id].tsx`처럼 대괄호고 감싸 처리한다.
    - 예시:
    ![](https://velog.velcdn.com/images/iamsunwoo/post/900d7e58-e538-4d2f-827e-941b2d9e185f/image.png)
  - **App Router 라우팅**
    - `app/` 폴더 기반의 폴더 구조 라우팅 방식을 사용한다.
    - 각 폴더에 `page.tsx` 파일이 존재하면 그 폴더가 하나의 라우트가 된다.
    - 예시:
    ![](https://velog.velcdn.com/images/iamsunwoo/post/3b34a494-884a-4bfe-b202-bc1b3af62548/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/94b97dbc-d5fe-4bca-9d74-1310adbacb50/image.png)
  - **App Router에서 동적 URL 처리 방식**
    - App Router 에서는 페이지 컴포넌트에 URL 파라미터나 쿼리 스트링은 Props로 전달된다.
    - **페이지 컴포넌트에 전달되는 Props의 형태**
      ```ts
      export default function Page({
        params,
        searchParams,
      }: {
        params: Promise<{ slug: string }>
        searchParams: Promise<{ [key: string]: string | string[] | undefined }>
      }) {
        return <h1>My Page</h1>
      }
      ```
      - `params`와 `searchParams`는 **Promise 객체**이기 때문에 접근 시, `async/await`를 반드시 사용해야 한다.
      - 페이지 컴포넌트를 `async`로 정의하면 서버 컴포넌트로 동작하며, `await params`, `await searchParams`로 안전하게 값을 읽을 수 있다.
- **코드 예제:**
  - **Query String**
    ```ts
    export default async function Page({
      searchParams,
    }: {
      searchParams: Promise<{ q: string }>;
    }) {
      const { q } = await searchParams;
      return <div>Search 페이지: {q}</div>;
    }
    ```
    
  - **URL Parameter**
    ```ts
    export default async function Page({
      params,
    }: {
      params: Promise<{ id: string }>;
    }) {
      const { id } = await params;
      return <div>book/{id} page 입니다.</div>;
    }
    ```
- **내가 이해한 포인트:**
  - App Router는 폴더 기반 라우팅이며, 각 폴더는 하나의 라우트 세그먼트이다.
  - Next.js 15부터 `params` / `searchParams`는 **Promise로 제공**되므로 서버 컴포넌트에서 `async/await`, 클라이언트 컴포넌트에서 `use()`가 필요하다.
  - `searchParams` 사용 시 해당 페이지는 SSR 방식으로 사전 렌더링된다.
- **실무/프로젝트 적용 아이디어:**
  - 검색ㆍ필터링 기반 UI를 구현할 때 `searchParams`를 이용하면 바로 Query String을 처리할 수 있어 SEO에도 유리하고, 데이터를 조합하는 방식도 단순해진다.
---

### 🔹 강의 3: 레이아웃 설정하기
- **핵심 내용:**
  - **`layout.tsx`**
    - 폴더 단위 공통 레이아웃
    - 라우트가 변경되어도 유지된다.
    - 중첩 레이아웃 구성이 가능하다.
    - 해당 파일 내에서 페이지 컴포넌트의 위치를 반드시 명명해야 한다.
    ![](https://velog.velcdn.com/images/iamsunwoo/post/7246f86b-46c0-4cc8-8004-38be0ffc6367/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/adc5be42-8d2e-4703-a721-020ed3bddfad/image.png)
  - **`RootLayout`(전역 레이아웃)**
    - `/app/layout.tsx`
    - 앱 전체에 기본 적용되는 전역 레이아웃으로 필수적으로 존재해야한다.
  - **라우트 그룹**
    - 폴더명을 괄호로 묶어서 사용: `(group)`
    - URL 경로에는 영향을 주지 않지만 폴더 단위로 관리가 가능하다.
    - `/(auth)/login/page.tsx` → `/login`
- **코드 예제:**
  - `layout.tsx`
    ```ts
    export default function Layout({ children }: { children: ReactNode }) {
      return (
        <div>
          <div>공통 영역</div>
        {children}
        </div>
      );
    }
    ```
- **내가 이해한 포인트:**
  - App Router의 핵심 장점은 레이아웃 유지이며, 이를 통해 페이지 전환 시 불필요한 컴포넌트 언마운트가 사라져 UX가 대폭 개선된다.
  - Route Group은 URL을 깔끔하게 유지하면서도 기능ㆍ도메인 단위로 구조를 정리할 수 있기 때문에 실제 프로젝트 구조화에 매우 유용하다.

---

### 🔹 강의 4: 리액트 서버 컴포넌트 이해하기
- **핵심 내용:**
  - **React Server Component(RSC)**
    - App Router의 모든 컴포넌트는 기본적으로 서버 컴포넌트이다.
    - 서버에서 사전 렌더링 시 딱 한번만 실행되므로 브라우저 JS Bundle에 포함되지 않는다.
    - 클라이언트 전용 기능(`useEffect`, `useState`, Web API 등) 사용이 불가하다.
  - **Page Router 시절의 문제점**
    - 모든 React 컴포넌트가 클라이언트에서도 실행되기 때문에 상호작용이 없는 컴포넌트도 JS 번들을 증가시킨다.
    - 따라서, 하이드레이션 비용도 커지게 된다.
  - **Server Component 장점**
    - 서버에서 사전 렌더링 시 한 번만 실행
    - 클라이언트 JS 크기 감소
    - 데이터 페칭 최적화 용이
  - **Client Component가 필요한 경우**
    - 상태, 이벤트 핸들링 등 상호작용 필요할 때만
    - 파일 최상단 `use client` 선언 필요
    
    ![](https://velog.velcdn.com/images/iamsunwoo/post/0f767e84-f068-4d50-a1be-0944b36746ef/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/5bd4eb8c-7ca5-4e27-8690-83201b814b74/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/5d1a9d94-2f4f-4a5e-905f-0b59e037b35f/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/86fa8e22-1b50-41d7-9d76-47ed729ce229/image.png)
 - 파일명이 `page`나 `layout`이 아니면 일반적인 타입스크립트 파일로 간주한다.

- **코드 예제:**
  - 상호작용이 있는 클라이언트 컴포넌트
    ```ts
    'use client';

    import { ChangeEvent, useState } from 'react';

    export default function Searchbar() {
      const [search, setSearch] = useState('');

      const onChangeSearch = (e: ChangeEvent<HTMLInputElement>) => {
        setSearch(e.target.value);
      };

      return (
        <div>
          <input value={search} onChange={onChangeSearch} />
          <button>검색</button>
        </div>
      );
    }
    ```
- **내가 이해한 포인트:**
  - RSC의 목적은 **불필요한 JS 번들 제거 + 서버 중심 렌더링 최적화**라는 점이 핵심이다.
  - RSC를 이해해야 App Router의 렌더링 모델을 정확히 다룰 수 있고, 어떤 로직을 서버로 보내고 어떤 로직을 클라이언트로 남길지가 설계의 핵심이 된다.

---

### 🔹 강의 5: 리액트 서버 컴포넌트 주의사항
- **핵심 내용:**
  - **React Sever Component 주의사항**
    1. **서버 컴포넌트에서 해서는 안 되는 것**
       - 브라우저 API 사용(`window`, `localStorage`, DOM API)
       - `useState`, `useEffect` 등 클라이언트 훅 사용
        ![](https://velog.velcdn.com/images/iamsunwoo/post/8f241e0b-ea95-4563-95d1-1f33d8c3e1f5/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/e45e39d7-0187-4025-b197-d00a9b5c6419/image.png)
    2. **클라이언트 컴포넌트의 실행 방식**
       - 서버에서 사전 렌더링 시 1회
       - 하이드레이션 과정을 위해 클라이언트에서 1회
       → 총 2회 실행된다.
    3. **클라이언트 컴포넌트에서 서버 컴포넌트 import 금지**
       - Next.js는 자동으로 서버 컴포넌트를 클라이언트 컴포넌트로 강등시켜 버린다.
       → JS Bundle 용량이 커지게 된다.
       - 해결: 부모-자식 구조의 `children`으로 조합
    4. **서버 → 클라이언트 컴포넌트 props 전달 시 주의**
       - **직렬화가 불가능한 데이터는 전달이 불가하다.**
       - 함수, Date 객체, Map/Set 등 직렬화 불가
       ![](https://velog.velcdn.com/images/iamsunwoo/post/822193f6-f16e-408b-9ad9-6c18f30b94a2/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/54dfc767-f797-448c-9c12-f8e0ccfb7b01/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/d59a450e-130b-47df-aa1a-147fe18815bf/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/9a21e91e-fdaf-4d93-9cfa-d78a951e39ab/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/9dd6e75d-398d-4f3b-82d3-cd8476555991/image.png)
- **코드 예제:**
  - Server → Client Component로 **전달 가능한 Props**
    ```ts
    <ClientComp username="sunwoo" age={29} tags={['next', 'react']} />
    ```
  - Server → Client Component로 **전달 불가능한 Props**
    ```ts
    <ClientComp onChange={handleOnChange}/>
    ```
- **내가 이해한 포인트:**
  - RSC의 출력은 RSC Payload 포맷으로 직렬화되기 때문에, 전달 가능한 props가 제한될 수밖에 없다.
  - 클라이언트 컴포넌트에서 서버 컴포넌트를 import 하면 의도치 않게 번들 증가가 발생하므로 항상 설계 시 고려해야 한다.
  - 서버에서 데이터 준비 → 클라이언트에서 인터렉션 처리라는 역할 분리가 App Router의 핵심 운영 모델이다.
- **실무/프로젝트 적용 아이디어:**
  - Form, Modal, Dropdown 같은 상호작용 UI만 Client Component로 분리하고, 나머지 UIㆍ데이터 처리는 모두 Server Component로 두면 번들 최적화와 유지보수성이 크게 올라갈 수 있다.

---

### 🔹 강의 6: 네비게이팅
- **핵심 내용:**
  - **App Router의 페이지 이동**
  ![](https://velog.velcdn.com/images/iamsunwoo/post/19cc1996-57d7-4ad6-828c-52d2b22dcf09/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/abf5f910-f31a-4cd6-8cef-90434a00a4be/image.png)
    - 전체적인 네비게이팅 매커니즘은 Page Router와 유사하지만, 서버 컴포넌트가 추가되면서 JS Bundle + RSC Payload가 함께 전달된다.
    ![](https://velog.velcdn.com/images/iamsunwoo/post/fcdc22cd-d3e8-4bf4-bb13-e7fee9c6e36b/image.png)
    - 프로그래매틱한 페이지 이동은 Page Router와 동일하게 `useRouter` 훅을 사용하지만, App Router에서는 `next/navigation`에서 가져와야 한다.
  - **PreFetching**
    - SSR 페이지는 Prefetching 시 **RSC Payload만 전달**하고, **JS Bundle은 전달하
  - App Router의 모든 페이지 컴포넌트는 **Static(기본값)** 또는 **Dynamic** 방식으로 사전 렌더링한다.
- **코드 예제:**
  - **프로그래매틱한 페이지 이동**
    ```ts
    'use client';

    import { useRouter } from 'next/navigation';
    import { ChangeEvent, useState } from 'react';

    export default function Searchbar() {
      const router = useRouter();
      const [search, setSearch] = useState('');

      const onChangeSearch = (e: ChangeEvent<HTMLInputElement>) => {
        setSearch(e.target.value);
      };

      const onSubmit = () => {
        router.push(`/search?q=${search}`);
      };

      return (
        <div>
          <input value={search} onChange={onChangeSearch} />
          <button onClick={onSubmit}>검색</button>
        </div>
      );
    }
    ```
- **내가 이해한 포인트:**
  - App Router에서는 페이지 이동 시 클라이언트 컴포넌트만 JS Bundle을 포함하고, 서버 컴포넌트는 RSC Payload를 받아 필요한 부분만 렌더링한다.
  - 즉, 페이지 전체 리로드 없이 서버에서 필요한 데이터만 갱신하는 구조로, 네트워크 효율과 UX를 동시에 개선한다.

---
### 🔹 강의 7: 한입북스 UI 구현하기
- **핵심 내용:**
  - `useSearchParams`
    - 클라이언트 컴포넌트에서 현재 URL의 Query String 값을 읽을 수 있는 훅이다.
    - `useSearchParams`는 읽기 전용이며, 값을 변경하려면 `router.push()`나 `router.replace()`를 사용해야 한다.
- **코드 예제:**
  ```ts
  'use client';

  import { useSearchParams } from 'next/navigation';

  export default function SearchResult() {
    const searchParams = useSearchParams();
    const query = searchParams.get('q');

    return (
      <div>
        <h1>검색 결과</h1>
        <p>검색어: {query}</p>
      </div>
    );
  }
  ```
- **내가 이해한 포인트:**
  - App Router에서는 쿼리 파라미터 접근 시 `useRouter` 대신 `useSearchParams`를 사용해야 하며, 읽기 전용이기 때문에 상태 변경은 별도 라우팅으로 처리해야 한다.
  - 이 훅은 클라이언트에서만 동작하므로 반드시 `use client` 선언이 필요하다.

---

# 🎯 [한 입 크기로 잘라 먹는 Next.js] - 섹션 5: 데이터 페칭
> 수강일: 2025.11.11

---

## 🧩 섹션 개요
- **섹션 목표:**
  - App Router 환경에서의 데이터 페칭 구조와 최적화 메커니즘을 깊이 이해한다.
  - 기존 Page Router의 `getServerSideProps`, `getStaticProps` 없이도 **서버 컴포넌트 내부에서 안전하고 효율적으로 데이터를 불러오는 방법**을 학습한다.
  - `fetch`의 캐시 전략과 Next.js 내부의 Request Memoization 동작을 구분해서 이해한다.
- **핵심 학습 포인트:**
  - App Router의 서버 기반 데이터 페칭 구조
  - 환경 변수 관리와 보안
  - Next.js 확장 fetch의 캐시 매커니즘 이해
  - Request Memoization의 동작 원리
---

## 📌 강의별 정리

### 🔹 강의 1: 앱 라우터의 데이터 페칭
- **핵심 내용:**
  - **Page Router에서의 데이터 페칭 한계**
    - 기존 Page Router에서는 `getServerSideProps`, `getStaticProps`, `getStaticPaths` 등 **특정 함수 내부에서만 데이터 페칭이 가능**했다.
    - 이러한 제약으로 인해 **컴포넌트 단위 데이터 요청 분리가 어려웠고**, 클라이언트 측에서 불필요하게 중복 요청이 발생하거나, 모든 데이터가 한꺼번에 로드되는 비효율이 존재했다.
  ![](https://velog.velcdn.com/images/iamsunwoo/post/77fa8e3b-ef5f-428c-9fce-d18e62f8d6b8/image.png)
  - **App Router에서의 데이터 페칭 구조**
    - App Router에서는 각 **서버 컴포넌트 내부에서 직접 `fetch`를 호출**할 수 있다. 즉, 더 이상 페이지 전체 단위로 데이터를 받아올 필요 없이, **컴포넌트 단위로 필요한 데이터만 요청**할 수 있다.
    - 서버에서 데이터가 미리 준비된 상태로 HTML이 생성되기 때문에, **클라이언트는 불필요한 데이터 요청 없이 즉시 렌더링**이 가능하다.
  ![](https://velog.velcdn.com/images/iamsunwoo/post/04d857e4-f020-4122-a0b2-9bfe959cf776/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/73a6f430-d796-4a17-af12-25bd6c81b918/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/0f8eab38-ee85-47e5-99b5-d670f45cae92/image.png)
  - **환경 변수 관리(`.env` 설정)**
    - 백엔드 API 요청 시 URL 하드코딩을 방지하기 위해 `.env` 파일에 환경 변수를 선언한다.
    - **서버 전용 환경 변수**는 `NEXT_PUBLIC` 접두사를 붙이지 않는다.
    → Next.js는 이를 **서버 컴포넌트 전용(private)** 환경 변수로 인식한다.
    - 반대로 클라이언트 컴포넌트에서도 접근해야 한다면 `NEXT_PUBLIC_`을 붙여야 한다.
- **코드 예제:**
  - **`.env`**
    ```bash
    NEXT_PUBLIC_API_SERVER_URL=http://localhost:12345
    ```
  - **데이터 페칭 코드**
    ```ts
     const response = await fetch(`${process.env.NEXT_PUBLIC_API_SERVER_URL}/book`);
    ```
- **내가 이해한 포인트:**
  - App Router의 가장 큰 변화는 **데이터 페칭이 페이지 단위가 아닌 컴포넌트 단위로 가능**하다는 점이다.
  - 덕분에 컴포넌트별로 독립적인 데이터 로직을 작성할 수 있다.
  - `.env`를 통해 서버/클라이언트용 변수를 명확히 구분함으로써 **보안성과 유지보수성 모두 향상**된다.
---

### 🔹 강의 2: 데이터 캐시
- **핵심 내용:**
  - **데이터 캐시란?**
    - Next.js의 **App Router에서는 서버 컴포넌트의 fetch 요청 결과를 자동으로 캐싱**한다.
    즉, 동일한 요청이 반복될 경우 백엔드 서버에 다시 요청하지 않고, **Next.js 서버 내부에 저장된 캐시된 데이터를 재활용**한다.
    - 이러한 캐싱 기능은 **Next.js가 자체 확장한 fetch 함수** 덕분에 가능하다.
    → 즉, `axios` 같은 HTTP Request 라이브러리에서는 활용할 수 없다.
    - 캐시 사용을 통해 네트워크 트래픽과 API 호출 횟수를 줄여 **렌더링 속도 및 서버 효율성**을 높일 수 있다.
  - **Next.js의 확장 fetch**
    - App Router에서 사용하는 `fetch`는 **기본 Web API의 fetch가 아닌, Next.js가 확장한 버전**이다.
      - 캐싱
      - ISR
      - Request Memoization
      - On-Demand Revalidation
      같은 다양한 기능이 추가되어 있다.
    - 캐싱 동작은 `fetch`의 **두 번째 인자(옵션 객체)**로 제어할 수 있다.
    - 페칭 로그 기록을 남기려면 `next.config.ts`에서 `logging.fetches`를 활성화할 수 있다.
  ![](https://velog.velcdn.com/images/iamsunwoo/post/eb2303ef-33ce-47a9-ae99-e2bf28f46fb2/image.png)
  
    |옵션|설명|특징|
    |:---|:---|:---|
    |`{ cache: 'no-store' }`|요청 결과를 **캐싱하지 않음**|항상 백엔드로 요청이 발생|
    |`{ cache: 'force-cache'}`|요청 결과를 **무조건 캐싱**|이후 동일 요청 시 캐시 데이터 재사용|
    |`{ next: { revalidate: 3 } }`|일정 주기로 캐시를 **자동 갱신(ISR)**|지정한 초 단위로 데이터 최신화|
    |`{ next: { tags: ['a'] } }`|특정 태그를 기준으로 **On-Demand Revalidate**|API 호출로 캐시 무효화 가능|
 
    - `{ cache: "no-store" }`
    ![](https://velog.velcdn.com/images/iamsunwoo/post/6c1b2171-9072-47b3-805d-e8b2711fabcc/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/6085eb13-5b39-41d4-abe9-5041c2f6cf53/image.png)
      - 매 요청마다 항상 새로운 데이터를 가져온다.
      - 가장 최신 데이터를 보장하지만, 서버 부하가 커질 수 있다.
    - `{ cache: "force-cache" }`
    ![](https://velog.velcdn.com/images/iamsunwoo/post/c173e7cb-d78d-4328-8acd-67708b704ed4/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/3bce129c-13a5-442d-98f3-4eea5a12378f/image.png)
      - 최초 요청 시 데이터를 캐싱(`set`)하고, 이후에는 동일 요청에 대해 **서버 재호출 없이 캐시된 JSON 데이터만 반환**한다.
      - 정적 사이트나 변동이 적은 데이터를 다룰 때 적합하다.
      - 결과 로그에는 `hit`(캐시 사용) 또는 `miss`(캐시 미스)가 표시된다.
   - `{ next: {revalidate: 3 } }`
     - 일정 주기(초 단위)로 캐시를 자동 갱신한다.
     - Page Router의 ISR과 동이한 개념이며, App Router 버전의 ISR이다.
     - 설정된 시간이 지나면 **다음 요청 시점에만** 백엔드로 재요청이 발생한다.
     ![](https://velog.velcdn.com/images/iamsunwoo/post/467026cd-d401-45fa-8ad1-e425941adecb/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/7f206e76-4308-4046-80c7-be7d1f5adec2/image.png)
   - `{ next: { tags: ['a'] } }`
     - **On-Demand Revalidate (수동 캐시 무효화)** 기능이다.
     API 호출을 통해 특정 태그에 해당하는 데이터 캐시를 명시적으로 무효화할 수 있다.
     - 예를 들어, 관리자 페이지에서 책 데이터 갱신 버튼을 클릭했을 때 해당 태그의 캐시를 삭제하고 새로 갱신하도록 설정할 수 있다.
     ![](https://velog.velcdn.com/images/iamsunwoo/post/3cec4519-044f-46f4-8f84-fc1a41c45474/image.png)


- **코드 예제:**
  - **`next.config.ts` - fetch 로깅 활성화**
    ```ts
    import type { NextConfig } from 'next';

    const nextConfig: NextConfig = {
      /* config options here */
      logging: {
        fetches: {
          fullUrl: true,
        },
      },
    };

    export default nextConfig;
    ```
   - `{cache: 'no-store'}`
    ```ts
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_SERVER_URL}/book`,
        { cache: 'no-store' }
      );
    ```
   - `{cache: 'force-cache'}`
    ```ts
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_SERVER_URL}/book/random`,
        { cache: 'force-cache' }
      );
    ```
   - `{next: revalidate: 3}`
    ```ts
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_SERVER_URL}/book/random`,
        { next: { revalidate: 3 } }
      );
    ```
- **내가 이해한 포인트:**
  - App Router의 `fetch`는 단순한 데이터 요청 함수가 아니라, **렌더링 최적화와 캐싱을 통합한 데이터 레이어** 역할을 수행한다.
  - `cache`와 `revalidate` 옵션을 적절히 조합하면 SSR과 ISR의 장점을 모두 누릴 수 있다.
  - **Next.js의 캐시 레이어는 서버 메모리 기반**이며, 빌드/배포 환경에서는 Edge 서버 또는 Vercel 플랫폼의 캐시 스토리지로 확장된다.
- **실무/프로젝트 적용 아이디어:**
  - 변경이 거의 없는 데이터는 `forch-cache`로 캐싱하고, 주기적으로 변하는 데이터(신간 도서, 인기글 등)는 `revalidate`로 주기 갱신 구조를 만든다.
---

### 🔹 강의 3: 리퀘스트 메모이제이션
- **핵심 내용:**
  - **Request Memoization이란?**
    - 하나의 페이지가 렌더링되는 동안, **동일한 API 요청을 여러 번 보내지 않도록 자동으로 중복 호출을 제거하는 기능**이다.
    - App Router의 서버 컴포넌트 구조에서는 여러 계층의 컴포넌트에서 각각 동일한 데이터를 `fetch`할 수 있다.
    이 때, Next.js는 **같은 URL, 같은 옵션의 fetch 요청을 메모이제이션하여 한 번만 수행**하고, 이후 요청들은 이미 가져온 응답을 그대로 재사용한다.
    - 즉, **하나의 렌더링 사이클 내에서만 유효한 일시적 캐시(휘발성 캐시)**로 동작한다.
    ![](https://velog.velcdn.com/images/iamsunwoo/post/ef642567-bfef-446c-bc7b-1fd457ca83f3/image.png)
    - **Request Memoization 미적용 시**
    ![](https://velog.velcdn.com/images/iamsunwoo/post/dbb1a3a5-c0bf-464f-8d53-bba955f5d045/image.png)
    - **Request Memoization 적용 시**
    ![](https://velog.velcdn.com/images/iamsunwoo/post/5bf897aa-5bfd-4d51-b8ac-d191ad40b3dd/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/dfd9a5fb-7cde-44f6-b0a4-242b7ccdf2fd/image.png)
    - 동일한 URL과 옵션으로 `fetch`가 호출되면, Next.js는 한 번의 요청 결과를 메모리 저장한다.
    - 이후 동일한 요청은 실제 네트워크 요청 없이, 캐시된 응답(JSON)을 반환한다.
    - 렌더링이 완료되면 이 임시 메모리는 소멸된다.
    ![](https://velog.velcdn.com/images/iamsunwoo/post/3c469856-409c-4275-90e4-b34493fcb17e/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/8ba390db-d4bc-4ddb-9c68-b6fbebe95f25/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/34601408-75b5-4566-b2da-6d36002fe16e/image.png)



- **코드 예제:**
  ```ts
  // 동일한 fetch가 여러 컴포넌트에서 호출되어도
  // Next.js는 한 번의 요청만 수행함
  const res1 = await fetch(`${process.env.API_SERVER_URL}/book`);
  const res2 = await fetch(`${process.env.API_SERVER_URL}/book`);
  console.log(res1 === res2); // ✅ true (Request Memoization 덕분)
  ```
- **내가 이해한 포인트:**
  - **Data Cache vs Request Memoization 차이**
  
    |구분|Data Cache|Request Memoization|
    |:---|:---|:---|
    |**유효 범위**|여러 요청(렌더링) 간 공유|한 번의 렌더링 사이클 동안만 유효|
    |**지속성**|서버에 저장되어 재사용 가능|렌더링 종료 시 즉시 소멸|
    |**저장 위치**|Next.js 서버 내부의 캐시 레이어|렌더링 컨텍스트 내 메모리|
    |**주요 목적**|API 호출 수를 줄여 성능 향상|같은 페이지 내 중복 호출 방지|
    |**적용 시점**|`fetch` 옵션에 따라 설정 가능|자동 적용(`fetch` 사용 시 내부적으로 수행 됨)
   - Request Memoization은 렌더링 중 중복 fetch 제거에 초점이 맞춰진 기술로, **Data Cache**와는 전혀 다른 개념이다.

---

# 🎯 [한 입 크기로 잘라 먹는 Next.js] - 섹션 6: 페이지 캐싱
> 수강일: 2025.11.11 ~ 2025.11.12

---

## 🧩 섹션 개요
- **섹션 목표:**
- **핵심 학습 포인트:**

---

## 📌 강의별 정리

### 🔹 강의 1: 풀 라우트 캐시 1
- **핵심 내용:**
  - **풀 라우트 캐시(Full Route Cache)란?**
  ![](https://velog.velcdn.com/images/iamsunwoo/post/cd5d6a61-4d60-43e7-b557-d0f4484ed3b5/image.png)
    - Next.js App Router에서 **페이지 전체를 캐싱**하는 기능으로, **서버에서 렌더링된 HTML과 RSC Payload를 통째로 저장**해두었다가 이후 요청 시 그대로 재사용한다.
    - Page Router 시절의 SSG 방식과 유사하지만, App Router에서는 **서버 컴포넌트 구조에 맞게 개선된 캐싱 모델**이다.
    - 즉, 사전 렌더링된 페이지를 **Next.js 서버 자체 캐시 레이어에 저장**하고, 동일한 요청이 들어오면 새로 렌더링하지 않고 **기존 캐시를 그대로 반환**한다.
    - App Router의 Static Page에만 적용할 수 있다.
    ![](https://velog.velcdn.com/images/iamsunwoo/post/a301e0dd-8a10-4556-a4e7-a1d0ae899805/image.png)
  - **Dynamic Page vs Static Page**
  ![](https://velog.velcdn.com/images/iamsunwoo/post/09e3151d-912a-44bb-a1a8-e970efce68dd/image.png)
    - Dynamic Page로 간주되는 경우
      - 특정 페이지가 매 요청마다 렌더링 결과가 달라지는 경우, Next.js는 해당 페이지를 동적 페이지로 판단하여 캐시하지 않는다.
      - 대표적인 조건은 다음과 같다:
        1. **캐시 불가능한 데이터 페칭 사용 시**
           - `fetch`에 `{ cache: 'no-store' }` 옵션을 사용한 경우
           → 항상 최신 데이터를 불러오므로 캐시 불가
           ![](https://velog.velcdn.com/images/iamsunwoo/post/12ded521-d0b5-4b8b-8bdd-e3c42fcf019e/image.png)
        2. **동적 함수 사용 시**
           - 쿠키(`cookies()`), 헤더(`headers()`), 쿼리 스트링(`searchParams`) 등 **요청마다 값이 달라지는 데이터**를 참조하면 Dynamic Page로 분류된다.
           ![](https://velog.velcdn.com/images/iamsunwoo/post/13f9351b-0ed3-49ea-9224-266426f7285c/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/d5e210c0-4d85-418e-a3b7-91c55cd1397b/image.png)
    - Static Page로 간주되는 경우
      - 위의 조건에 해당하는 않는 모든 페이지는 자동으로 **정적 페이지**로 캐싱된다.
      - 즉, 데이터가 항상 동일하고, 요청마다 렌더링이 필요 없는 경우 빌드 시점 또는 최초 요청 시 한 번만 렌더링된다.
      ![](https://velog.velcdn.com/images/iamsunwoo/post/7b7b7d98-1d4d-4ec1-8682-ef9d8b9b4eba/image.png)
   - **풀 라우트 캐시와 Revalidate**
     - 풀 라우트 캐시 또한 revalidate 옵션을 통해 갱신 주기를 지정할 수 있다.
     - `{ next: { revalidate: 60 } }` → 60초가 지난 뒤 새 요청이 들어오면, 백엔드 데이터를 다시 요청해 페이지를 새로 캐싱한다.
     - 이 기능은 ISR과 유사하게 동작한다.
   ![](https://velog.velcdn.com/images/iamsunwoo/post/d8ba102d-33c2-4880-b211-8ddc5a3bf887/image.png)
- **내가 이해한 포인트:**
  - App Router의 풀 라우트 캐시는 사실상 Page Router의 SSG + ISR의 진화 버전이다.
  - 정적 페이지는 빌드 또는 최초 요청 시 한 번만 렌더링되고, 그 결과가 Next.js 서버 내부 캐시에 저장되어 빠르게 재사용된다.
  - 반면, Dynamic Page는 요청마다 렌더링이 발생하므로, 성능보다는 실시간성이 필요한 페이지에 적합하다.

---

### 🔹 강의 2: 풀 라우트 캐시 2
- **핵심 내용:**
  - **`useSearchParams()`**
    - 클라이언트 컴포넌트 전용 훅
    - 브라우저 URL 상태(Query Parameter)를 읽는 훅이기 때문에 서버 컴포넌트에서 바로 사용할 수 없다.
    - 만약 서버 컴포넌트 트리 안에서 사용하려고 한다면 클라이언트 컴포넌트로 분리하거나 **`<Suspense>`**로 감싸야 한다.
  - **`<Suspense>`로 감싸야 하는 이유**
    - 서버 컴포넌트는 빌드 타임에서 사전 렌더링 대상이다.
    - `useSearchParams()`는 클라이언트에서만 평가 가능한 값을 필요로 한다.
    - 그래서 Next.js는 이 훅이 포함된 부분을 **사전 렌더링에서 제외**하기 위해 `<Suspense>` boundary 안으로 분리하도록 요구한다.
    - `<Suspense>`로 감싸진 부분은 
    - `useSearchParams` 훅은 클라이언트 컴포넌트에서만 사용이 가능하나, 서버 컴포넌트에 포함되어 있다면 `<Suspense>` 컴포넌트로 감싸야 한다.
    - `<Suspense`> 로 감싸진 컴포넌트는 사전 렌더링 과정 중에 배제된다.
    - 클라이언트 측에서만 렌더링 된다.
    - `<Suspense>`로 감싸진 부분은
      - 서버 사전 렌더링에서 제외되고
      - 클라이언트에서 비동기적으로 렌더링된다.
  - **`<Suspense>` 특징 정리**
      - Suspense는 미결, 미완성의 뜻을 가지고 있다.
      - Suspense로 감싼 컴포넌트가 준비될 때까지 **fallback UI를 보여주는 장치**
- **코드 예제:**
  - **서버 컴포넌트**
    ```ts
    import { Suspense } from "react";
    import SearchSection from "./SearchSection";

    export default function Page() {
      return (
        <div>
          <h1>검색 페이지</h1>
          <Suspense fallback={<p>Loading search params...</p>}>
            <SearchSection /> // 클라이언트 컴포넌트
          </Suspense>
        </div>
      );
    }
    ```
  - **클라이언트 컴포넌트**
    ```ts
    "use client";
    import { useSearchParams } from "next/navigation";

    export default function SearchSection() {
      const searchParams = useSearchParams();
      const keyword = searchParams.get("q");

      return <div>검색어: {keyword}</div>;
    }
    ```
- **내가 이해한 포인트:**
  - `useSearchParams()`는 브라우저 URL이 필요한 동작이라서 서버에서 실행할 수 없다.
  - 서버 컴포넌트 안에서 직접 사용하면 에러가 발생하기 때문에 **Suspense로 묶어 클라이언트 전용 구간으로 분리**해야 한다.
  - Suspense는 단순히 fallback UI를 위한 것이 아니라 **서버 사전 렌더링에서 제외시키는 경계(boundary) 역할도 수행**
  - 풀 라우트 캐시는 미리 생성 가능한 부분만 캐시하고 **Suspense 내부 클라이언트 컴포넌트는 캐싱 대상에서 제외**된다.

---

### 🔹 강의 3: 풀 라우트 캐시 3. 동적 경로에 적용하기
- **핵심 내용:**
  - **동적 경로에 풀 라우트 캐시 적용하기**
    - `/products/[id]`, `/posts/[slug]` 같은 동적 경로도 빌드 타임에 사전 렌더링하여 풀 라우트 캐시로 저장이 가능하다.
    - **`generateStaticParams`**
      - Page Router의 `getStaticPaths`와 유사하게 동작한다.
      - 반환값은 반드시 객체 배열 형태여야 하며, 각 객체는 동적 세그먼트의 key-value 구조
      - 예:
          ```ts
          export function generateStaticParams() {
            return [{ id: '1' }, { id: '2' }, { id: '3' }];
          }
          ```
      - 반환된 모든 경로는 빌드시 미리 생성되어 라우트 캐시에 저장된다.
      ![](https://velog.velcdn.com/images/iamsunwoo/post/b175ad01-03a9-4208-b191-66b422257d89/image.png)
      - **단, 페칭된 데이터 또한 같이 캐싱된다.**
        - 즉, `fetch()`의 `{ cache: 'force-cache' }`가 기본으로 적용된다.
        - `revalidate`를 명시하지 않으면 **완전 정적(SSG)**으로 취급된다.
      - **잘못된 경로 접근 시 처리**
        - 존재하지 않는 param으로 접근하면 기본적으로 SSR 방식으로 동작한다.
        → Page Router의 `fallback: 'blocking' | true`와 유사하다.
        - 하지만, fallback 없이 404를 반환하고 싶다면:
          - 페이지 컴포넌트에서 라우트 세그먼트 옵션인 `dynamicParams` 값을 false로 설정하면 된다.
          → Page Router의 `fallback: false`와 유사하다.
            ```ts
            export const dynamicParams = false;
            ```
          - 또는 컴포넌트 내부에서 `notFound()` 직접 호출
- **코드 예제:**
  - **동적 경로를 빌드 타임에 정적으로 생성**
    ```ts
    export function generateStaticParams() {
      return [
        { id: '1' },
        { id: '2' },
        { id: '3' },
      ];
    }

    export default async function ProductPage({ params }) {
      const { id } = params;

      // 이 fetch는 자동으로 SSG 캐시됨
      const product = await fetch(`https://api.example.com/products/${id}`)
        .then(res => res.json());

      return <div>{product.name}</div>;
    }
    ```
- **내가 이해한 포인트:**
  - App Router에서도 동적 경로를 SSG 방식으로 사전 렌더링 할 수 있다.
  - `dynamicParams: false`는 사전 정의된 것 외의 경로는 절대 허용하지 말라는 의미이다.
  - 데이터 페칭 또한 자동으로 강제 캐싱된다는 점이 핵심이다.

---

### 🔹 강의 4: 라우트 세그먼트 옵션
- **핵심 내용:**
  - **라우트 세그먼트 옵션**
    - Next.js App Router에서 각 페이지(또는 레이아웃)에 대해
    **렌더링 방식ㆍ캐싱 전략ㆍ정적/동적 여부를 강제로 지정할 수 있는 설정**이다.
    - App Router는 기본적으로 페이지 내부에서 사용된 코드를 기준으로
    **페이지가 Static인지 Dynamic인지 자동 판별**한다.
    - 하지만, 이 자동 판별을 덮어쓰고 개발자가 직접 강제하고 싶을 때 라우트 세그먼트 옵션을 사용한다.
    - 주요 옵션
      1. `dynamicParams`
         - 동적 경로에서 사전 생성된 params 외의 값 접근 허용 여부
         - `false`로 설정하면 `generateStaticParams` 목록 외의 URL은 자동으로 404(Not Found) 처리된다.
      2. `dynamic`
          - 페이지의 동적/정적 렌더링 방식으로 강제로 지정하는 옵션
          - App Router는 보통 자동으로 Static/Dynamic 여부를 판단하지만, 특정 페이지 동작을 직접 제어해야 할 때 사용한다.
          - `auto`(기본값)
            - Next.js가 페이지 코드를 분석하여 Static/Dynamic을 자동 결정한다.
          - `force-dynamic`
            - 무조건 Dynamic 페이지로 처리
            - 즉, 빌드 시 정적 생성되지 않고 매 요청마다 서버에서 렌더링
            - 캐싱 불가능한 데이터, 쿠키 사용 등 동적 환경에서 유용
          - `force-static`
            - 페이지를 강제로 Static 페이지로 고정
            - 페이지 내부에서 동적 함수를 사용하면 **예기치 못한 오류**가 발생할 수 있다.
            → 정적일 수 없는 페이지를 억지로 정적으로 만들었기 때문
          - `error`
            - 페이지를 Static으로 만들려고 시도하되,
            만약 Static 조건을 충족하지 못한다면 빌드 에러를 발생시키고 명확한 이유를 알려달라는 옵션
            - 즉, `force-static`보다 안정적이다.
      3. `revalidate`
         - 정적 페이지라도 `revalidate`로 재생성 주기(ISR)를 지정할 수 있다.
- **코드 예제:**
  - **특정 페이지를 강제로 Dynamic 페이지로 설정**
    ```ts
    export const dynamic = 'force-dynamic';
    ```
  - **특정 페이지를 Static으로 고정하고, 정적 조건 불충족 시 오류 발생**
    ```ts
    export const dynamic = 'error';
    ```
  - **정적 페이지에 revalidate 주기 설정**
    ```ts
    export const dynamic = 60; // 60초마다 재생성
    ```
- **내가 이해한 포인트:**
  - App Router는 기본적으로 페이지 안에 동적인 요소가 있는지를 스스로 판단해 Static/Dynamic을 결정한다.
  - 하지만 페이지의 용도에 따라 정적/동적 타입을 개발자가 직접 강제할 필요가 있을 때 라우트 세그먼트 옵션을 사용한다.

---

### 🔹 강의 5: 클라이언트 라우터 캐시
- **핵심 내용:**
  - **클라이언트 라우터 캐시**
    - Next.js App Router는 페이지 이동 시 성능을 높이기 위해, 브라우저에서 **라우팅에 필요한 일부 데이터를 보관**해둔다.
    - 클라이언트 라우터 캐시는 다음 데이터를 저장한다:
      1. **RSC Payload(서버 컴포넌트 결과물)**
         - 서버에서 내려주는 RSC의 결과를 브라우저에 저장
         - 중복된 페이지 이동 시 같은 내용을 다시 요청하지 않도록 한다.
      2. **공통 레이아웃 구조**
         - 한 번 방분한 페이지의 레이아웃들은 캐시에 남아 다음 페이지 이동 시 **동일한 레이아웃을 재요청하지 않는다.**
    - App Router는 페이지를 이동할 때 전체 HTML을 다시 받지 않고, **변경된 서버 컴포넌트 데이터(RSC Payload)만 교체**하여 UI를 갱신한다.
    - **특징**
      - 클라이언트 라우터 캐시는 **브라우저 메모리에 저장**된다.
      - 따라서 **페이지 새로고침**시, 캐시는 모두 초기화된다.
      - 뒤로 가기 / 앞으로 가기 등은 캐시가 남아있어 즉시 렌더링된다.
      ![](https://velog.velcdn.com/images/iamsunwoo/post/f127ae8a-c1d8-40cf-b195-9c24b657c2fc/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/0880f3ec-863d-4886-9288-6b1461b5ddaf/image.png)
- **코드 예제:**
  - **클라이언트 라우터 캐시 정상 동작 확인**
    - 레이아웃에서 시간을 출력하면 페이지 전체가 리렌더링되는지 확인 가능하다.
      ```ts
      import { ReactNode, Suspense } from 'react';
      import Searchbar from '../../components/searchbar';

      export default function Layout({ children }: { children: ReactNode }) {
        return (
          <div>
            <div>{new Date().toLocaleString()}</div>
            <Suspense fallback={<div>Loading...</div>}>
              <Searchbar />
            </Suspense>
            {children}
          </div>
        );
      }
      ```
- **내가 이해한 포인트:**
  - 클라이언트 라우터 캐시는 **SPA의 빠른 페이지 이동**을 가능하게 하는 핵심 요소이다.
  - RSC Payload와 레이아웃 구조가 브라우저에 저장되면서 이미 방문한 페이지는 훨씬 빠르게 이동할 수 있다.
  - 하지만, 이 캐시는 일시적이며 새로고침하면 사라진다.

---
