# Section 4. App Router 시작하기

## App Router 시작하기

- Next.js 13(2022.10) 버전에 새롭게 추가된 라우터
- 기존의 Page Router를 완전히 대체함

변경되거나 추가되는 사항

- 데이터 페칭 방식 변경
- 레이아웃 설정 방식 변경
- 페이지 라우팅 설정 방식 변경
- React 18 신규 기능 추가
    - React Server Component
    - Streaming

크게 변경되지 않는 사항

- 네비게이팅
- 프리페칭
- 사전 렌더링

```tsx
npx create-next-app@latest section03
```

## 페이지 라우팅 설정하기

page.tsx 만 ~/에 대응함

- search/page.tsx 만들어야 ~/search에 대응
- 동적 경로 설정 방법: app/book/[id]/page.tsx

props → promise 객체로 반환

서버 컴포넌트인 경우 async 키워드를 붙일 수 있다

catch all segment

```tsx
book/[...id]
// -> book/이하에 나오는 것들은 다 [...id] 디렉토리 내의 page.tsx에 대응

book/[[...id]]
// -> book 이하에 아무 것도 없어도 404가 뜨지 않음
```

## 레이아웃 설정하기

/app/search/layout.tsx

- search 페이지의 레이아웃으로 자동 설정
- /search 경로로 시작하는 모든 페이지의 레이아웃으로 적용 됨
- 레이아웃 중첩 가능

![스크린샷 2025-11-16 03.47.24.png](attachment:d48b79a6-bc39-40fa-8aea-11cff1dd9841:스크린샷_2025-11-16_03.47.24.png)

```tsx
// layout.tsx -> 자동 생성
  
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
```

라우트 그룹(route group)

- with-searchbar
- 경로 상에는 아무런 영향을 주지 않으면서, 레이아웃만 변경

→ 라우트 그룹을 여러 개 설정하면 어떻게 되는가..?

## 리액트 서버 컴포넌트 이해하기

React Server Component

- React 18v 부터 새롭게 추가된, 새로운 유형의 컴포넌트
- 서버측에서만 실행되는 컴포넌트(브라우저에서 실행 X)
- 나머지는 클라이언트 컴포넌트라고 부르자 (지금까지 써오고 있었던 일반적인 리액트 컴포넌트)

server component 이전의 이야기

- page router 버전의 next.js에는 어떤 문제가 있었을까?
- JS Bundle이 꼭 다 필요할까?
- 상호작용이 없는 정적인 컴포넌트는 굳이 브라우저에서 하이드레이션 될 필요가 없다.

→ 서버 컴포넌트는 서버측에서 사전 렌더링을 진행할 때 딱 한번만 실행

→ 클라이언트 컴포넌트는 사전 렌더링 진행할 때 한 번, 하이드레이션 진행할때 한 번해서 총 두 번 실행

→ 페이지의 대부분을 서버 컴포넌트로 구성할 것을 권장, 클라이언트 컴포넌트는 꼭 필요한 경우에만 사용할 것

앱 라우터에서는 기본적으로 모든 컴포넌트가 다 서버 컴포넌트로 작동

- useEffect hook은 클라이언트 컴포넌트에서 사용
- “use client”

어떤 컴포넌트가 서버 컴포넌트?

- 상호작용이 있어야 하면 클라이언트 컴포넌트
    - 링크는 HTML 고유의 기능
- search bar : 실시간으로 입력을 state에 보관하고 있다가 엔터를 누르면 on key down 이벤트 핸들러가 작동해서 페이지를 프로그래매틱하게 이동 → 서버 컴포넌트로 만들어야 함

co-location

- 앱 라우터에서 파일의 이름이 페이지나 레이아웃이 아니면 그냥 일반적인 자바스크립트, 타입스크립트 파일로 간주 → 컴포넌트를 위한 파일도 앱 폴더 안에 만들어 둬도 된다

## 리액트 서버 컴포넌트 주의사항

1. 서버 컴포넌트에는 브라우저에서 실행될 코드가 포함되면 안된다
    - useState, useEffect, eventHandler
    - 라이브러리가 브라우저 측에서 실행되는 기능을 담고 있을 때
2. 클라이언트 컴포넌트는 클라이언트에서만 실행되지 않는다
    - 사전 렌더링을 위해 서버에서 1번 실행
    - 하이드레이션을 위해 브라우저에서 1번 실행
    
    → 서버와 클라이언트에서 모두 실행됨
    
3. 클라이언트 컴포넌트에서 서버 컴포넌트를 import 할 수 없다
    - 클라이언트 컴포넌트가 하이드레이션을 할 때, 서버 컴포넌트의 코드는 없는 코드
    - 서버 컴포넌트의 코드는 브라우저에게 전달되지 않기 때문
    
    → 근데 오류를 발생기키면 불편하므로, next.js는 자동으로 서버 컴포넌트를 클라이언트 컴포넌트로 변경
    
4. 서버컴포넌트에서 클라이언트 컴포넌트에게 직렬화 되지 않는 props는 전달 불가하다
    - 직렬화(serializtaion): 객체, 배열, 클래스 등의 복잡한 구조의 데이터를 네트워크 상으로 전송하기 위해 아주 단순한 형태(문자열, Byte)로 변환하는 것
    - 자바스크립트 함수는 직렬화가 불가능 함
        - 코드 블럭을 포함하는 형태이기 때문
        - 클로저, 렉시컬 스코프 등의 다양한 환경에 의존해있음
    - 직렬화가 불가능한 함수 값은 서버 컴포넌트에서 클라이언트 컴포넌트로 전달되는 props가 될 수 없음

클라이언트 컴포넌트의 개수가 많아지면 많아질 수록 브라우저에게 전달되는 자바스크립트 번들 용량이 커짐 → 하이드레이션까지 걸리는 시간이 오래 걸림

→ 최대한 될 수 있을 만큼 많은 컴포넌트를 서버 컴포넌트로 유지시켜서 자바스크립트 번들 용량을 줄여야 함

→ 서버 클라이언트 import 하지말고, children props로 받아서 렌더링하자

```tsx
"use client";

import { ReactNode } from "react";

export default function ClientComponent({
  children,
}: {
  children: ReactNode;
}) {
  console.log("클라이언트 컴포넌트!");
  return <div>{children}</div>;
}
```

사전 렌더링 과정 중

- 서버 컴포넌트들 따로 실행(RSC payload) → HTML 페이지 완성

RSC Payload

- React Server Component의 순수한 데이터(결과물)
- React server Component를 직렬화 한 결과
- RSC Payload에는 서버 컴포넌트의 모든 데이터가 포함
    - 서버 컴포넌트의 렌더링 결과
    - 연결된 클라이언트 컴포넌트의 위치
    - 클라이언트 컴포넌트에게 전달하는 props 값

## 네비게이팅

페이지 이동은 client side rendering 방식으로 처리 (page router 버전과 동일한 방식)

![스크린샷 2025-11-16 08.46.08.png](attachment:a00b9697-1b3e-4a17-ab8d-06311513619a:스크린샷_2025-11-16_08.46.08.png)

앱라우터 버전에서는 Next.js 서버가 브라우저에게 JavaScript 번들 파일만 전달하는 것이 아니라, RSC Payload를 함께 전달

→ 서버 컴포넌트를 브라우저에게 보내주기 위해서 RSC Payload + JS Bundle 전달

```tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";

export default function Searchbar() {
  const router = useRouter();
  const [search, setSearch] = useState("");

  const onChangeSearch = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearch(e.target.value);
  };

  const onSubmit = () => {
    router.push(`/search?q=${search}`);
  };

  return (
    <div>
      <input value={search} onChange={onChangeSearch} />
      <button onClick={onSubmit}>검색</button>
    </div>
  );
}
```

다이나믹 페이지는 프리페칭되지 않는다

## 한입북스 UI 구현하기

queryString을 불러올 때 useSearchParams hook 사용

```tsx
"use client";

import { useEffect, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import style from "./serachbar.module.css";

export default function Searchbar() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [search, setSearch] = useState("");

  const q = searchParams.get("q");

  useEffect(() => {
    setSearch(q || "");
  }, [q]);

  const onChangeSearch = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearch(e.target.value);
  };

  const onSubmit = () => {
    if (!search || q === search) return;
    router.push(`/search?q=${search}`);
  };

  const onKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter") {
      onSubmit();
    }
  };

  return (
    <div className={style.container}>
      <input
        value={search}
        onChange={onChangeSearch}
        onKeyDown={onKeyDown}
      />
      <button onClick={onSubmit}>검색</button>
    </div>
  );
}
```

# Section 5. 데이터 페칭

## 앱 라우터의 데이터 페칭

- App Router 버전의 Next.js App 에서는 Server Component로 인해 많은 변화가 발생

Page Router에서 데이터 페칭

1. SSR(서버 사이드 렌더링)
    
    ```tsx
    export async function getServerSideProps(){
    	return {props: {...}}
    }
    ```
    
2. SSG(정적 사이트 생성)
    
    ```tsx
    export async function getStaticProps(){
    	return {props: {...}}
    }
    ```
    
3. Dynamic SSG(동적 경로에 대한 정적 사이트 생성)
    
    ```tsx
    export async function getStaticPaths(){
    	return {paths : [...], fallback:...}
    }
    ```
    

클라이언트 컴포넌트에는 Async 키워드를 사용할 수 없었음

- 브라우저에서 동작 시 문제를 일으킬 수 있기 때문에 권장되지 않음

```tsx
// 서버 컴포넌트 (+ 비동기 함수)

export async function Page(props){
	const data = await fetch('...');
	
	return <div>...</div>
}
```

Next.js 공식 문서

- Fetching data where its’ needed → best practice

```tsx
import BookItem from "@/components/book-item";
import style from "./page.module.css";
import books from "@/mock/books.json";
import { BookData } from "@/types";

async function AllBooks() {
  const response = await fetch(
    `${process.env.NEXT_PUBLIC_API_SERVER_URL}/book`
  );
  if (!response.ok) {
    return <div>오류가 발생했습니다 ...</div>;
  }

  const allBooks: BookData[] = await response.json();
  return (
    <div>
      {allBooks.map((book) => (
        <BookItem key={book.id} {...book} />
      ))}
    </div>
  );
}

async function RecoBooks() {
  const response = await fetch(
    `${process.env.NEXT_PUBLIC_API_SERVER_URL}/book/random`
  );
  if (!response.ok) {
    return <div>오류가 발생했습니다...</div>;
  }

  const recoBooks: BookData[] = await response.json();
  return (
    <div>
      {recoBooks.map((book) => (
        <BookItem key={book.id} {...book} />
      ))}
    </div>
  );
}

export default function Home() {
  return (
    <div className={style.container}>
      <section>
        <h3>지금 추천하는 도서</h3>
        <RecoBooks />
      </section>
      <section>
        <h3>등록된 모든 도서</h3>
        <AllBooks />
      </section>
    </div>
  );
}
```

환경변수: NEXT_PUBLIC_API_SERVER_URL

- next public이라는 접두사를 붙이지 않으면 next는 자동으로 해당 환경 변수를 서버 측에서만 활용할 수 있게 프라이빗으로 설정 → 클라이언트 컴포넌트에서는 환경 변수에 접근할 수 없다
- next public이라는 접두사를 붙여야 클라이언트 컴포넌트에 쓸 수 있음

## 데이터 캐시

- fetch 메서드를 활용해 불러온 데이터를 NEXT 서버에서 보관하는 기능
- 영구적으로 데이터를 보관하거나, 특정 시간을 주기로 갱신 시키는 것도 가능
- 불필요한 데이터 요청의 수를 줄여서 웹 서비스의 성능을 크게 개선할 수 있음
- fetch의 두 번째 인수에 cache 옵션을 줘서 사용

```tsx
const response = await fetch(`~/api`, {cache: "force-cache"});
```

- cache: “force-cache”
    - 요청의 결과를 무조건 캐싱함
    - 한 번 호출 된 이후에는 다시는 호출되지 않음
- cache: “no-store”
    - 데이터 페칭의 결과를 저장하지 않는 옵션
    - 캐싱을 아예 하지 않도록 설정하는 옵션
- next: { revalidate: 3} };
    - 특정 시간을 주기로 캐시를 업데이트 함
    - 마치 Page Router의 ISR 방식과 유사
    - STABLE → SET → HIT
- next: { tags: [’a’’] }}
    - on demand revalidate
    - 요청이 들어왔을 때 데이터를 최신화 함

데이터 캐시의 기본 값이 캐싱을 하지 않는 것

## 리퀘스트 메모이제이션

- request memoization
- 요청을 기억한다
- 하나의 페이지를 렌더링 하는 동안에 중복된 API 요청을 캐싱하기 위해 존재
- 렌더링이 종료되면 모든 캐시가 소멸
- 그냥 중복 요청을 안 보내면 되는 거 아닌가?
    - 서버 컴포넌트의 도입 때문
    - 앱 라우터에서는 각 컴포넌트에서 요청을 보내도록 함
    - 서로 다른 컴포넌트에서 같은 요청을 보낼 때가 있다
