# 한 입 크기로 잘라 먹는 Next.js(v15)

next.js에서 제공하는 라우터

### 1. 페이지 라우터

- 초창기부터 제공되어 오던 예전 버전의 라우터

### 2. 앱 라우터

- Next 13 버전과 함께 처음으로 공개된 신규 라우터
- 리액트 서버 컴퍼넌트나 스트리밍 등의 아주 다양하고도 새로운 기능들이 제공

신규 버전인 App Router는 사실 과거 버전인 페이지 라우터의 단점을 보완하기 위해서 등장

- 어떤 부분에서 무엇이 나아졌는 지 파악하는 데 도움
- 앱 라우터는 아직 과도기 → 둘 다 배우자

# Next.js를 소개합니다

React.js를 보다 더 강력하고 편하게 사용할 수 있는 기능들을 제공 → React의 확장판

- 페이지 라우팅
- 빌트인 최적화 기능
- 다이나믹 HTML 스트리밍
- …

vercel에서 개발해서 오픈소스로 관리 중

카카오 웹툰, velog, inflearn, opgg …

어떻게 이렇게 많은 사랑을 받을까? → Next.js는 Library가 아닌 Framework이기 때문

Framework, Library 차이 → 기능 구현의 주도권이 누구에게 있는가

- 주도권이 개발자에게 있다: library
- 주도권이 개발자에게 없다: framework

**Framework**

- ex) Next.js, Remix …
- 주도권을 Framework가 가짐 → framework가 제공하는 기능을 이용하거나 허용하는 범위 내에서만 추가 도구 사용 가능
- Next.js에서 페이지 라우팅 기능을 구현해야 함 → Next.js가 제공하는 라우터 사용
- 자유도가 낮다 → 거의 모든 기능을 제공 → Page Routing, Optimizations, Server Pre Rendering 등 기본 제공 → 빠르게 웹 서비스 구축 가능

**Library**

- React.js, JQuery …
- 개발자가 하고 싶은 대로 구현 가능
- 자유도가 높다 → 기본 기능 외 제공 X

## 사전 렌더링 이해하기

- 브라우저의 요청에 사전에 렌더링이 완료된 HTML을 응답하는 렌더링 방식
- Client Side Rendering의 단점을 효율적으로 해결하는 기술

Client Side Rendering(CSR)

- React.js 앱의 기본적인 렌더링 방식
- 클라이언트(브라우저)에서 직접 화면을 렌더링 하는 방식
- user → browser에게 접속 요청 → server index.html, JS Bundle 보내줌 → 브라우저에서 JS 실행 → 컨텐츠 렌더링

SSR

- JS Bundle에 웹 사이트에 필요한 전체 코드 보유
- 브라우저는 이미 리액트 앱을 가지고 있고, 페이지 이동을 해도 브라우저 자체적으로 JS 실행 및 렌더링
- 초기 접속 이후에 페이지 이동을 빠르게 제공
- 초기 접속 속도가 느려짐 (요청 시 접속 요청 → index.html, JS Bundle 서버가 전송 → JS 실행 → 컨텐츠 렌더링 모두 해야함)
- FCP(First Contentful Paint) → 사전 렌더링
    - ‘요청 시작’ 시적으로 부터 컨텐츠가 화면에 처음 나타나는데 걸리는 시간
    - FCP 3, 5, 6, 10sec 이상일 경우 이탈률 32%, 90%, 106, 123% 증가

사전 렌더링

- 접속 요청 → JS 실행(렌더링) → 렌더링 된 HTML → 화면에 렌더링 → FCP 감소 → JS Bundle → JS 실행(HTML과 연결/수화)
    
    ![스크린샷 2025-11-09 01.02.05.png](attachment:57772f45-95d4-4dac-92c0-280a5af97595:스크린샷_2025-11-09_01.02.05.png)
    
- 렌더링:
    1. JS 실행(렌더링): 자바스크립트 코드(React 컴포넌트)를 HTML로 변환하는 과정
    2. 화면에 렌더링: HTML 코드를 브라우저가 화면에 그려내는 작업
- TTI(Timer to interactive)
    - 요청~hydration 적용 시간까지의 시간

페이지 이동 요청 → 클라이언트 사이드 렌더링 방식으로 처리

### **🧩 React (CSR)**

1️⃣ HTML(빈 root div) 다운로드

2️⃣ JS 번들 다운로드

3️⃣ API 요청

4️⃣ 브라우저에서 HTML 구성 + 렌더링

5️⃣ 사용자에게 보임

### **⚡ Next.js (SSR/SSG)**

1️⃣ 서버(또는 빌드 단계)에서 HTML+데이터 미리 생성

2️⃣ 완성된 HTML 바로 응답

3️⃣ JS 번들 다운로드

4️⃣ Hydration으로 상호작용 연결

## 실습용 백엔드 서버 세팅하기

실습용 백엔드 서버가 필요한 이유

- next 서버와 백엔드 서버 연결 시 최적화 기능 제공

# 섹션 3. Page Router 핵심 정리

## Page Router를 소개합니다

Page Router

- 현재 많은 기업에서 사용되고 있는 안정적인 라우터
- React Router 처럼 페이지 라우팅 기능 제공
- Pages 폴더 기준 파일, 폴더명 기반 자동 라우팅
- 동적 경로(Dynamic Routes)
    - `[id].js` 형식으로 파일 작성

`npx create-next-app@14 section02` 

- 가장 안정적인 버전 14
- 페이지 라우터 사용 위함

`_app.tsx` 

- 루트 컴포넌트
- 모든 페이지의 부모 컴포넌트
- component: page
- pageProps: component에 들어가는 props를 객체로 보관
- 헤더 같은 모든 페이지에 나타나야 하는 컴포넌트는 _app.tsx에 작성

`_document.tsx` 

- index.html과 비슷
- 페이지 전체에 적용되는 html 태그 작성

## 페이지 라우팅 설정하기

- 폴더 아래에 index.tsx 생성하면 자동으로 폴더 이름으로 라우팅 된다
- URL에  `?q` 와 같이 작성하면 쿼리를 전달할 수 있음

```tsx
import { useRouter } from "next/router";

export default function Page() {
  const router = useRouter();
  const { q } = router.query;
  return <h1> search {q}</h1>;
}
```

- 가변적 값을 포함하는 동적 경로 → urlParameter
- 여러 동적 파라미터를 고려하는 방법 → catch all segment → `[...id].tsx`
    - id 는 배열 형태로 전달된다
- 완전히 범용적인 페이지 → optional cath all segment → ``[[...id]].tsx`

- 404.tsx로 404 라우팅 가능

## 네비게이팅

- `<a>` 태그는 클라이언트 사이드 렌더링 방식으로 이동시키는 게 아닌, 서버에게 새로운 페이지를 매번 다시 요청하는 방식으로 이동 → 느림 → 링크 컴포넌트 사용
- `<Link href = "/"} index</Link>`

programmatic Navigation

- 사용자가 링크를 직접 클릭했을 때 페이지를 이동시키는 방식이 아니라 특정 버튼이 클릭이 되었거나 특정 조건이 만족했을 경우 어떤 함수 내부에서 페이지를 이동시키는 방법

```tsx
  const onClickButton = () => {
    router.push("/test");
  }
  
  <button onClick={onClickButton}>/test</button>
```

## 프리페칭(Pre-Fetching)

- 사전에 불러온다
- 사용자가 보고있는 페이지 내에서 이동할 가능성이 있는 모든 페이지들을 사전에 미리 다 불러놓는 기능
- 현재 페이지에서 이동이 가능한 모든 페이지들에 필요한 데이터를 미리 다 불러 놓음으로써 페이지 이동을 매우 빠른 속도로 지체없이 처리해주기 위함
- 왜 프리패칭이 필요할까?
    - next.js에서는 html 페이지 응답 이후 후속으로 모든 자바스크립트 코드를 번들 파일 형태로 전달해주고, 그래서 브라우저가 서버에게 추가 리소스를 요청할 필요가 없는데?
    - next.js는 모든 리액트 컴포넌트들을 페이지별로 스플리팅 해서 저장을 미리 해두기 때문
    - 현재 페이지에 해당하는 자바스크립트 코드들만 전달된다
        - 전달되는 자바스크립트 코드 양을 줄이기 위함
        - JavaScript 코드를 매번 다 번들링해서 전달하면?
            - 한 번에 전달되는 파일 용량이 커짐
            - 브라우저에서 다운로드 속도 느려짐
            - JavaScript 코드를 실행해서 HTML과 연결하는 하이드레이션 과정 오래걸림
            - TTI(유저가 앱에 상호작용할 수 있게 되는 시간) 늦어짐

<aside>

1. 사전 렌더링은 초기 접속 요청 시에 모든 페이지에 대한 자바스크립트 파일이 다 전달되는 것이 아니었다
2. 현재 접속 요청이 발생한 페이지에 해당하는 자바스크립트 번들 파일만 전달이 된다
3. 프리패칭으로 현제 페이지에서 이동할 수 있는 모든 페이지에 대한 자바스크립트 코드를 사전에 미리 다 불러온다
</aside>

npm run dev로 개발모드로 가동해 놓고 있을 때에는 프리패칭이 동작하지 않음(매번 자원을 불러온다) → build, production 모드 앱 구동 필요

production 방법

- npm run build
- npm run start

프로그래메틱하게 이동시키는 페이지에 대해서도 프리패칭을 시키고 싶을 때

- `router.prefetch("/test");` 로 프리패칭 설정 가능

프리패칭 해제 방법

- `prefetch={false}`

## API Routes

- next.js에서 API를 구축할 수 있게 해주는 기능
- 간단한 API를 구축해서 클라이언트(브라우저)로 부터 요청을 받아 데이터베이스에서 데이터를 꺼내올 수 있음
- 서드파티에 데이터를 불러와서 전달 가능

/api 내부의 경로로 api 요청하면 해당 파일의 함수가 실행 되어서 api 작동

## 스타일링

- inline 스타일링 → 가독성 불편
- css 파일로 분리 → next에서는 오류
- Next.js에서는 App 컴포넌트가 아닌 index.tsx 같은 파일에서는 import문을 통해서 css 파일 불러오는 것을 제한
    - 별도의 페이지파일에서 css를 그대로 불러와서 import 하고 있을 경우 다른 페이지에 작성된 css 코드와 충돌을 일으킬 수 있기 때문
    - 페이지를 이동할 때 css 파일이 함께 로딩이 되면, 클래스 네임들이 서로 충돌 가능
    - 대신 app 컴포넌트에서는 모든 페이지에 다 적용되는 컴포넌트이기 때문에, global.css만 예외적으로 불러올 수 있음
- next.js가 기본적으로 제공하는 css 모듈 기능 활용
    - css 파일에 작성해둔 클래스 네임들이 다른 css파일과 중복되지 않도록 변환해주는 기능
    - `index.module.css`

```markdown
import style from "./index.module.css";

import default function Home() {
  return {
	  <>
		  <h1 className = {style.h1}>인덱스</h1>
```

## 글로벌 레이아웃 설정하기

- global layout 적용 방법 → app 컴포넌트에 페이지 컴포넌트를 포함하는 구조로 만들면 된다

```markdown
import { ReactNode } from "react";

export default function GlobalLayout({
  children,
} : {
  children: ReactNode;
}) {
  return (
    <div>
      <header>헤더</header>
      <main>{children}</main>
      <footer>푸터</footer>
    </div>
  )
}
```

## 페이지별 레이아웃 설정하기

```markdown
Home.getLayout = (page: ReactNode) => {
	return <SearchableLayout>{page}</SearchableLayout>
};
```

- 자바스크립트 모든 함수는 객체 → 메서드 추가 가능

- 레이아웃 정의되지 않은 페이지 예외 처리

```markdown

type NextPageWithLayout = NextPage & {
  getLayout?: (page: ReactNode) => ReactNode;
};

export default function App({
  Component,
  pageProps,
}: AppProps & {
  Component: NextPageWithLayout;
}) {
  const getLayout =
    Component.getLayout ?? ((page: ReactNode) => page);

  return (
    <GlobalLayout>
      {getLayout(<Component {...pageProps} />)}
    </GlobalLayout>
  );
} 
```

```markdown
  const q = router.query.q as string;

  useEffect(() => {
    setSearch(q || "");
  }, [q]);

```

```markdown
  const onSubmit = () => {
    if (!search || q === search) return;
    router.push(`/search?q=${search}`);
  };
```

## 한입북스 UI 구현하기

## 사전 렌더링과 데이터페칭

## SSR 1. 소개 및 실습

### 서버 사이드 렌더링

SSR-Server Side Rendering

- 가장 기본적인 사전 렌더링 방식
- 요청이 들어올 때 마다 사전 렌더링을 진행

### 작동 방법

```markdown
export const getServerSideProps() = () => {}; 
```

컴포넌트보다 먼저 실행되어서, 컴포넌트에 필요한 데이터 불러오는 함수

1. 페이지 진입
2. getServerSideProps → 백엔드 서버, 서드파티에서 데이터를 불러옴
3. 페이지 컴포넌트 실행

### 특징

- 객체를 반환해야 함
- 그 객체 안에는 props가 들어있어야 함
- 오직 한 번만 실행
- 서버 측에서 실행
- 브라우저를 읽을 수 없음 → window(.location) undefined

### 컴포넌트 두 번 실행된다

1. 서버에서 한 번 실행
2. 자바스크립트 코드 실행

### 브라우저에서만 실행되는 코드 작성

```markdown
useEffect(()) => {
	console.log(window);
}. []);
```

- useEffect는 컴포넌트 마운트 이후(화면이 나타난 이후) 실행되는 훅
- 서버에서 실행되지 않고 브라우저에서만 실행

### props type

```markdown
export default function Home({
	data,
}: InferGetServerSidePropsType<typeof getserverSideProps>
```

- InferGetServerSidePropsType 내장 타입 이용

## SSR 2. 실습

`lib/fetch-books.ts` 

```tsx
import { BookData } from "@/types";

export default async function fetchBooks(
  q?: string
): Promise<BookData[]> {
  let url = `https://onebite-books-server-one.vercel.app/book`;
  if (q) {
    url += `/search?q=${q}`;
  }

  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error("");

    return await response.json();
  } catch (err) {
    console.error(err);
    return [];
  }
}
```

```tsx
import { BookData } from "@/types";

export default async function fetchRandomBooks(): Promise<
  BookData[]
> {
  const url = `http://localhost:12345/book/random`;

  try {
    const response = await fetch(url);
    return await response.json();
  } catch (err) {
    console.error(err);
    return [];
  }
}
```

```tsx
export const getServerSideProps = async () => {
  const [allBooks, recoBooks] = await Promise.all([
    // fetchBooks(), fetchRandomBooks 병렬로 실행
    fetchBooks(), 
    fetchRandomBooks(),
  ]);

  return {
    props: {
      allBooks,
      recoBooks,
    },
  };
};

export default function Home({
  allBooks,
  recoBooks,
}: InferGetServerSidePropsType<typeof getServerSideProps>) {
```

```tsx
// search

import BookItem from "@/components/book-item";
import {
  GetServerSidePropsContext,
  InferGetServerSidePropsType,
} from "next";
import fetchBooks from "@/lib/fetch-books";

export const getServerSideProps = async (
  context: GetServerSidePropsContext
) => {
  const q = context.query.q;
  const books = await fetchBooks(q as string);

  return {
    props: {
      books,
    },
  };
};

export default function Page({
  books,
}: InferGetServerSidePropsType<typeof getServerSideProps>) {
  return (
    <div>
      {books.map((book) => (
        <BookItem key={book.id} {...book} />
      ))}
    </div>
  );
}

Page.getLayout = (page: ReactNode) => {
  return <SearchableLayout>{page}</SearchableLayout>;
};
```

```tsx
// book/[id].tsx

import {
  GetServerSidePropsContext,
  InferGetServerSidePropsType,
} from "next";
import style from "./[id].module.css";
import fetchOneBook from "@/lib/fetch-one-book";

export const getServerSideProps = async (
  context: GetServerSidePropsContext
) => {
  const id = context.params!.id; // !로 undefined가 아님을 표시
  const book = await fetchOneBook(Number(id));

  return {
    props: {
      book,
    },
  };
};

export default function Page({
  book,
}: InferGetServerSidePropsType<typeof getServerSideProps>) {
  if (!book) return "문제가 발생했습니다 다시 시도하세요";

  const {
    id,
    title,
    subTitle,
    description,
    author,
    publisher,
    coverImgUrl,
  } = book;

  return (
    <div className={style.container}>
      <div
        className={style.cover_img_container}
        style={{ backgroundImage: `url('${coverImgUrl}')` }}
      >
        <img src={coverImgUrl} />
      </div>
      <div className={style.title}>{title}</div>
      <div className={style.subTitle}>{subTitle}</div>
      <div className={style.author}>
        {author} | {publisher}
      </div>
      <div className={style.description}>{description}</div>
    </div>
  );
}
```

```tsx
// lib/fetch-one-book.ts

import { BookData } from "@/types";

export default async function fetchOneBook(
  id: number
): Promise<BookData | null> {
  const url = `http://localhost:12345/book/${id}`;

  try {
    const response = await fetch(url);
    return await response.json();
  } catch (err) {
    console.error(err);
    return null;
  }
}
```

## SSG 1. 소개

## SSG 2. 정적 경로에 적용하기

## SSG 3. 동적 경로에 적용하기

## SSG 4. 풀백옵션 설정하기

## ISR 1. 소개 및 실습

## ISR 2. 주문형 재 검증

## SEO 설정하기

## 배포하기

## 페이지 라우터 정리
