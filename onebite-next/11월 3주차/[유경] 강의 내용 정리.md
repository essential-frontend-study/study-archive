# 한 입 크기로 잘라 먹는 Next.js(v15)

next.js에서 제공하는 라우터

### 1. 페이지 라우터

- 초창기부터 제공되어 오던 예전 버전의 라우터

### 2. 앱 라우터

- Next 13 버전과 함께 처음으로 공개된 신규 라우터
- 리액트 서버 컴퍼넌트나 스트리밍 등의 아주 다양하고도 새로운 기능들이 제공

신규 버전인 App Router는 사실 과거 버전인 페이지 라우터의 단점을 보완하기 위해서 등장

- 어떤 부분에서 무엇이 나아졌는 지 파악하는 데 도움
- 앱 라우터는 아직 과도기 → 둘 다 배우자

# Next.js를 소개합니다

React.js를 보다 더 강력하고 편하게 사용할 수 있는 기능들을 제공 → React의 확장판

- 페이지 라우팅
- 빌트인 최적화 기능
- 다이나믹 HTML 스트리밍
- …

vercel에서 개발해서 오픈소스로 관리 중

카카오 웹툰, velog, inflearn, opgg …

어떻게 이렇게 많은 사랑을 받을까? → Next.js는 Library가 아닌 Framework이기 때문

Framework, Library 차이 → 기능 구현의 주도권이 누구에게 있는가

- 주도권이 개발자에게 있다: library
- 주도권이 개발자에게 없다: framework

**Framework**

- ex) Next.js, Remix …
- 주도권을 Framework가 가짐 → framework가 제공하는 기능을 이용하거나 허용하는 범위 내에서만 추가 도구 사용 가능
- Next.js에서 페이지 라우팅 기능을 구현해야 함 → Next.js가 제공하는 라우터 사용
- 자유도가 낮다 → 거의 모든 기능을 제공 → Page Routing, Optimizations, Server Pre Rendering 등 기본 제공 → 빠르게 웹 서비스 구축 가능

**Library**

- React.js, JQuery …
- 개발자가 하고 싶은 대로 구현 가능
- 자유도가 높다 → 기본 기능 외 제공 X

## 사전 렌더링 이해하기

- 브라우저의 요청에 사전에 렌더링이 완료된 HTML을 응답하는 렌더링 방식
- Client Side Rendering의 단점을 효율적으로 해결하는 기술

Client Side Rendering(CSR)

- React.js 앱의 기본적인 렌더링 방식
- 클라이언트(브라우저)에서 직접 화면을 렌더링 하는 방식
- user → browser에게 접속 요청 → server index.html, JS Bundle 보내줌 → 브라우저에서 JS 실행 → 컨텐츠 렌더링

SSR

- JS Bundle에 웹 사이트에 필요한 전체 코드 보유
- 브라우저는 이미 리액트 앱을 가지고 있고, 페이지 이동을 해도 브라우저 자체적으로 JS 실행 및 렌더링
- 초기 접속 이후에 페이지 이동을 빠르게 제공
- 초기 접속 속도가 느려짐 (요청 시 접속 요청 → index.html, JS Bundle 서버가 전송 → JS 실행 → 컨텐츠 렌더링 모두 해야함)
- FCP(First Contentful Paint) → 사전 렌더링
    - ‘요청 시작’ 시적으로 부터 컨텐츠가 화면에 처음 나타나는데 걸리는 시간
    - FCP 3, 5, 6, 10sec 이상일 경우 이탈률 32%, 90%, 106, 123% 증가

사전 렌더링

- 접속 요청 → JS 실행(렌더링) → 렌더링 된 HTML → 화면에 렌더링 → FCP 감소 → JS Bundle → JS 실행(HTML과 연결/수화)    
- 렌더링:
    1. JS 실행(렌더링): 자바스크립트 코드(React 컴포넌트)를 HTML로 변환하는 과정
    2. 화면에 렌더링: HTML 코드를 브라우저가 화면에 그려내는 작업
- TTI(Timer to interactive)
    - 요청~hydration 적용 시간까지의 시간

페이지 이동 요청 → 클라이언트 사이드 렌더링 방식으로 처리

### **🧩 React (CSR)**

1️⃣ HTML(빈 root div) 다운로드

2️⃣ JS 번들 다운로드

3️⃣ API 요청

4️⃣ 브라우저에서 HTML 구성 + 렌더링

5️⃣ 사용자에게 보임

### **⚡ Next.js (SSR/SSG)**

1️⃣ 서버(또는 빌드 단계)에서 HTML+데이터 미리 생성

2️⃣ 완성된 HTML 바로 응답

3️⃣ JS 번들 다운로드

4️⃣ Hydration으로 상호작용 연결

## 실습용 백엔드 서버 세팅하기

실습용 백엔드 서버가 필요한 이유

- next 서버와 백엔드 서버 연결 시 최적화 기능 제공

# 섹션 3. Page Router 핵심 정리

## Page Router를 소개합니다

Page Router

- 현재 많은 기업에서 사용되고 있는 안정적인 라우터
- React Router 처럼 페이지 라우팅 기능 제공
- Pages 폴더 기준 파일, 폴더명 기반 자동 라우팅
- 동적 경로(Dynamic Routes)
    - `[id].js` 형식으로 파일 작성

`npx create-next-app@14 section02` 

- 가장 안정적인 버전 14
- 페이지 라우터 사용 위함

`_app.tsx` 

- 루트 컴포넌트
- 모든 페이지의 부모 컴포넌트
- component: page
- pageProps: component에 들어가는 props를 객체로 보관
- 헤더 같은 모든 페이지에 나타나야 하는 컴포넌트는 _app.tsx에 작성

`_document.tsx` 

- index.html과 비슷
- 페이지 전체에 적용되는 html 태그 작성

## 페이지 라우팅 설정하기

- 폴더 아래에 index.tsx 생성하면 자동으로 폴더 이름으로 라우팅 된다
- URL에  `?q` 와 같이 작성하면 쿼리를 전달할 수 있음

```tsx
import { useRouter } from "next/router";

export default function Page() {
  const router = useRouter();
  const { q } = router.query;
  return <h1> search {q}</h1>;
}
```

- 가변적 값을 포함하는 동적 경로 → urlParameter
- 여러 동적 파라미터를 고려하는 방법 → catch all segment → `[...id].tsx`
    - id 는 배열 형태로 전달된다
- 완전히 범용적인 페이지 → optional cath all segment → ``[[...id]].tsx`

- 404.tsx로 404 라우팅 가능

## 네비게이팅

- `<a>` 태그는 클라이언트 사이드 렌더링 방식으로 이동시키는 게 아닌, 서버에게 새로운 페이지를 매번 다시 요청하는 방식으로 이동 → 느림 → 링크 컴포넌트 사용
- `<Link href = "/"} index</Link>`

programmatic Navigation

- 사용자가 링크를 직접 클릭했을 때 페이지를 이동시키는 방식이 아니라 특정 버튼이 클릭이 되었거나 특정 조건이 만족했을 경우 어떤 함수 내부에서 페이지를 이동시키는 방법

```tsx
  const onClickButton = () => {
    router.push("/test");
  }
  
  <button onClick={onClickButton}>/test</button>
```

## 프리페칭(Pre-Fetching)

- 사전에 불러온다
- 사용자가 보고있는 페이지 내에서 이동할 가능성이 있는 모든 페이지들을 사전에 미리 다 불러놓는 기능
- 현재 페이지에서 이동이 가능한 모든 페이지들에 필요한 데이터를 미리 다 불러 놓음으로써 페이지 이동을 매우 빠른 속도로 지체없이 처리해주기 위함
- 왜 프리패칭이 필요할까?
    - next.js에서는 html 페이지 응답 이후 후속으로 모든 자바스크립트 코드를 번들 파일 형태로 전달해주고, 그래서 브라우저가 서버에게 추가 리소스를 요청할 필요가 없는데?
    - next.js는 모든 리액트 컴포넌트들을 페이지별로 스플리팅 해서 저장을 미리 해두기 때문
    - 현재 페이지에 해당하는 자바스크립트 코드들만 전달된다
        - 전달되는 자바스크립트 코드 양을 줄이기 위함
        - JavaScript 코드를 매번 다 번들링해서 전달하면?
            - 한 번에 전달되는 파일 용량이 커짐
            - 브라우저에서 다운로드 속도 느려짐
            - JavaScript 코드를 실행해서 HTML과 연결하는 하이드레이션 과정 오래걸림
            - TTI(유저가 앱에 상호작용할 수 있게 되는 시간) 늦어짐

<aside>

1. 사전 렌더링은 초기 접속 요청 시에 모든 페이지에 대한 자바스크립트 파일이 다 전달되는 것이 아니었다
2. 현재 접속 요청이 발생한 페이지에 해당하는 자바스크립트 번들 파일만 전달이 된다
3. 프리패칭으로 현제 페이지에서 이동할 수 있는 모든 페이지에 대한 자바스크립트 코드를 사전에 미리 다 불러온다
</aside>

npm run dev로 개발모드로 가동해 놓고 있을 때에는 프리패칭이 동작하지 않음(매번 자원을 불러온다) → build, production 모드 앱 구동 필요

production 방법

- npm run build
- npm run start

프로그래메틱하게 이동시키는 페이지에 대해서도 프리패칭을 시키고 싶을 때

- `router.prefetch("/test");` 로 프리패칭 설정 가능

프리패칭 해제 방법

- `prefetch={false}`

## API Routes

- next.js에서 API를 구축할 수 있게 해주는 기능
- 간단한 API를 구축해서 클라이언트(브라우저)로 부터 요청을 받아 데이터베이스에서 데이터를 꺼내올 수 있음
- 서드파티에 데이터를 불러와서 전달 가능

/api 내부의 경로로 api 요청하면 해당 파일의 함수가 실행 되어서 api 작동

## 스타일링

- inline 스타일링 → 가독성 불편
- css 파일로 분리 → next에서는 오류
- Next.js에서는 App 컴포넌트가 아닌 index.tsx 같은 파일에서는 import문을 통해서 css 파일 불러오는 것을 제한
    - 별도의 페이지파일에서 css를 그대로 불러와서 import 하고 있을 경우 다른 페이지에 작성된 css 코드와 충돌을 일으킬 수 있기 때문
    - 페이지를 이동할 때 css 파일이 함께 로딩이 되면, 클래스 네임들이 서로 충돌 가능
    - 대신 app 컴포넌트에서는 모든 페이지에 다 적용되는 컴포넌트이기 때문에, global.css만 예외적으로 불러올 수 있음
- next.js가 기본적으로 제공하는 css 모듈 기능 활용
    - css 파일에 작성해둔 클래스 네임들이 다른 css파일과 중복되지 않도록 변환해주는 기능
    - `index.module.css`

```markdown
import style from "./index.module.css";

import default function Home() {
  return {
	  <>
		  <h1 className = {style.h1}>인덱스</h1>
```

## 글로벌 레이아웃 설정하기

- global layout 적용 방법 → app 컴포넌트에 페이지 컴포넌트를 포함하는 구조로 만들면 된다

```markdown
import { ReactNode } from "react";

export default function GlobalLayout({
  children,
} : {
  children: ReactNode;
}) {
  return (
    <div>
      <header>헤더</header>
      <main>{children}</main>
      <footer>푸터</footer>
    </div>
  )
}
```

## 페이지별 레이아웃 설정하기

```markdown
Home.getLayout = (page: ReactNode) => {
	return <SearchableLayout>{page}</SearchableLayout>
};
```

- 자바스크립트 모든 함수는 객체 → 메서드 추가 가능

- 레이아웃 정의되지 않은 페이지 예외 처리

```markdown

type NextPageWithLayout = NextPage & {
  getLayout?: (page: ReactNode) => ReactNode;
};

export default function App({
  Component,
  pageProps,
}: AppProps & {
  Component: NextPageWithLayout;
}) {
  const getLayout =
    Component.getLayout ?? ((page: ReactNode) => page);

  return (
    <GlobalLayout>
      {getLayout(<Component {...pageProps} />)}
    </GlobalLayout>
  );
} 
```

```markdown
  const q = router.query.q as string;

  useEffect(() => {
    setSearch(q || "");
  }, [q]);

```

```markdown
  const onSubmit = () => {
    if (!search || q === search) return;
    router.push(`/search?q=${search}`);
  };
```

## 한입북스 UI 구현하기

## 사전 렌더링과 데이터페칭

## SSR 1. 소개 및 실습

### 서버 사이드 렌더링

SSR-Server Side Rendering

- 가장 기본적인 사전 렌더링 방식
- 요청이 들어올 때 마다 사전 렌더링을 진행

### 작동 방법

```markdown
export const getServerSideProps() = () => {}; 
```

컴포넌트보다 먼저 실행되어서, 컴포넌트에 필요한 데이터 불러오는 함수

1. 페이지 진입
2. getServerSideProps → 백엔드 서버, 서드파티에서 데이터를 불러옴
3. 페이지 컴포넌트 실행

### 특징

- 객체를 반환해야 함
- 그 객체 안에는 props가 들어있어야 함
- 오직 한 번만 실행
- 서버 측에서 실행
- 브라우저를 읽을 수 없음 → window(.location) undefined

### 컴포넌트 두 번 실행된다

1. 서버에서 한 번 실행
2. 자바스크립트 코드 실행

### 브라우저에서만 실행되는 코드 작성

```markdown
useEffect(()) => {
	console.log(window);
}. []);
```

- useEffect는 컴포넌트 마운트 이후(화면이 나타난 이후) 실행되는 훅
- 서버에서 실행되지 않고 브라우저에서만 실행

### props type

```markdown
export default function Home({
	data,
}: InferGetServerSidePropsType<typeof getserverSideProps>
```

- InferGetServerSidePropsType 내장 타입 이용

## SSR 2. 실습

`lib/fetch-books.ts` 

```tsx
import { BookData } from "@/types";

export default async function fetchBooks(
  q?: string
): Promise<BookData[]> {
  let url = `https://onebite-books-server-one.vercel.app/book`;
  if (q) {
    url += `/search?q=${q}`;
  }

  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error("");

    return await response.json();
  } catch (err) {
    console.error(err);
    return [];
  }
}
```

```tsx
import { BookData } from "@/types";

export default async function fetchRandomBooks(): Promise<
  BookData[]
> {
  const url = `http://localhost:12345/book/random`;

  try {
    const response = await fetch(url);
    return await response.json();
  } catch (err) {
    console.error(err);
    return [];
  }
}
```

```tsx
export const getServerSideProps = async () => {
  const [allBooks, recoBooks] = await Promise.all([
    // fetchBooks(), fetchRandomBooks 병렬로 실행
    fetchBooks(), 
    fetchRandomBooks(),
  ]);

  return {
    props: {
      allBooks,
      recoBooks,
    },
  };
};

export default function Home({
  allBooks,
  recoBooks,
}: InferGetServerSidePropsType<typeof getServerSideProps>) {
```

```tsx
// search

import BookItem from "@/components/book-item";
import {
  GetServerSidePropsContext,
  InferGetServerSidePropsType,
} from "next";
import fetchBooks from "@/lib/fetch-books";

export const getServerSideProps = async (
  context: GetServerSidePropsContext
) => {
  const q = context.query.q;
  const books = await fetchBooks(q as string);

  return {
    props: {
      books,
    },
  };
};

export default function Page({
  books,
}: InferGetServerSidePropsType<typeof getServerSideProps>) {
  return (
    <div>
      {books.map((book) => (
        <BookItem key={book.id} {...book} />
      ))}
    </div>
  );
}

Page.getLayout = (page: ReactNode) => {
  return <SearchableLayout>{page}</SearchableLayout>;
};
```

```tsx
// book/[id].tsx

import {
  GetServerSidePropsContext,
  InferGetServerSidePropsType,
} from "next";
import style from "./[id].module.css";
import fetchOneBook from "@/lib/fetch-one-book";

export const getServerSideProps = async (
  context: GetServerSidePropsContext
) => {
  const id = context.params!.id; // !로 undefined가 아님을 표시
  const book = await fetchOneBook(Number(id));

  return {
    props: {
      book,
    },
  };
};

export default function Page({
  book,
}: InferGetServerSidePropsType<typeof getServerSideProps>) {
  if (!book) return "문제가 발생했습니다 다시 시도하세요";

  const {
    id,
    title,
    subTitle,
    description,
    author,
    publisher,
    coverImgUrl,
  } = book;

  return (
    <div className={style.container}>
      <div
        className={style.cover_img_container}
        style={{ backgroundImage: `url('${coverImgUrl}')` }}
      >
        <img src={coverImgUrl} />
      </div>
      <div className={style.title}>{title}</div>
      <div className={style.subTitle}>{subTitle}</div>
      <div className={style.author}>
        {author} | {publisher}
      </div>
      <div className={style.description}>{description}</div>
    </div>
  );
}
```

```tsx
// lib/fetch-one-book.ts

import { BookData } from "@/types";

export default async function fetchOneBook(
  id: number
): Promise<BookData | null> {
  const url = `http://localhost:12345/book/${id}`;

  try {
    const response = await fetch(url);
    return await response.json();
  } catch (err) {
    console.error(err);
    return null;
  }
}
```

## SSG 1. 소개

SSR: 서버 사이드 렌더링

- 접속 요청이 들어올 때마다 서버에서 JS 실행
- 페이지 내부 데이터 항상 최신으로 유지
- 데이터가 크거나, 지연 시 사용자 불편

SSG: 정적 사이트 생성

- Static Site Generation
- SSR의 단점을 해결하는 사전 렌더링 방식
- 빌드 타임에 페이지를 미리 사전렌더링 해 둠

- SSG 장점: 사전 렌더링에 많은 시간이 소요되는 페이지더다로 사용자의 요청에는 매우 빠른 속도로 응답 가능
- SSG 단점: 매번 똑같은 페이지만 응답함, 최신 데이터 반영은 어렵다

## SSG 2. 정적 경로에 적용하기

getstaticProps 선언 → SSG 방식으로 동작

InferGetStaticPropsType<typeof getStaticProps>

```tsx
export const getStaticProps = async () => {
  console.log("인덱스 페이지");

  const [allBooks, recoBooks] = await Promise.all([
    fetchBooks(),
    fetchRandomBooks(),
  ]);

  return {
    props: {
      allBooks,
      recoBooks,
    },
  };
};
```

- 개발모드가 아닌 프로덕트 모드에서 SSG가 제대로 실행
- SSG 페이지는 터미널의 Route 결과에 채워진 동그라미로 표시
- Next.js가 기본적으로 모든 API Routes들을 다이나믹하게(SSR) 작동하도록 설정 → f 기호 붙어있음

- 빌드 타임에 쿼리 스트링을 알 수 없음 → Search 페이지는 SSG 방식으로 구현할 수 없음 → React 구현하듯이 해야함

```tsx
export default function Page() {
  const [books, setBooks] = useState<BookData[]>([]);

  const router = useRouter();
  const q = router.query.q;

  const fetchSearchResult = async () => {
    const data = await fetchBooks(q as string);
    setBooks(data);
  };

  useEffect(() => {
    if (q) {
      fetchSearchResult();
    }
  }, [q]);

  return (
    <div>
      {books.map((book) => (
        <BookItem key={book.id} {...book} />
      ))}
    </div>
  );
}

```

## SSG 3. 동적 경로에 적용하기

- url 파라미터 값은 문자열

```tsx
export const getStaticPaths = () => {
  return {
    paths: [
      { params: { id: "1" } },
      { params: { id: "2" } },
      { params: { id: "3" } },
    ],
    fallback: false,
  };
};
```

npm run start > ./.next > /server > /pages > book > html 파일 생성

## SSG 4. 풀백옵션 설정하기

fallback 옵션 설정 (없는 경로로 요청시)

- false: 404 Not Found 반환
- blocking: 즉시 생성 (Like SSR)
- true: 즉시 생성 + 페이지만 미리 반환 (props가 없는 페이지 반환)

페이지 로딩 느리게 하는 법

- 크롬 개발자모드 > 네트워크 > throtling > fast 3G

fallback 상태: 페이지 컴포넌트가 아직 서버로부터 데이터를 전달받지 못한 상태

fallback 상태일 때 로딩 텍스트 띄워주는 법: router 객체의 isFallback 프로퍼티 사용

```tsx
export default function Page({
  book,
}: InferGetStaticPropsType<typeof getStaticProps>) {
  const router = useRouter();

  if (router.isFallback) return "로딩중입니다";
  if (!book) return "문제가 발생했습니다 다시 시도하세요";
  // if (!book) return notFound: true;

  const {
    id,
    title,
    subTitle,
    description,
    author,
    publisher,
    coverImgUrl,
  } = book;

  return (
    <div className={style.container}>
      <div
        className={style.cover_img_container}
        style={{ backgroundImage: `url('${coverImgUrl}')` }}
      >
        <img src={coverImgUrl} />
      </div>
      <div className={style.title}>{title}</div>
      <div className={style.subTitle}>{subTitle}</div>
      <div className={style.author}>
        {author} | {publisher}
      </div>
      <div className={style.description}>{description}</div>
    </div>
```

## ISR 1. 소개 및 실습

ISR(Incremental Static Regeneration): 증분 정적 재 생성

- SSG 방식으로 생성된 정적 페이지를 일정 시간을 주기로 다시 생성하는 기술
- 매우 빠른 속도로 응답 가능 → 기존 SSG 방식의 장점
- 최신 데이터 반영 가능 → 기존 SSR 방식의 장점

일정 시간 주기로 랜덤 도서 추천

```tsx
export const getStaticProps = async () => {
  console.log("인덱스 페이지");

  const [allBooks, recoBooks] = await Promise.all([
    fetchBooks(),
    fetchRandomBooks(),
  ]);

  return {
    props: {
      allBooks,
      recoBooks,
    },
    revalidate: 3,
  };
};
```

빌드 결과에 ISR 3초임을 출력

## ISR 2. 주문형 재 검증

시간 기반의 ISR을 적용하기 어려운 페이지도 존재

ex) 시간과 관계 없이 사용자의 행동에 따라 데이터가 업데이트 되는 페이지

그냥 SSR로 처리하면 되는 거 아닌가?

- 응답 시간이 느려진다

On-Demand ISR: 요청을 받을 때 마다 페이지를 다시 생성하는 ISR

```tsx
import { NextApiRequest, NextApiResponse } from "next";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    await res.revalidate("/");
    return res.json({ revalidate: true });
  } catch (err) {
    res.status(500).send("Revalidation Failed");
  }
}
```

## SEO 설정하기

public/fabicon, thumbnail

```tsx
import Head from "next/head";

...

export default function Home({
  allBooks,
  recoBooks,
}: InferGetStaticPropsType<typeof getStaticProps>) {
  return (
    <>
      <Head>
        <title>한입북스</title>
        <meta property="og:image" content="/thumbnail.png" />
        <meta property="og:title" content="한입북스" />
        <meta
          property="og:description"
          content="한입 북스에 등록된 도서들을 만나보세요"
        />
      </Head>

...
```

```tsx
if (router.isFallback) {
    return (
      <>
        <Head>
          <title>한입북스</title>
          <meta property="og:image" content="/thumbnail.png" />
          <meta property="og:title" content="한입북스" />
          <meta
            property="og:description"
            content="한입 북스에 등록된 도서들을 만나보세요"
          />
        </Head>
        <div>로딩중입니다</div>
      </>
    );
  }
  if (!book) return "문제가 발생했습니다 다시 시도하세요";
```

- fallback 상태가 아닐 때에만 메타 태그 적용 → 처음 페이지를 요청했을 때에는 메타 태그가 적용되지 않아서 SEO 설정이 안된다 → fallback 상태일 때도 메타태그가 적용되도록 하자

## 배포하기

```tsx
sudo npm install -g vercel
vercel login
vercel
```

백엔드 서버도 같이 배포 필요 → 배포된 서버 주소로 url 교체 필요

## 페이지 라우터 정리

### Page Router의 장점

1. 파일 시스템 기반의 간편한 페이지 라우팅 제공
    - 라우팅을 위해 코드 추가 작성이 필요 없다
    - 동적 경로도 작성 가능(중첩도 가능)
2. 다양한 방식의 사전 렌더링 제공
    - 사전렌더링: 서버 측에서 JS 실행해서 렌더링 된 HTML을 클라이어트에게 전달 → FCP 단축
        1. 서버사이드 렌더링(SSR): 요청이 들어올 때 마다 사전 렌더링을 진행
        2. 정적 사이트 생성(SSG): 빌드 타임에 미리 페이지를 사전 렌더링 해 둠
        3. 증분 정적 재생성(ISR): SSG 페이지 일정 시간마다 재생성

### Page Router의 단점

1. 페이지별 레이아웃 설정이 번거롭다
    - 코드 중복, 복잡 → App Router에서는 layout이라는 파일 하나만으로 손쉽게 페이지 별 레이아웃 설정 가능
2. 데이터 페칭이 페이지 컴포넌트에 집중된다    
    - 페이지가 복잡해지면 데이터를 전달하는 과정이 복잡해진다
    
3. 불필요한 컴포넌트들도 JS Bundle에 포함된다
    - Next.js앱에서 만든 리액트 컴포넌트들은 총 두 번 실행된다
        1. 서버 측에서 사전 렌더링을 진행하기 위해 최초로 한 번 실행
        2. 자바스크립트 번들에 포함되어 브라우저에게 전달되어, 하이드레이션을 위해 한 번 더 실행
            - 하이드레이션: 상호작용을 추가하기 위함 → TTI(Time To Interactive)
    - 상호작용이 필요 없는 컴포넌트도 존재 → 서버에서 한 번만 실행하면 된다
