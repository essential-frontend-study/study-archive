## section 2

### Next.js는 라이브러리가 아닌 프레임워크다
1. 리액트같은 라이브러리는 개발 주도권을 개발자가 가진다. 기능 구현을 원하는 방향으로 진행하는데, 예를 들어, 라우팅을 구현하기 위해 React Router를 사용할지 Tanstack Router나 다른 선택지들 중 어떤 것을 사용할지 고민해보고 결정할 수 있다. 반면, 프레임워크는 개발 주도권을 프레임워크가 가진다. 프레임워크가 제공하는 기능을 이용하거나, 허용된 범위 내에서만 추가 도구를 사용할 수 있다. 예를 들어, 라우팅을 구현하기 위해서 Next.js가 자체적으로 제공하는 Page Router, App Router 둘 중 하나만 고를 수 있다.
    | 특징 | 프레임워크 (Next.js) | 라이브러리 (React) |
    | :--- | :--- | :--- |
    | **개발 주도권** | 프레임워크가 가짐 (제어의 역전) | 개발자가 가짐 |
    | **자유도** | 특정 구조와 규칙을 따르므로 상대적으로 낮음 | 원하는 도구(라우터, 상태 관리 등)를 자유롭게 선택하므로 높음 |
    | **기능 제공 범위** | 광범위 (라우팅, 최적화, 데이터 패칭, 빌드 등) | 핵심 기능 (UI 렌더링) 외 제공하지 않음 |
2. 즉, Next.js는 React를 기반으로 서버 사이드 렌더링(SSR), 정적 사이트 생성(SSG), 라우팅, API Routes 등 프로덕션 환경에 필요한 모든 기능을 추가하여 웹 애플리케이션 개발에 필요한 완벽한 환경을 제공하여 React 생태계의 주요 프레임워크이다.

### 사전 렌더링 이해하기
1. 사전 렌더링이란, 브라우저의 요청에 사전에 렌더링이 완료된 HTML을 응답하는 렌더링 방식이다. CSR의 단점을 효율적으로 해결하는 기술이다.

2. 기존 리액트에서는 CSR을 이용했다. CSR은 리액트에서 사용하는 기존 렌더링 방식인데, 클라이언트에서 직접 화면을 렌더링 하는 방식으로, 사용자가 웹 페이지에 진입할 때, 서버는 빈 html을 클라이언트에 전달하고 자바스크립트 번들을 다운받는다. 그리고 다운받은 번들을 실행시켜서 클라이언트에 컨텐츠를 렌더링하면 비로소 웹 페이지에 요소가 그려진다.
![](https://lh3.googleusercontent.com/d/1tUQo0qek1XcqVY7Uj4zsp493vtNuaQI4)
3. 이때 이 번들의 크기가 크다면 첫 페이지 진입 시 초기 로딩 속도가 느려서 사용자에게 빈 화면을 보여주게 된다. 초기 접속 시 서버에게 요청을 보내는 시점부터 컨텐츠가 화면에 나오기까지 걸리는 시간을 FCP라고 하는데, CSR은 SSR에 비해 FCP가 좋지 않다. 이는 사용자 이탈률을 결정할 만큼 중요한 요소이다.
![](https://lh3.googleusercontent.com/d/1ZpU6lT37A3Z0fOepMBE39VHf9XRfqbwF)


4. 즉, CSR은 초기 접속 이후의 페이지 이동이 빠르지만, FCP(초기 접속 속도)가 느리다. FCP가 느린 문제를 해결하기 위해 사전 렌더링이 필요하다.

5. 사전 렌더링 방식은 사용자가 웹 페이지에 진입할 때, 서버에 요청을 보낸다. 서버는 자바스크립트 코드를 HTML으로 변환하는 JS실행(렌더링) 과정을 거치고, 사전에 렌더링된 HTML을 클라이언트에 전달한다. 그러면 웹 페이지에 요소가 그려진다. 이때, CSR과는 다르게 빈 HTML을 전달하는 것이 아닌, 사전에 렌더링된 HTML을 전달하는 것이 핵심이다.
![](https://lh3.googleusercontent.com/d/12ZAhtCOgRtzbTBP24epkP-XvF62-LN1h)

6. 이 과정까지는 아직 클릭, 페이지 이동과 같은 인터렉션(상호작용)은 동작하지 않는다. 이를 위해 서버는 자바스크립트 번들을 클라이언트로 보내주게 되고, 클라이언트는 이 번들을 실행한다. 이때 HTML과 이벤트가 연결되어 비로소 웹 페이지 인터렉션이 가능해지는데, 이 과정을 하이드레이션이라 한다. 이때, 초기 로딩부터 상호작용까지 가능한 시점까지를 TTI라고 한다.
![](https://lh3.googleusercontent.com/d/1QK58kPBfwsiP-AqBccOuiEaJ5139kwpu)



## section 3

### page Router
1. Next.js의 Page Router 방식에 대해 간략하게 알아보자 Next.js에서는 라우팅을 위한 Page Router와 App Router 방식이 있는데, Page Router는 자동으로 pages 폴더 내에 있는 파일들 혹은 폴더들의 경로와 이름에 따라 라우팅이 제공된다.
![](https://lh3.googleusercontent.com/d/1cyGHE053mntiDEXfBHK84psD0zcwbFZs)

2. 또한 동적 경로를 갖는 페이지의 라우팅이 제공된다. 동적 경로란 경로상의 가변적인 값을 포함하고 있는 경로를 말한다. 동적 경로는 블로그 게시글 페이지나, 쇼핑몰의 상품 상세페이지와 같은 곳에 활용된다. 동적 경로를 정의할 때는 파일이나 폴더 이름을 대괄호를 감싸야 한다.
![](https://lh3.googleusercontent.com/d/1wsqbmtRgH7BEeidbfDL2c8WzN7npAMpy)

3. 프로젝트는 다음 명령어를 통해 생성할 수 있다.
```tsx
// npx create-next-app@{버전 or latest(가장 최신 버전)} {프로젝트 이름}
npx create-next-app@14 next-project_01
npx create-next-app@latest next-project_01
```

### _app.tsx와 _document.tsx 살펴보기
1. Next.js 프로젝트를 생성하고 pages 폴더 내부를 보면 _app.tsx와 _document.tsx가 존재하는 것을 확인할 수 있다. 이 두 파일은 페이지의 역할을 하는 파일이 아니다. 모든 페이지에 공통적으로 적용되는 로직이나 레이아웃, 데이터를 다루기 위해 필요한 파일이다. 

2. _document.tsx파일에는 모든 페이지에 공통적으로 적용 되어야 하는 HTML코드를 설정하는 역할을 하는 Document 컴포넌트가 있다. 기존의 리액트 프로젝트에서 index.html과 비슷한 역할을 한다. 따라서 lang='kr'과 같이 언어 설정, 메타태그, 폰트, 캐릭터셋, 구글 에널리틱스 등 설정할 수 있다.

3. _app.tsx파일에는 App컴포넌트가 있는데, 이는 루트 컴포넌트이다. 즉, App 컴포넌트는 모든 페이지 역할을 하는 컴포넌트의 부모 컴포넌트이다. 이 App 컴포넌트는 component, pageProps를 props로 받는데, component라는 props는 현재의 page 역할을 할 컴포넌트를 받는 것이다. pageProps는 component props에게 전달될 페이지지의 props들을 모두 객체로 보관한 데이터이다. 그렇기 때문에 리턴문에 있는 페이지 역할을 할 컴포넌트를 렌더링 하면서 동시에 props로는 pageProps를 전달받는 것을 볼 수 있다. 결론적으로 Next.js에서는 어떤 페이지를 렌더링을 하던 App컴포넌트의 자식인 page의 역할을 하는 컴포넌트가 렌더링되는 구조로 이루어져있다. 따라서 이 파일에서는 모든 페이지에 공통적으로 나타나야 하는 헤더와 같은 공통 요소가 필요하다면 이 파일에 추가할 수 있다.
![](https://lh3.googleusercontent.com/d/1xPDM65OahQ6SaWI742lbm5am_-XUN2Mr)

### 페이지 라우팅 설정하기
**주의: pages폴더 내의 파일(폴더)명은 반드시 소문자로 구성한다.**

1. 위에서 간략하게 살펴봤듯이 Page Router 방식에서 페이지 라우팅을 설정하기 위해서는 pages 폴더 내에 파일을 생성하면 해당 파일이 경로가 되며, 폴더를 생성하면 해당 폴더가 경로가 된다. 폴더로 라우팅을 설정할 경우 폴더 내부에는 반드시 index.tsx와 같은 형태가 되야한다.

2. 중첩 경로도 설정할 수 있다. '/search/setting'와 같이 중첩경로를 설정하려면 해당 파일내에 일반적으로 pages 폴더 내부에 했던 라우팅 방식을 사용하면 된다.
![](https://lh3.googleusercontent.com/d/1KtEaQMEJYvitapRhBC3LTOvuqYKOk9bb)

3. Next.js에서 쿼리스트링을 직접 꺼내서 사용하려면 useRouter 훅을 이용해야 한다.
    ```tsx
    import { useRouter } from 'next/router';

    export default function SearchPage() {
        const router = useRouter();

        const { q } = router.query;

        return <h1>Search page {q}</h1>
    }
    ```
    - console에 찍힌 라우터 객체에는 다양한 프로퍼티가 있다. 이때 query 프로퍼티의 q에 쿼리스트링의 값이 담겨있다.
    ```tsx
    export default function Book() {
        const router = useRouter();

        const { id } = router.query;

        return <h1>Book {id}</h1>
    }
    ```
    - 위와 같이 동적경로로 구성한 페이지에서 id로 url parameter를 다룰 수 있다. 만약, 중첩경로에도 대응하고 싶다면 (book/id/review/...와 같은) catch all segment를 사용해야 한다. 기존 [id].tsx(동적 경로 세그먼트)로 관리하는 파일명을 [...id].tsx와 같이 변경해주면 모든 중첩 경로에 대응하는 유연한 페이지를 구성할 수 있다. 중첩된 url parameter들은 배열 형태로 id 프로퍼티에 저장이 된다.
    - 추가적으로 /book과 같이 동적 경로로 구성한 페이지에 id값이 아닌 인덱스 경로로 요청이 오는 경우에 대응하고 싶다면 [[...id]]와 같이 대괄호를 하나 더 감싸주면 해당 book폴더에 index.tsx 파일을 별도로 갖지 않아도 index경로에 대응할 수 있다.

4. 존재하지 않는 경로 즉, 404페이지를 커스텀하려면 해당 폴더 내에 404.tsx파일을 하나 만들면 된다. 서버 측 에러(500 에러)를 커스텀하려면 pages/_error.tsx 파일을 하나 만들면 된다.

### 네비게이팅
1. next.js에서는 페이지 이동 시 Link 컴포넌트를 사용한다. 리액트에서는 react-router-dom에서 제공하는 Link 컴포넌트를 사용했지만, Next.js에서는 기본 제공하는 (next/link) Link 컴포넌트를 사용한다. 둘의 차이점은 Link 컴포넌트에 리액트는 to를 통해 이동시킬 경로를 전달했다면, Next.js는 href를 통해 이동시킬 경로를 전달한다.
    ```tsx
    import Link from 'next/link';

    export default function App() {
        return (
            <>
              <header>
                <Link href={'/'}>index</Link>
                <Link href={'/search'}>search</Link>
                <Link href={'/book/1'}>book 1</Link>
              </header>
            </>
        )
    }
    ```

2. 사용자가 로그인을 하면(이벤트 발생) 다른 페이지로 이동시키는 프로그래매틱한 페이지 이동을 구현하는 방법은 다음과 같다.
    ```tsx
    // import문 생략

    export default App() {
        const router = useRouter();

        const onClickButton = () => {
            router.push('/a')
        }

        return <button onClick={onClickButton}>a페이지로 이동</button>;
    }
    ```

### 프리페칭
1. 프리페칭이란 사전에 페이지를 미리 불러오는 기능이다. 즉, 현재 사용자가 보고있는 페이지 내에서 Link 컴포넌트가 뷰포트에 나타나거나 근처인 경우 해당 페이지에 필요한 JS번들을 사전에 미리 다운로드하는 기능이다.. 이는 빠른 페이지 이동을 제공한다.

2. 왜 프리페칭이 필요할까? Next.js의 브라우저 렌더링 방식에서 클라이언트에게 JS 번들을 보내주는데, 이때 Next.js는 자동으로 코드 스플리팅 기능이 적용되어서, 해당 페이지에 필요한 JS 번들만 전달한다. 이는 JS 번들 크기를 줄이기 위함이고, 이는 곧 TTI 성능이 개선되는 효과를 볼 수 있다.(하이드레이션 과정이 빨라짐) 하지만, 리액트와 다르게 모든 JS 번들을 클라이언트에게 보내는 게 아니기에 첫 요청 이후에는 CSR 방식으로 페이지 이동이 되지 않는다.클라이언트는 다음 페이지 이동에 필요한 요청하면 서버는 해당 페이지 응답하는 구조 반복가 반복되는데, 이는 SSR 방식이다. 이를 해결하기 위해 사용자가 이동할 가능성이 있는 페이지의 번들도 미리 보내주어, CSR처럼 동작하도록 하는 것이다. 결과적으로, 프리페칭 + 코드스플리팅으로 하이드레이션 과정도 빨라지고 페이지 이동도 빨리지는 것이다.

3. 프로그래매틱 방식으로(이벤트 기반 페이지 이동) 페이지를 이동하는 경우, 프리페칭이 제공되기 위해 다음과 같이 router 객체를 사용해야 한다.
    ```tsx
    export default App() {
        const router = useRouter();

        onClickButton = () => {
            router.push('/a');
        };

        useEffect(()=>{ router.prefetch('/a') },[]);

        return ...;
    }
    ```
    - 위 코드애서 컴포넌트가 첫 마운트 시 prefetch를 통해 미리 다운로드 한다. 
    - 추가적으로 Link 컴포넌트는 자동으로 프리페칭이 된다고 했는데, prefetch={false} 옵션으로 프리페칭 기능을 끌 수 있다.

### API Routes
1. Next.js에서 API를 구축할 수 있게 해주는 기능이다. 예시로, 백엔드 API 서버가 하는일과 동일하게 간단한 API 서버를 구축해서 클라이언트 요청에 따라 DB에 CRUD와 같은 작업을 할 수 있게 해준다. pages 폴더 내부에 api 폴더를 생성하고 해당 폴더내에 api 경로에 맞는 파일명으로 생성해준다.
    ```ts
    import type { NextApiRequest, NextApiResponse } from 'next';

    type Data = {
        name: string;
    };
    
    export default function handler(
        req:NextApiRequest, res:NextApiResponse
        ) {
            const date = new Date();
            res.json({ time: date.toLocaleString() });
        }
    ```
    -  해당 파일이름의 api 경로가 호출이 되면 handler 함수가 실행이 되는데 이 함수는 Date객체를 만들고 해당 객체를 제이슨 형태로 응답하고 있다. 해당 요청을 날리면 다음과 같다.
    ```json
    {"time":"2024. 6. 14. 오후 1:23:45"}
    ```
2. 이처럼 Next.js에서 API까지 만들 수 있도록 도와주는 API Route를 활용할 수 있다. (HTTP 메서드를 사용한 라우팅 분기 등) 
    - 추가적으로, API Routes는 서버 환경(Node.js)에서 실행되므로, 환경 변수(Environment Variables)에 저장된 **데이터베이스 접속 비밀번호, 외부 API 키(예: Stripe, AWS)**와 같은 민감한 정보를 클라이언트에게 노출하지 않고 안전하게 사용할 수 있다. 클라이언트 컴포넌트는 오직 이 API Routes만 호출한다.

### 사전 렌더링과 데이터 패칭
1. 기존 React에서는 데이터 패칭을 위해 컴포넌트가 최초 마운트 시에만 fetch 요청을 보내도록 작성했었다. 하지만 이 방식은 초기 접속 요청부터 데이터 로딩까지 오랜 시간이 걸린다. 이유는 데이터 패칭을 컴포넌트가 마운트가 된 후에 실행하기 때문이다. 애초에 데이터 요청자체를 늦게까지 때문에 데이터를 불러오는 속도가 느린 것이다.
![](https://lh3.googleusercontent.com/d/1NteSL-DpUEwFP0HnBpmto0LVu0xG1KgG)


2. Next.js에서는 사전렌더링 과정에서 JS 실행중에 필요한 데이터를 미리 불러오도록 요청할 수 있다. 즉, 이미 데이터패칭이 완료된 페이지를 한 번에 렌더링하고 그 후에 하이드레이션과정을 거친다. 
![](https://lh3.googleusercontent.com/d/1uilSZdxxpU-SYnfEFVWhiJm4G88AWTfe)


3. 정리하자면 리액트의 데이터 패칭은 컴포넌트 마운트 이후 발생, 데이터 요청 시점이 느려지게 되는 단점이 발생하고 Next.js의 데이터 패칭은 사전 렌더링 중 발생하여(이후 추가적인 데이터 요청도 당연히 가능) 데이터 요청 시점이 빨라지는 장점이 있다. 결론적으로 사용자에게 데이터 패칭이 완료된 웹 페이지를 추가적인 요청 없이 한 번에 보여줄 수 있다.

4. 또한, Next.js에서 서버 상태가 좋지 못해서 API 응답 결과를 늦게 주는 경우를 대처하기 위해 빌드타임에 사전렌더링을 하도록 설정할 수 있다. 즉, 다양한 방식으로 사전렌더링을 할 수 있도록 여러가지 방식을 제공하고 있다. 

5. Next.js는 3가지의 사전 렌더링 방식을 제공한다. SSR, SSG, ISR 방식이다. SSR은 가장 기본적인 사전 렌더링 방식이며, 요청이 들어올 때 마다 사전 렌더링을 진행한다. SSG는 빌드 타임에 미리 페이지를 사전렌더링 해두는 방식이다. ISR은 사용자가 직접 데이터 갱신 시점을 지정하여 SSG에서 해당 시점이 되면 다시 빌드를 하여 사전렌더링 하는 방식으로, SSG의 업그레이드 버전으로 볼 수 있다. 이를 통해 각 상황에 맞게 알맞은 사전렌더링 방식을 이용해야 한다.

### SSR(서버 사이드 렌더링)
1. page router에서는 getServerSideProps 함수를 통해 SSR 방식으로 사전 렌더링을 이용할 수 있다. 약속된 함수 이름으로 export 키워드로 내보내주면 Next.js에서 이를 트리거하여 SSR 방식으로 사전 렌더링을 진행한다.
    ```tsx
    export const getServerSideProps = async () => {
        // 컴포넌트보다 먼저 실행되어, 컴포넌트에 필요한 데이터를 불러오는 함수
        const [allBooks, recoBooks] = await Promise.all([
            fetchBooks(), fetchRandomBooks()
            ]);

        return {
            props: {
                allBooks,
                recoBooks,
            }
        }
    };

    export default function App({ 
        allBooks, recoBooks 
        }: InferGetServerSidePropsType<typeof getServerSideProps>
        ) {
            // data 사용
            }
    ```
    - 이 방식을 간단히 정리하면, 사용자가 요청을 보내면 getServerSideProps 함수가 실행되고 (이때, 백엔드 서버 데이터를 불러온다거나 하는 작업 수행), 마지막으로 App 컴포넌트가 실행이 되는 것이다.
    - 주의 사항으로는 getServerSideProps는 사전렌더링 과정에서 서버측에서 한 번만 실행되는 함수이다. 그렇기에 해당 함수 안에서는 브라우저 환경에서만 이용할 수 있는 window 객체 접근 등 서버 환경에 없는 로직을 넣으면 에러가 발생한다. 
    - 또 해당 App 컴포넌트는 서버측에서 한 번, 로컬측에서 한 번 실행되어 총 두 번 실행된다. 따라서 브라우저 환경에서만 실행할 코드는 useEffect와 같은 훅을 사용해야 한다.
2. 서버 사이드 렌더링의 경우 다음으로 살펴볼 SSG와는 다르게 사용자의 요청 시 항상 최신의 데이터를 보여줘야할 경우에 적합하다.

### SSG(정적 사이트 생성)
1. 빌드 타임에 페이지를 미리 사전렌더링 해두는 방식이다. SSR은 사용자가 요청 시 매번 새로운 데이터를 요청하여 가져온다면, SSG는 빌드타임 시에만 데이터를 요청하여 가져오는 방식이다. 즉, 사전 렌더링에 많은 시간이 소요되는 페이지더라도 사용자의 요청에 매우 빠른 속도로 응답할 수 있다.
    ```tsx
    export const getStaticProps = async () => {
        const [allBooks, recoBooks] = await Promise.all([
            fetchBooks(), fetchRandomBooks()
            ]);

        return {
            props: {
                allBooks,
                recoBooks,
            }
        }
    };

    export default function App({ 
        allBooks, recoBooks 
        }: InferGetStaticPropsType<typeof getStaticProps>
        ) {
            // data 사용
            }
    ```
2. 블로그 게시글이나 상품 상세페이지 등 데이터가 자주 변경되지 않는 페이지에 적합하다. SSG를 테스트하기 위해서는 개발모드로 작동시키지 않고, 빌드 후 프로덕션 모드로 실행시켜야 한다.

3. 동적 경로에 SSG를 적용하기 위해서는 getStaticPath 함수가 추가적으로 필요하다. 빌드 타임에 경로를 설정한 뒤 해당 경로를 사전 렌더링 해야하기 때문이다.
![](https://lh3.googleusercontent.com/d/1wVEvYqDZaukHuo8Alp3LlGNHHXuwWNvG)
    ```tsx
    export const getStaticPaths = () => {
        return {
            paths: [
                { params: { id: '1' } },
                { params: { id: '2' } },
                { params: { id: '3' } },
            ],
            fallback: false // true, 'blocking'
        }
    }
    ```
    - 이 함수에서는 미리 빌드 타임에 정적 페이지를 생성하기 위한 paths가 필요하다. 위 코드에서는 id가 1,2,3번인 페이지를 정적 페이지 생성을 하는 것이다. 또한 fallback 옵션은 4번 페이지로 요청이 들어올 경우(미리 정해놓지 않은 페이지) 대비할 수 있게 한다. 
    - paths에 미리 지정해주지 않은 페이지로 요청이 올 경우에 false의 경우 not found로 보내주고, blocking의 경우 즉시 생성해서 보내준다. 마치 SSR과 유사하다. 단, 한 번만 페이지를 만들면 그 후에는 다시 SSG 방식으로 동작한다. true의 경우 즉시 생성해서 보내주는데 데이터가 없는 페이지만 미리 반환한다. 그리고 데이터 계산이 끝나면 데이터만 따로 반환해서 다시 페이지를 보여준다.
    ![](https://lh3.googleusercontent.com/d/1QAs0CRL5afAPY6CH0lwgjUdns1H8los1)
    ![](https://lh3.googleusercontent.com/d/1mhnePnlihCXxb3LZdpDZSlu9sVkbl0P7)

### ISR(증분 정적 재생성)
1. ISR은 특정 시간 이후에 정적으로 생성된 페이지를 다시 새롭게 재생성하게 해주는 방식이다. 이 방식은 기존 SSG 방식의 장점과 SSR 방식의 장점을 합친 방식이다.
    ```tsx
    export const getStaticProps = async () => {
        const [allBooks, recoBooks] = await Promise.all([
            fetchBooks(), fetchRandomBooks()
            ]);

        return {
            props: {
                allBooks,
                recoBooks,
            },
            revalidate: 30,
        }
    };

    export default function App({ 
        allBooks, recoBooks 
        }: InferGetStaticPropsType<typeof getStaticProps>
        ) {
            // data 사용
            }
    ```

    ![](https://lh3.googleusercontent.com/d/1PdRPaG0IqhMjfRVrXtxj97pFOrvjyUaF)
    - 이와 같이 revalidate 시간이 30초라면, 해당 30초 이전에 들어온 요청엔 매번 같은 데이터를 응답해주고, 30초 이후로 요청이 들어온다면, 30초 이전에 보낸 요청을 그대로 보내되, 새로운 데이터로 갱신을 시킨다. 그리고 그 후에 요청이 또 다시 들어오면 그제서야 새로운 데이터를 응답해주는 방식이다.
    - 이처럼 ISR은 데이터 업데이트 시 매번 전체 재빌드를 할 필요가 없어지며(SSG 단점 보완), 요청 시마다 서버에서 데이터를 가져와 HTML을 만드는 과정이 없어지므로, 서버 부하가 줄고 응답 속도가 빠르다.(SSR 단점 보완)

2. 하지만 시간 기반의 ISR이 아닌 사용자의 행동에 따라 데이터가 업데이트 되길 원할 수 있는데 이때, on demand ISR 방식을 사용할 수 있다. 게시글 수정이나, 삭제 등 특정 이벤트(행동)에 따라 해당 페이지를 다시 사전 렌더링하여 최신 데이터를 불러오게 할 수 있다는 것이다.
    ![](https://lh3.googleusercontent.com/d/13eL9rzc6wo1OMMEK1ajbJywx-gz8wfjW)
    ```tsx
    // revaildate.ts
    import { NextApiRequest, NextApiResponse } from 'next';

    export default async function handler(
        req: NextApiRequest,
        res: NextApiResponse,
    ) {
        try {
            await res.revalidate('/')
            return res.json({ revalidate: true })
        } catch(err) {
            res.status(500).send('revalidate 실패');
        }
    }
    ```
    - revalidate api에 요청하면 위 handler 함수가 실행된다. 이 함수 내부에서는  /(인덱스)경로를 다시 생성한다. 생성이 성공했다면 revalidate true라는 응답이 돌아오게 된다. 실패하면 500 요청이 돌아오게 된다. 이제 이 함수를 특정 이벤트가 발생할 때 호출해주면 된다.

### SEO 생성하기
1. Next.js에서는 각 페이지별로 메타 태크를 별도로 설정해줄 수 있다.
    ```tsx
    import Head from 'next/head';

    ...

    return (
        <>
          <Head>
            <title>한입북스</title>
            <meta property="og:image" content="thumbnail.png" />
            <meta property="og:title" content="한입북스" />
            <meta property="og:description" content="한입북스에 등록된 도서들을 만나보세요" />
          </Head>
          ...
        </>
    )
    ```
    - 참고로 동적경로 페이지에서 paths에 설정한 페이지가 아닌 다른 페이지로 들어오게 되면 (true, 'blocking'과 같은) 해당 메타 태그는 제거가 된다. 따라서 로딩중 렌더링하는 곳에도 Head 태그에 기본적인 메타태그를 설정해줘야 한다. 또한 상세페이지 같은 경우 getStaticProps나 getServerSideProps를 통해 가져온 데이터를 활용하여 동적으로 메타 태그를 설정해줄 수 있다.