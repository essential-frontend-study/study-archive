# Section 7. 스트리밍과 에러핸들링

## 스트리밍이란?

- 데이터를 여러 개의 조각으로 나누어 작은 용량의 데이터들을 하나씩 클라이언트에게 전송하는 기술
- 클라이언트는 모든 데이터가 다 불러와 지지 않은 상태에서도 지금까지 전달받은 데이터에 접근할 수 있음 → 긴 로딩 없이 좋은 경험 제공
- next는 html 페이지를 스트리밍하는 기능을 자체적으로 제공
- 단순한 컴포넌트 → 대체 UI 화면에 보여주다가 렌더링 후 늦은 컴포넌트만 따로 전달
- 비동기 작업이 존재하지 않는 컴포넌트 → 빠르게 렌더링
비동기 작업으로 렌더링 오래 걸리는 컴포넌트 → 뒤늦게 렌더링
- 다이나믹 페이지에 자주 사용
- 오래 걸리는 컴포넌트의 렌더링을 사용자가 좀 더 좋은 환경에서 기다릴 수 있도록

## 스트리밍 1. 페이지 스트리밍 적용하기

1. loading.tsx 파일은 현재 경로에 있는 페이지 컴포넌트 뿐만 아니라 레이아웃처럼 해당 경로 아래에 있는 모든 비동기 페이지 컴포넌트들을 모두 스트리밍 되도록 설정해준다.
2. loading.tsx 파일이 스트리밍하도록 설정하는 페이지 컴포넌트는 async 키워드가 붙어서 비동기로 작성하도록 설정된 페이지 컴포넌트에만 스트리밍 제공
3. loading.tsx는 무조건 페이지 컴포넌트에만 스트리밍을 적용할 수 있다.
4. loading.tsx 파일로 설정된 스트리밍은 브라우저에서 쿼리 스트링이 변경될 때에는 트리거링 되지 않는다
    
    → 쿼리만 바뀌는 건 스트리밍 적용 X → suspense 적용 필요
    

## 스트리밍 2. 컴포넌트 스트리밍 적용하기

일반적인 컴포넌트에 자유롭게 스트리밍을 설정할 수 있도록 리액트의 suspense 컴포넌트 이용

- suspense: 미완성

```tsx
export default async function Page({
  searchParams,
}: {
  searchParams: Promise<{ q?: string }>;
}) {
  const { q } = await searchParams;
  return (
    <Suspense key={q || ""} fallback={<div>Loading ...</div>}>
      <SearchResult q={q || ""} />
    </Suspense>
   );
}
```

- 리액트 suspense는 최초로 한 번 내부 컴포넌트 로딩이 완료된 후에는 내부에 어떤 컨텐츠가 변경된다고 하더라도 새롭게 다시 로딩 상태로 돌아가지 않음
→ suspense key 값을 바꿔서 컴포넌트 자체를 아예 새로운 컴포넌트로 인식 → 컴포넌트를 새롭게 렌더링

- suspense 컴포넌트는 페이지 내에서 여러 개의 비동기 컴포넌트들을 동시다발적으로 스트리밍할 때 효율적

## 스켈레톤 UI 적용하기

- 뼈대 역할을 하는 UI

```tsx
import style from "./book-item-skeleton.module.css";

export default function BookItemSkeleton() {
  return (
    <div className={style.container}>
      <div className={style.cover_img}></div>
      <div className={style.info_container}>
        <div className={style.title}></div>
        <div className={style.subtitle}></div>
        <br />
        <div className={style.author}></div>
      </div>
    </div>
  );
}
```

```tsx
.container {
  display: flex;
  gap: 15px;
  padding: 20px 10px;
  border-bottom: 1px solid rgb(220, 220, 220);
}

.cover_img {
  width: 80px;
  height: 105px;
  background-color: rgb(230, 230, 230);
}

.info_container {
  flex: 1;
}

.title,
.subtitle,
.author {
  width: 100%;
  height: 20px;
  background-color: rgb(230, 230, 230);
}
```

```tsx
import BookItemSkeleton from "./book-item-skeleton";

export default function BookListSkeleton({
  count,
}: {
  count: number;
}) {
  return new Array(count)
    .fill(0)
    .map((_, idx) => (
      <BookItemSkeleton key={`book-item-skeleton-${idx}`} />
    ));
}
```

- react loading skeleton 라이브러리 사용 가능

## 에러 핸들링(error.tsx)

- try catch 문 대신 error.tsx로 에러 핸들링

```tsx
// error.tsx

"use client";

import { useRouter } from "next/navigation";
import { startTransition, useEffect } from "react";

export default function Error({
  error,
  reset,
}: {
  error: Error;
  reset: () => void;
}) {
  const router = useRouter();

  useEffect(() => {
    console.error(error.message);
  }, [error]);

  return (
    <div>
      <h3>오류가 발생했습니다</h3>
      <button
        onClick={() => {
          // 함수 하나를 인수로받아서, 해당 함수 내부의 코드를 동기적으로 실행
          startTransition(() => {
            router.refresh(); // 현재 페이지에 필요한 서버 컴포넌트들을 다시 불러옴 -> RSC Component
            reset(); // 에러 상태를 초기화, 컴포넌트들을 다시 렌더링
          });
        }}
      >
        다시 시도
      </button>
    </div>
  );
}
```

- 클라이언트 컴포넌트로 설정해야 하는 이유(useCliient)
    - 오류는 서버, 클라이언트 환경을 만록하고 어떤 환경이든 다 발생 가능 → 모두 대응하기 위해 클라이언트 컴포넌트로 설정

- reset props
    - 함수
    - 에러가 발생한 페이지를 복구하기 위해 다시 한 번 컴포넌트들을 렌더링 시켜보는 기능
    - 서버 측에서 전달받은 데이터를 이용해서 화면을 다시 한 번 렌더링 해보기만 함 → 서버 컴포넌트를 다시 실행하지는 않음 / 대신 클라이넌트 컴포넌트 내부에서 발생한 오류만 복구 가능
        
        → reset 대신 window.location.reload() → state, cliend component 데이터가 다 날라감 + 재렌더링 필요
        
        → 오류가 발생한 부분만 렌더링 → useRouter의 router.refresh() + reset()
        
        - router.refresh()는 next.js 서버에게 서버 컴포넌트만 새롭게 렌더링해달라고 요청
        - router.refresh는 비동기로 동작, 비동기 객체 반환 X → startTransition()으로 일괄 진행

error.tsx는 자기와 같은 경로에 있는 레이아웃까지만 렌더링을 시켜줌

- next app router 버전에서는 레이아웃을 살리기 위해 error.tsx를 각각의 경로별로 만들어 줘야 할 수도 있다.

# Section 8. 서버 액션

## 서버 액션을 소개합니다

서버 액션이란?

- 브라우저에서 호출할 수 있는 서버에서 실행되는 비동기 함수

```tsx
export default function Page() {
	const saveName = async (formData: FormData) => {
		"use server"; // next.js 서버에서만 실행 되는 서버 액션을 설정된다.
		...
	};

	return (
		<form action={saveName}>
			<input name="name" placeholder="이름을 알려주세요 ..." />
			<button type="submit">제출</button>
		</form>
		);
	}

```

- 서버에서만 실행되는 함수를 브라우저가 직접 호출하면서 데이터까지 폼 데이터 형식으로 전달
- 기존에는 API를 통해서만 진행했어햐 하는 브라우저와 서버간의 데이터 통신을 자바스크립트 함수 하나만으로 쉽고 간결하게 설정 가능

- useServer 지시자로 서버 액션을 만들고 서버 액션을 호출하는 폼을 브라우저에서 제출 → 자동으로 서버 액션을 호출하는 HTTP 리퀘스트가 서버에게 날라감 → 서버 액션들은 컴파일 결과자동으로 특정 해시 값을 갖는 API로서 설정 → request 헤더에 next action이라는 이름으로 현재 호출하고자 하는 서버 액션의 해시 값 명시
- 서버 액션 → API 생성 → 자동 호출

```tsx
function ReviewEditor() {
  async function createReviewAction(formData: FormData) {
    "use server";

    const content = formData.get("content")?.toString();
    const author = formData.get("author")?.toString();

    console.log(content, author);
  }

  return (
    <section>
      <form action={createReviewAction}>
        <input name="content" placeholder="리뷰 내용" />
        <input name="author" placeholder="작성자" />
        <button type="submit">작성하기</button>
      </form>
    </section>
  );
}
```

서버 액션을 활용하는 이유?

- 코드가 간결하기 때문
- API는 파일 추가, 경로 설정, 예외 처리 등의 부가 작업 번거로움
- 클라이언트는 호출만 하고 코드를 전달 받지는 않음 → 보안상으로 민감하거나 중요한 데이터를 다룰 때 유용

## 리뷰 추가 기능 구현하기

```tsx
"use server";

export async function createReviewAction(formData: FormData) {
  const bookId = formData.get("bookId")?.toString();
  const content = formData.get("content")?.toString();
  const author = formData.get("author")?.toString();

  if (!bookId || !content || !author) {
    return;
  }

  try {
    const response = await fetch(
      `${process.env.NEXT_PUBLIC_API_SERVER_URL}/review`,
      {
        method: "POST",
        body: JSON.stringify({ bookId, content, author }),
      }
    );
    console.log(response.status);
  } catch (err) {
    console.error(err);
    return;
  }
}
```

```tsx
function ReviewEditor({ bookId }: { bookId: string }) {
  return (
    <section>
      <form action={createReviewAction}>
        <input name="bookId" value={bookId} hidden />
        <input required name="content" placeholder="리뷰 내용" />
        <input required name="author" placeholder="작성자" />
        <button type="submit">작성하기</button>
      </form>
    </section>
  );
}
```

## 리뷰 조회 기능 구현하기

## 리뷰 재검증 구현하기

사용자가 리뷰를 작성했을 때 자동으로 화면이 업데이트 되어서 내가 작성한 리뷰가 바로 나타나는 기능 추가

서버 액션이 성공적으로 종료되었을 때 실시간으로 서버측에서 렌더링 or 서버 컴포넌트 다시 렌더링 → 사용자들이 보고 있는 북페이지 재검증

- revalidatePath(`/book/${bookId}`);
- next 서버에서 페이지를 새롭게 생성 후 브라우저에게 보내서 바로 리뷰가 나타남
- 서버 컴포넌트 내부에서만 호출 가능 (클라이언트 클라이언트에서는 불가능)
- 페이지를 재검증하는 기능 → 페이지에 포함된 모든 캐시를 무효화(데이터 캐시, 풀 라우트 캐시) → 다음 번에 페이지를 방문할 때 실시간으로 다이나믹 페이지처럼 생성

![스크린샷 2025-11-18 04.03.24.png](attachment:33387427-b851-4178-9f8d-7f3e94b0e46b:스크린샷_2025-11-18_04.03.24.png)

![스크린샷 2025-11-18 04.04.45.png](attachment:3ee80c35-7524-46d0-8e24-bfef8caa74d1:스크린샷_2025-11-18_04.04.45.png)

## 다양한 재검증 방식 살펴보기

```tsx
"use server";

import { revalidatePath, revalidateTag } from "next/cache";

export async function createReviewAction(formData: FormData) {
  const bookId = formData.get("bookId")?.toString();
  const content = formData.get("content")?.toString();
  const author = formData.get("author")?.toString();

  if (!bookId || !content || !author) {
    return;
  }

  try {
    const response = await fetch(
      `${process.env.NEXT_PUBLIC_API_SERVER_URL}/review`,
      {
        method: "POST",
        body: JSON.stringify({ bookId, content, author }),
      }
    );
    console.log(response.status);

    // 1. 특정 주소의 해당하는 페이지만 재검증
    // revalidatePath(`/book/${bookId}`);

    // // 2. 특정 경로의 모든 동적 페이지를 재검증
    // revalidatePath("/book/[id]", "page");

    // // 3. 특정 레이아웃을 갖는 모든 페이지 재검증
    // revalidatePath("/(with-searchbar)", "layout");

    // // 4. 모든 데이터 재검증
    // revalidatePath("/", "layout");

    // 5. 태그 기준, 데이터 캐시 재검증
    revalidateTag(`review-${bookId}`);
  } catch (err) {
    console.error(err);
    return;
  }
}
```

## 클라이언트 컴포넌트에서의 서버액션

- 전송 버튼에서 사용자 피드백 필요
- 중복 제출 방지

useActionState

- react 19 버전에 추가
- 폼 태그의 상태를 쉽게 핸들링할 수 있도록 도와줌

```tsx
"use server";

import { delay } from "@/util/delay";
import { revalidatePath, revalidateTag } from "next/cache";

export async function createReviewAction(_: any, formData: FormData) {
  const bookId = formData.get("bookId")?.toString();
  const content = formData.get("content")?.toString();
  const author = formData.get("author")?.toString();

  if (!bookId || !content || !author) {
    return {
      status: false,
      error: "리뷰 내용과 작성자를 입력해주세요",
    };
  }

  try {
    await delay(2000);
    const response = await fetch(
      `${process.env.NEXT_PUBLIC_API_SERVER_URL}/review/1`,
      {
        method: "POST",
        body: JSON.stringify({ bookId, content, author }),
      }
    );
    if (!response.ok) {
      throw new Error(response.statusText);
    }

    revalidateTag(`review-${bookId}`);
    return {
      status: true,
      error: "",
    };
  } catch (err) {
    return {
      status: false,
      error: `리뷰 저장에 실패했습니다 : ${err}`,
    };
  }
}
```

```tsx
"use client";

import style from "./review-editor.module.css";
import { createReviewAction } from "@/actions/create-review.action";
import { useActionState, useEffect } from "react";

export default function ReviewEditor({ bookId }: { bookId: string }) {
  const [state, formAction, isPending] = useActionState(
    createReviewAction,
    null
  );

  useEffect(() => {
    if (state && !state.status) {
      alert(state.error);
    }
  }, [state]);

  return (
    <section>
      <form className={style.form_container} action={formAction}>
        <input name="bookId" value={bookId} hidden />
        <textarea
          disabled={isPending}
          required
          name="content"
          placeholder="리뷰 내용"
        />
        <div className={style.submit_container}>
          <input
            disabled={isPending}
            required
            name="author"
            placeholder="작성자"
          />
          <button disabled={isPending} type="submit">
            {isPending ? "..." : "작성하기"}
          </button>
        </div>
      </form>
    </section>
  );
}
```

## 리뷰 삭제 기능 구현하기

deletebutton 을 client component로 분리

```tsx
"use client";

import { deleteReviewAction } from "@/actions/delete-review.action";
import { useActionState, useEffect, useRef } from "react";

export default function ReviewItemDeleteButton({
  reviewId,
  bookId,
}: {
  reviewId: number;
  bookId: number;
}) {
  const formRef = useRef<HTMLFormElement>(null);
  const [state, formAction, isPending] = useActionState(
    deleteReviewAction,
    null
  );

  useEffect(() => {
    if (state && !state.status) {
      alert(state.error);
    }
  }, [state]);

  return (
    <form ref={formRef} action={formAction}>
      <input name="reviewId" value={reviewId} hidden />
      <input name="bookId" value={bookId} hidden />
      {isPending ? (
        <div>...</div>
      ) : (
        <div onClick={() => formRef.current?.requestSubmit()}>
          삭제하기
        </div>
      )}
    </form>
  );
}
```

submit()

- 유효성 검사나 이벤트 핸들러를 무시하고 그냥 무조건 강제로 폼의 제출을 발생

requestSubmit()

- formRef.current?.request.Submit()
- 실제로 사용자가 Submit 버튼을 클릭한 것과 똑같이 동작 → 의도한 대로 안전하게 동작할 가능성이 높음
- Submit 보다는 RequestSubmit 메서드 권장

# Section 9. 고급 라우팅 패턴

## 패럴렐 라우트

병렬 라우트

ReactNode Type

- React가 화면에 렌더링할 수 있는 모든 값의 총합 타입
- 컴포넌트에서 children 같은 곳에 들어갈 수 있는 모든 것을 의미
- ex) 문자열, 숫자, boolean, null, undefined, jsx, react component, array, fragment, portal
    - 모든 UI로 렌더링 가능한 값
- 언제 쓰는가?
    - 컴포넌트의 children 타입에 지정할 때
    - JSX로 렌더링될 수 있는 값을 넣을 때

슬롯(slot)

- 부모가 전달한 UI 조각(children)을 특정 위치에 끼워넣는 기능
- 이름 앞에 골뱅이 기호가 붙은 폴더
- 병렬로 렌더링이 될 하나의 페이지 컴포넌트를 보관
- 슬롯 안에 보관된 페이지 컴포넌트는 부모 레이아웃 컴포넌트인 레이아웃 컴포넌트에게 props로써 자동으로 전달

## 인터셉팅 라우트

인터셉트: 가로채다

상세>모달 에서 새로고침하면 모달만 렌더링

`(.)` 작성

```tsx
"use client";

import { ReactNode, useEffect, useRef } from "react";
import style from "./modal.module.css";
import { createPortal } from "react-dom";
import { useRouter } from "next/navigation";

export default function Modal({ children }: { children: ReactNode }) {
  const dialogRef = useRef<HTMLDialogElement>(null);
  const router = useRouter();

  useEffect(() => {
    if (!dialogRef.current?.open) {
      dialogRef.current?.showModal();
      dialogRef.current?.scrollTo({
        top: 0,
      });
    }
  }, []);

  return createPortal(
    <dialog
      onClose={() => router.back()}
      onClick={(e) => {
        // 모달의 배경이 클릭이된거면 -> 뒤로가기
        if ((e.target as any).nodeName === "DIALOG") {
          router.back();
        }
      }}
      className={style.modal}
      ref={dialogRef}
    >
      {children}
    </dialog>,
    document.getElementById("modal-root") as HTMLElement
  );
}
```
