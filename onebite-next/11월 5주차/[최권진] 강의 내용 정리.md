## section 7

### 스트리밍
1. 스트리밍이란, 서버에서 클라이언트에게 데이터를 넘겨줄 때, 데이터의 크기가 큰 경우 데이터를 부분적으로 나누어서 전달해줄 수 있게 해주는 것이다. Next.js에서는 HTML을 스트리밍할 수 있도록 자체적인 기능을 제공하고 있다. 즉, 비동기작업이 존재하지 않아서 빠르게 렌더링 할 수 있는 컴포넌트 먼저 보여주고, 비동기가 끝난 뒤 데이터를 받고나서 해당 데이터를 채워서 보여주는 게 가능하다.

2. 이러한 스트리밍은 빌드 타임에 미리 생성되지 않는 동적 페이지에 사용된다. 사용하는 방법은 해당 폴더에 loading.tsx 파일을 만들면 된다.
    ```tsx
    export default function Loading() {
        return <div>Loading ...</div>;
    }
    ```
    - 그러면 async 키워드를 사용하는 동적 페이지에서 해당 데이터를 불러오기 전까지 Loading ... 텍스트를 보여주고 해당 데이터를 다 불러왔다면 해당 데이터로 다시 보여준다.
    - "주의 사항으로는 해당하는 폴더에 loading.tsx 파일이 있다면 폴더 내부에 있는 모든 async 컴포넌트(자식 페이지 및 해당 폴더의 레이아웃)에 적용된다. 또한, 일반 컴포넌트가 아닌 라우트 세그먼트의 **페이지(page.tsx) 또는 레이아웃(layout.tsx)**에만 스트리밍을 적용할 수 있다."

### Suspense
1. Suspense 컴포넌트를 사용하면 위의 loading.tsx와 다르게 일반 컴포넌트에도 loading ui를 적용시킬 수 있다.
    ```tsx
    import { Suspense } from 'react';

    export default function Page({
        searchParams
    }: {
        searchParams: {
            q?: string;
        }
    }) {
        return (
            <Suspense key={searchParams.q || ''} fallback={<div>Loading...</div>}>
              <SearchResult q={searchParams.q || ''} />
            </Suspense>
        )
    }
    ```
    - Suspense 컴포넌트를 react로부터 불러온 뒤, SearchResult 컴포넌트를 Suspense 컴포넌트로 감싼 뒤, Suspense의 fallback ui를 설정하게 되면 해당 ui가 로딩중인 상태일 때 렌더링된다. key 값을 searchParams.q로 설정하게 되면 쿼리스트링 값이 변할 때 마다 Suspense 컴포넌트가 다시 생성되기 때문에 일종의 트릭역할을 하여 검색할 때 마다 로딩 ui를 렌더링할 수 있게 된다. 

### 에러 핸들링
1. 기존 데이터 패칭에서 try-catch문으로 감싸지 않더라도 해당 데이터 패칭이 실패할 경우 error.tsx 파일에 구현된 ui를 보여주도록 설정할 수 있다. 해당 폴더 내부에 error.tsx파일을 만들게 되면 해당 파일에서 에러가 발생할 경우 해당 error.tsx의 ui를 렌더링하게 된다.

    ```tsx
    'use client';

    export default function Error({error, reset}: {error: Error; reset: () => void}) {
        const router = useRouter();
        return <div onClick={() => startTransition( () => {
            router.refresh(); // 현재 페이지에 필요한 서버 컴포넌트 다시 불러옴
            reset(); // 에러 상태 초기화, 컴포넌트 다시 렌더링
        })}>오류 발생. 다시 시도</div>
    }
    ```
2. use client 지시자를 설정하는 이유는 클라이언트측에서 발생한 오류던, 서버측에서 발생한 오류던 다 대응할 수 있도록 하기 위함이다. (클라이언트 컴포넌트는 서버에서 한 번, 클라이언트에서 한 번 실행된다고 이전에 배웠다.)

3. 또한 Next.js는 기본적으로 에러가 발생했을 때, 컴포넌트에게 에러 객체를 props로 제공한다. 또, reset 메서드를 제공하는게 이는 컴포넌트를 다시 한 번 렌더링 할 수 있는 메서드이다. 따라서 OnClick 이벤트에 붙여서 다시 컴포넌트를 실행할 수 있게 한다.

4. 여기서 reset() 메서드만 사용할 경우, 서버 컴포넌트는 다시 시작하지 않기에 router.refresh()를 이용해서 서버 컴포넌트를 다시 렌더링 시켰고, startTransition을 통해 router.refresh()를 실행한 뒤, reset()을 실행하도록 해준 것이다. 

5. startTransition이란, 동시성 기능을 활용하여 UI의 응답성을 유지하도록 돕는 React API이다. 이 함수는 업데이트의 중요도를 구분하여, 사용자에게 즉각적인 피드백이 필요한 긴급한 업데이트와, 조금 지연되어도 괜찮은 덜 긴급한 업데이트를 구분할 수 있게 해준다.

6. startTransition의 주요 역할은 렌더링을 차단하는 무거운 업데이트가 발생할 때, 사용자 인터페이스(UI)가 멈추거나 렉이 걸리는 현상을 방지하는 것이다. 입력(typing), 클릭(clicking), 마우스 오버(hovering)와 같이 즉각적인 피드백이 필요한 업데이트를 React는 최우선으로 처리한다.(긴급 업데이트) 반면, 데이터 페칭, 복잡한 계산, UI의 애니메이션 변경 등 지연이 허용되는 업데이트. startTransition으로 감싼 업데이트는 낮은 우선순위로 처리된다.(트랜지션 업데이트)

7. startTransition을 사용하면, React는 긴급 업데이트를 먼저 처리한 후, 남는 시간을 활용하여 트랜지션 업데이트를 처리한다.

8. 결과적으로 사용자가 "오류 발생. 다시 시도" 버튼을 클릭했을 때, React가 이 시간이 걸리는 작업을 긴급하지 않은 일로 인식하게 만든다. 기본적으로 router.refresh() 메서드는 긴급함 업데이트로 간주된다. 긴급 업데이트는 동기적으로 처리되어야 하거나, 적어도 UI를 차단하고 완료될 때까지 기다려야 한다고 가정하기에 비동기 작업인 router.refresh() 메서드를 사용할 경우 렌더링이 꼬여버릴 수 있다. 따라서 startTransition으로 감싸서 해당 작업을 덜 긴급한 작업으로 간주하게 하면 렌더링이 꼬이지 않아서 예기치 않은 동작이 발생하는 것을 방지할 수 있다.

9. 추가로, Next.js 공식 문서에서도 클라이언트 컴포넌트 내에서 라우팅 관련 API(router.push(), router.refresh(), router.replace() 등)를 호출하여 데이터 페칭을 유발하는 경우, 이를 **startTransition**으로 감싸도록 권장하거나 강제한다.

## section 8

### 서버 액션 
1. 서버 액션이란, 브라우저에서 호출할 수 있는 서버에서 실행되는 비동기 함수이다. 이 서버 액션을 사용하면 별도의 API 파일을 만들지 않아도 간단한 함수만으로도 브라우저에서 Next 서버측에서 실행되는 함수를 직접 호출할 수 있게 된다. 즉, 이 함수는 네트워크를 통해 서버로 전송되어 Next.js 서버측에서 실행된다.
    ```tsx
    function ReviewEditor() {
        async function createReviewAction(formData: FormData) {
            'use server';
            
            const content = formData.get('content')?.tostring();
            const author = formData.get('author')?.tostring();
        }

        return (
            <section>
              <form action={createReviewAction}>
                <input name='content' placeholder='리뷰 내용' />
                <input name='author' placeholder='작성자' />
                <button type='submit'>작성하기</button>
              </form>
            </section>
        )
    }
    ```
2. 별도의 API 라우트(`app/api/...`)를 만들지 않아도 자동으로 API Endpoint가 생성되며, 해당 엔드포인트를 통해 서버 액션이 호출된다.
    - 서버 액션 내부에서 DB 접근, 비밀 키 사용, 보안이 필요한 로직 등을 사용할 수 있다.

3. 또, 제출된 해당 폼의 데이터도 action에 연결된 서버 액션의 매개변수로 전달된다. 따라서 formData가 전달되어 content, author 값을 각각 추출할 수 있게 된다.

4. 이 서버 액션이 필요한 이유는, API를 통해 이 기능을 만들기 위해서는 별도의 파일을 추가하고 경로를 설정하고 예외처리하는 이 과정이 귀찮을 수 있다. 하지만 서버 액션을 이용하면, 단순한 기능만 필요한 경우 간결하게 코드를 작성할 수 있다. 또한 클라이언트는 이 함수를 호출만 할 수 있기에 보안상 민김한 데이터를 다루기에도 좋다. 

### 서버 액션 revalidatePath 재검증 구현하기
1. revalidatePath 메서드에 현재 페이지의 경로를 넣어주면 해당 페이지에 대한 재검증을 구현할 수 있다. 즉, 데이터를 추가하고 router.refresh()나, useState를 변경하여 useEffect의 의존성 배열에 상태로 넣어줘서 페이지를 재검증 시키는 것이 아닌, revalidatePath 메서드를 통해 데이터가 변경되는 즉시 관련된 캐시를 무효화하여, 사용자가 항상 최신 상태의 데이터를 기반으로 렌더링된 UI를 보도록 보장한다.
    ```tsx
    import { revalidatePath } from 'next/cache';

    // 서버 액션 함수 내부에서 사용
    async function createPost(formData: FormData) {
        'use server';
        // 1. DB에 데이터 변경 (추가/수정/삭제) 로직 실행
        // ...

        // 2. 변경된 데이터가 반영되어야 하는 페이지 경로를 재검증
        revalidatePath('/posts'); 
    }
    ```
    - 주의 사항으로는 먼저 revalidatePath는 서버 액션 내부나 서버 컴포넌트에서만 호출 가능하다. 또, revalidatePath를 통해 캐시 무효화가 설정되어있는 페이지에서 데이터 캐시 옵션을 force-cache와 같이 설정했더라도, revalidatePath를 통해 캐시 무효화가 진행되면 해당 캐시 관련된 모든 정보가 사라진다. 즉, 풀 라우트 캐시, 데이터 캐시가 다 날라간다.
        ![](https://lh3.googleusercontent.com/d/1MPEXArPoAzhs-Cg-XxYpRm6IvPXLehjT)
        - 위와 같이 데이터 캐시와 풀 라우트 캐시에 저장을 하더라도,
        ![](https://lh3.googleusercontent.com/d/1VXgyHVfvRwVUvmZ8uBGDTlPmBPS3d6qv)
        - revalidatePath가 들어오면, 저장된 캐시 (데이터 캐시, 풀 라우트 캐시)모두 숙청 당한다. 그리고 풀 라우트 캐시는 두 번째 요청부터 저장된다. 

2. 이 외에도 다양한 재검증 방식이 존재한다.
    - 특정 페이지만 재검증
        ```tsx
        revalidatePath(`/book/${bookId}`);
        ```
    - 특정 경로의 모든 동적 페이지 재검증
        ```tsx
        revalidatePath('/book/[id]', 'page');
        ```
    - 특정 레이아웃을 갖는 모든 페이지 재검증
        ```tsx
        revalidatePath('/(with-searchbar)', 'layout');
        // with-searchbar 경로에 있는 레이아웃을 갖는 모든 페이지가 재검증되는 것. 
        ```
    - 모든 페이지 재검증
        ```tsx
        revalidatePath ('/', 'layout');
        // 루트 경로에 있는 레이아웃을 갖는 모든 페이지가 재검증. 즉, 모든 페이지가 루트 레이아웃을 갖기에 모든 페이지 재검증
        ```
    - 태그 기준, 데이터 캐시 재검증
        ```tsx
        revalidateTag('tag');
        // tag라는 값을 갖는 모든 데이터 캐시가 재검증
        ```

3. 서버 액션을 위한 상태관리를 지원하는 useActionState에 대해 알아보자.
    - useActionState는 useState와 유사하게 동작하지만, 특히 **비동기 폼 액션(서버 액션)**의 상태를 처리한다.
        ```tsx
        const [state, formAction, isPending] = useActionState(createReviewAction, null);
        ```
        - useActionState훅의 첫 번째 인자에 서버 액션 함수를 넣고, 두 번째 인자에는 폼의 상태의 초기값을 넣어준다. 그럼 이 useActionState는 세 개의 값을 반환한다.
            - 최신 결과 상태: 서버 액션 실행이 성공했는지, 실패했는지에 대한 결과 데이터 또는 에러 메시지를 담고 있는 상태.
            - 폼 액션 함수: 서버 액션 함수에 dispatch 역할을 부여하여, 폼의 action prop에 바로 연결할 수 있는 바인딩된 함수.
            - ispending: 서버 액션 실행중인지 실행 완료되었는지를 알려주는 상태
        - ispending을 사용해서 폼의 따닥(중복요청) 요청 방지가 가능하다.
        - state를 통해서 액션 함수의 에러 핸들링도 가능하다.
            ```tsx
            'use clinet';
            
            import {useActionState, useEffect} from 'react';
            import serverAction from '...';

            export default function ReviewEditor() {
                const [state, formAction, isPending] = useActionState(serverAction, null);
                
                // 서버 액션 error 핸들링
                useEffect(() => {
                    if (state && !state.status) alert(state.error)
                }, [state]);

                return (
                    <form action={serverAction}>
                      // disabled에 isPending을 넣어 중복요청 방지
                      <input disabled={isPending} name='content' />
                      <input disabled={isPending} name='author' />
                      <button disabled={isPending} type='submit'>{isPending ? '...' : '제출'}</button>
                    </form>
                )
            }
            ```
## section 9

### 패럴랠 라우트
1. 패럴랠 라우트는 병령 라우트이다. 여러 페이지(또는 독립된 뷰)의 콘텐츠를 하나의 URL에서 병렬적으로(동시에) 렌더링하는 Next.js App Router의 기능이다.
    ![](https://lh3.googleusercontent.com/d/1HR2QICotqayRE4xbBiuBoL4xDHcfY8EV)
    - 이 기능의 주 목적은 서로 독립적인 섹션(예: 대시보드의 위젯, 모달 창)을 만들고, 한 섹션의 데이터 로딩 실패나 상태 갱신이 다른 섹션에 영향을 주지 않도록 분리하는 것이다.

2. 패럴랠 라우트를 구현하기 위해서는 슬롯을 만들어야 한다. 폴더 이름을 @폴더이름 형태로 정의해야 한다. 이렇게 만든 슬롯은 병렬로 렌더링 될 페이지 컴포넌트를 보관하는 폴더이다. 그리고 이 슬롯폴더 내부 파일은 해당 폴더의 상위 layout.tsx의 props로 전달된다. 
    ![](https://lh3.googleusercontent.com/d/1m-i4zoM52LNEr0s-spPFmDs8S3-Ls246)
    - 그리고 해당 슬롯명으로 컴포넌트 렌더링 할 수 있다. 또한 해당 슬롯은 개수 제한이 없다.
    ![](https://lh3.googleusercontent.com/d/1xZfeekroppl-kenrZ8O5yq9EpNpzJBhI)
    - 또한, 특정 슬롯 하위에 추가적인 경로의 페이지를 생성하여 이동해봐도 해당 슬롯의 페이지만 업데이트 되며, 나머지 슬롯의 페이지들은 그대로 이전의 상태를 유지한다.(그대로 렌더링) 
    - 추가적으로, 새로고침을 하면 404 페이지로 리다이렉트 되는데, 새로고침은 다시 초기 접속을 하는것을 의미하는데, 그럴 경우 해당하는 슬롯의 이전의 상태를 찾을 수 없기 때문이다. 따라서 이를 방지하려면 각 슬롯에 default page를 만들어주면 새로고침으로 인해, 이전의 상태를 찾을 수 없을 경우 보여줄 페이지를 설정할 수 있다.
    ![](https://lh3.googleusercontent.com/d/1aexgovlGQdCDv2f8J9IxaafcsBFHT0ct)

### 인터셉팅 라우트
1. 인터셉팅 라우트란 사용자가 특정 경로로 접속해서 새로운 페이지를 요청할 때, 해당 요청을 가로채서 원래 렌더링 되는 페이지가 아닌 우리가 원하는 페이지를 대신 렌더링 하도록 설정할 수 있다.

2. 인터셉팅 라우트엔 특별한 조건이 있는데, 이는 초기 접속이 아닌 Link 컴포넌트나 router.push()를 통해 클라이언트 사이드 렌더링 방식으로 페이지에 접속한 경우에만 인터셉팅 라우트가 발동되는 조건이다.

3. 인터셉팅 라우트는 가로챌 페이지의 경로 앞에 (.)을 붙인 폴더를 생성하면, 해당 폴더 내부 파일이 인터셉트 할 때 보여줄 페이지이다. 이때, 소괄호() 안에 ., .., ...과 같이 가로챌 세그먼트의 위치를 정해줄 수 있다.
    - (.): 현재 레벨에서 세그먼트 가로채기
    - (..): 한 레벨 위에서 세그먼트 가로채기
    - (...): 두 레벨 위에서 세그먼트 가로채기
    - (....): 루트 레벨에서 세그먼트 가로채기 

4. 이렇게 가로챈 라우트는 보통 상세페이지로 바로 접속되는 게 아닌, 상세페이지를 모달 형태로 띄워줄 때 사용된다. 
    ![](https://lh3.googleusercontent.com/d/1LnrpQwVay7A_TmURLcboLSseR_KwXv03)

### 패럴랠 + 인터셉팅 라우트
1. 위에서 만든 인터셉팅 라우트는 잘 동작하지만 뒷 배경을 유심히 보면, index 페이지의 데이터가 없는것을 볼 수 있다. 이를 해결하기 위해 패럴랠 라우트와 인터셉팅 라우트를 적용해주기 위해 @modal 슬롯 내부에 인터셉팅 라우트를 위한 폴더를 위치시켜주고, 해당 슬롯은 상위 레이아웃의 props로 전달되니 루트 레이아웃에서 해당 modal을 렌더링 시켜준다. 이때, default.tsx를 통해 null을 리턴해줘야 '/'로 접속했을 때, 그대로 index 페이지가 렌더링될 수 있다.
    ![](https://lh3.googleusercontent.com/d/1snP977LS3wzTsEgm40NipmtJYeBencNZ)
    - 이제 결과를 보면, 뒷 배경에 병렬 라우트(패럴랠)가 적용되어 자연스러워졌다.
    ![](https://lh3.googleusercontent.com/d/1WuhDNz_-XdhnW4dvQIroho5XMCt6eQEg)

## section 10

### 이미지 최적화
1. 웹에서 차지하는 이미지는 58%이라고 한다. 따라서 이미지 최적화가 중요한데, Next.js에서는 이미지 최적화를 제공한다. 바로 Image 컴포넌트를 사용하면 된다.
    ![](https://lh3.googleusercontent.com/d/1raka0mn-PNxIC51j4dPyny2cHeqyogF6)

2. 기존 img 태그를 사용했을 땐, 현재 페이지의 화면에서 필요없는 이미지들이 전부 렌더링된다. (layz loading 미적용) 또한, 실제 이미지 크기에 필요한만큼 요청하지 않는다. 예로, 화면에서는 80 * 105의 크기로 이미지를 렌더링하지만, 실제 요청하는 이미지 크기는 400*400 인 셈이다. Image 컴포넌트를 적용하여 최적화 할 수 있다.

3. Image 컴포넌트를 사용할 땐 주의할 점이 있는데, 외부 이미지를 사용할 경우 해당 외부 이미지의 도메인을 next.config.mjs에 추가해줘야 한다.
    ![](https://lh3.googleusercontent.com/d/1yAmVrJjrvUCUZLK2iFF9MEfxItn9UnP8)

4. 결과는 이미지 형식이 webp로 변환되었고, 해당 이미지를 너무 큰 크기로 불러오지 않아 이미지 전체 크기가 줄었고, 한 번에 모든 이미지를 가져오지 않고 페이지를 스크롤할 때 이미지를 추가적으로 가져오기에 성능 측면에서 많이 개선된 것을 볼 수 있다.
    ![](https://lh3.googleusercontent.com/d/1n2IJ2Zk8SNbUQSYFWcjg-2e3z_dqryKA)


### 검색엔진 최적화 (SEO)
1. 검색엔진 최적화 중 메타 데이터 설정하는 방법은 해당 페이지에 export const metadata라고 변수를 선언해서 객체로서 내보내주면 된다.
    ```tsx
    export const metadata: Metadata = {
        title: '한 입 북스',
        description: '한 입 북스에 등록된 도서를 만나보세요.',
        openGraph: {
            title: '한 입 북스',
            description: '한 입 북스에 등록된 도서를 만나보세요.',
            images: ['/thumbnail.png'],
        }
    }
    ```

2. 동적인 값을 통해 메타 데이터를 설정해야하는 경우 generateMetadata라는 약속된 이름의 함수를 통해 설정할 수 있다.
    ```tsx
    export async function generateMetadata({searchParams}: {searchParams: Promise<q?: string>}) {
        const { q } = await searchParams;
        return {
            title: `${q}: 한 입 북스 검색`,
            description: `${q}의 검색 결과`,
            openGraph: {
                title: `${q}: 한 입 북스 검색`,
                description: `${q}의 검색 결과`,
                images: ['/thumbnail.png'],
                }
            }
    }
    ```

3. 메타 데이터에서도 데이터를 페칭 할 수 있다.
    ![](https://lh3.googleusercontent.com/d/11gIAyPngW3IX8Sf3VSj5BW-VFQ7SR_2u)