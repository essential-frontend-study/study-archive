# 🎯 [한 입 크기로 잘라 먹는 Next.js] - 섹션 7: 스트리밍과 에러핸들링
> 수강일: 2025.11.17

---

## 🧩 섹션 개요
- **섹션 목표:**
  - Next.js App Router 환경에서 스트리밍, Suspense, Skeleton UI, 에러 핸들링 같은 고급 렌더링/UX 기법을 체계적으로 이해하고 실제 페이지ㆍ레이아웃ㆍ컴포넌트에 적용할 수 있게 한다.
- **핵심 학습 포인트:**
  - 스트리밍 렌더링의 동작 워너리
  - `loading.tsx`의 역할과 동작 범위
  - Suspense를 이용한 컴포넌트 단위 스트리밍
  - Skeleton UI 디자인 패턴
  - 에러 핸들링의 구조
---

## 📌 강의별 정리

### 🔹 강의 1: 스트리밍이란?
- **핵심 내용:**
  - **스트림(Stream, 개천)**
  ![](https://velog.velcdn.com/images/iamsunwoo/post/afb02b2b-bcdc-40e7-a95d-8a3ddea0956c/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/62b33b35-9227-4c15-802d-f0d68ed556e3/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/ccde14a9-63c6-4c0c-a642-60708e3f3add/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/58bf41db-ee7b-4d6d-a226-a80f12718955/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/0dcaf6b2-c7c6-409a-a7ad-b472cad7c5db/image.png)
  - 대용량 데이터를 한 번에 전송하는 대신, **잘게 나눠 순차적으로 전달하는 방식**
  → 전체가 준비되기 전에도 일부 데이터에 접근이 가능하다.
  - 이러한 특성 덕분에 모든 데이터가 내려올 때까지 기다릴 필요가 없어
  **초기 UI가 빠르게 보여지고 UX가 향상**된다.
  - Next.js(App Router)는 이를 기반으로 **HTML 스트리밍을 기본 제공**한다.
  즉, 서버가 페이지를 렌더링할 때 **빠르게 준비되는 부분은 먼저 전송**
  비동기 결과가 필요한 부분은 나중에 스트리밍으로 이어서 전송한다.
  - 구현적으로는 React의 **Server Component + Suspense** 구조 덕분에 가능하며,
  Next.js가 이를 서버 HTML 스트림 형태로 변환한다.
  ![](https://velog.velcdn.com/images/iamsunwoo/post/998fd32f-f251-4184-9ddc-8bb0ec4f5c6f/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/2a32c72a-498a-47d3-84a6-ecec074e2e29/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/ff7fb7b9-0b00-4058-8765-8ce03104b99a/image.png)
  - Dynamic Page에서 자주 활용되며, 사용 흐름은 다음과 같다:
    1. 빠르게 렌더링 가능한 UI → 먼저 화면에 표시
    2. 비동기 fetch가 걸리는 UI → Loading UI 노출
    3. 백엔드 요청 완료 후 비동기 UI 스트리밍
- **내가 이해한 포인트:**
  - 스트리밍은 "전체 HTML 렌더링 완료 → 전송"이 아니라,
  **준비된 일부 → 즉시 전송, 나머지는 후속으로 전송**하는 SSR 최적화 방식
  - Suspense로 감싸진 서버 컴포넌트는 비동기 작업 완료 시점에
  추가 HTML 조각을 스트리밍해 화면에 이어 붙인다.
  - 사용자는 페이지 전환 시 아무것도 없는 하얀 화면을 보는 시간이 크게 줄어 UX가 강화된다.
  - 결론적으로 **SSR의 단점(대기 시간)을 최소화하고
  CSR의 장점(빠른 초기 로딩)을 일부 가져온 구조**
- **실무/프로젝트 적용 아이디어:**
  - 검색 결과 페이지, 상세 페이지처럼 fetch가 많이 필요한 페이지에서 사용하면
  로딩 체감이 크게 줄어든다.
- **질문/토론거리:**
  - Suspense의 클라이언트 컴포넌트 버전과 서버 컴포넌트 버전의 스트리밍 처리 방식 차이는?
---

### 🔹 강의 2: 스트리밍 1. 페이지 스트리밍 적용하기
- **핵심 내용:**
  - 특정 페이지에 스트리밍을 적용하려면 **해당 경로에 `loading.tsx` 파일을 생성**하면 된다.
  이 파일을 해당 페이지가 서버에서 비동기 작업을 수행하는 동안
  **SSR 단계에서 즉시 대체 UI로 렌더링**된다.
  - `loading.tsx`는 일종의 **페이지 단위 Suspense fallback**이며,
  Next.js가 내부적으로 자동 Suspense 경계를 생성한다.
  - **작동 범위**
    - 단순히 같은 디렉터리의 페이지 컴포넌트만이 아니라,
    `layout.tsx`가 존재하는 경우 **해당 레이아웃 하위의 모든 비동기 페이지**에 대해
    로딩 UI가 적용될 수 있다.
    - 즉, 디렉터리 구조 기반으로 **스트리밍의 적용 범위가 전파되는 구조**이다.
  - **트리거 조건**
    - 스트리밍은 **해당 페이지 컴포넌트가 async 함수**이거나
    내부에서 비동기 작업을 수행할 때만 실행된다.
    - 반드시 **페이지 컴포넌트에서만 자동 적용**된다.
    별도의 UI 컴포넌트 수준에서 스트리밍을 적용하고 싶다면,
    **React Suspense**를 직접 사용해야 한다.
  - **제한 사항**
    - 클라이언트 라우터에서 **단순 쿼리스트링 변경**같은
    shallow routing(새로고침 없이 URL을 변경)은 `loading.tsx`를 다시 실행하지 않는다.
    이는 서버에서 새 페이지를 렌더링하지 않기 때문이다.
    - `loading.tsx`는 **서버 컴포넌트 전용**이므로,
    클라이언트에서 JS로 비동기 작업을 기다리는 행동과 다르다.
- **코드 예제:**
  - **`loading.tsx`**
    ```ts
    export default function Loading() {
      return <div>Loading ...</div>;
    }
    ```
  - **고의적인 딜레이**
    - `delay.ts`
      ```ts
      export async function delay(ms: number) {
        return new Promise((resolve) => {
          setTimeout(() => {
            resolve('');
          }, ms);
        });
      }
      ```
- **내가 이해한 포인트:**
  - `loading.tsx`는 Next.js 가 제공하는 **페이지 수준 스트리밍 UI**이다.
  - Suspense를 별도 작성하지 않아도 자동으로 Suspense 경계가 생성된다.
  - 핵심은 서버가 비동기 fetch를 진행하기 전에
  즉시 렌더링해야 할 부분을 먼저 Streaming으로 클라이언트에 보내는 것
  - 페이지ㆍ레이아웃 트리의 구조에 따라 로딩 UI의 적용 범위가 결정되므로
  디렉터리 구조 설계가 중요하다.
  - 비동기 작업이 없는 페이지는 스트리밍이 발생하지 않으며,
  SSR의 속도와 완전히 동일하게 동작한다.
- **실무/프로젝트 적용 아이디어:**
  - 검색 페이지, 상세 페이지처럼 API 요청 시간이 길어질 수 있는 화면에서
  `layout + loading` 조합으로 초기 체감 성능을 개선할 수 있다.

---

### 🔹 강의 3: 스트리밍 2. 컴포넌트 스트리밍 적용하기
- **핵심 내용:**
  - `Suspense`
    - Suspense를 사용하면 페이지 단위가 아닌
    **컴포넌트 단위로 스트리밍을 세분화**하여 적용할 수 있다.
    즉, 페이지 전체 로딩 없이 필요한 컴포넌트만 부분적으로 스트리밍이 가능하다.
    - `loading.tsx`와는 달리,
    Suspense는 **개발자가 원하는 영역만 명확하게 감싸서 스트리밍 경계를 직접 설계**할 수 있다.
    - Suspense는 기본적으로 내부 데이터가 바뀌어도
    다시 로딩 상태로 돌아가지 않는다라는 특징이 있다.
    하지만, `Suspense` 컴포넌트에 **`key` 속성을 부여**하면,
    key 값이 바뀔 때마다 해당 Suspense가 **초기화 → fallback → 다시 스트리밍**하는 동작을 강제로 발생시킬 수 있다.
    - 쿼리스트링이 변경되더라도 자동으로 트리거되지 않기 때문에
    쿼리 변화를 기준으로 컴포넌트를 재로딩하고 싶다면 `<Suspense key={searchParams}>` 같은 방식이 필요하다.
    - 컴포넌트 스트리밍은 서버 컴포넌트에서만 효과가 있으며, 클라이언트 컴포넌트의 Suspense는 CSR fallback 전환만 담당한다.
    
- **코드 예제:**
    ```ts
    export const dynamic = 'force-dynamic';

    export default function Home() {
      return (
        <div className={style.container}>
          <section>
            <h3>지금 추천하는 도서</h3>
            <Suspense fallback={<div>도서를 불러오는 중입니다...</div>}>
              <RecoBooks /> // 서버 컴포넌트
            </Suspense>
          </section>
          <section>
            <h3>등록된 모든 도서</h3>
            <Suspense fallback={<div>도서를 불러오는 중입니다...</div>}>
              <AllBooks /> // 서버 컴포넌트
            </Suspense>
          </section>
        </div>
      );
    ```
- **내가 이해한 포인트:**
  - 컴포넌트 단위 Suspense는 페이지 전체가 로딩되는 것을 막고,
  필요한 부분만 따로 스트리밍할 수 있기 때문에 레이아웃과 페이지가 안정적으로 유지된다.
  - Suspense는 기본적으로 한 번 로딩 후엔 다시 로딩하지 않는다.
  → 그래서 쿼리 변경이나 state 변경에 따라 재로딩이 필요하면 반드시 `key`로 강제 초기화해야 한다.

---

### 🔹 강의 4: 스켈레톤 UI 적용하기
- **핵심 내용:**
  - **스켈레톤 UI(Skeleton UI)**
  ![](https://velog.velcdn.com/images/iamsunwoo/post/2650da18-9dd4-4ab7-b0c8-ab5298489555/image.png)
    - 데이터 로딩 중에 화면에 텅 빈 상태로 보이지 않도록,
    실제 UI 레이아웃과 유사한 형태의 **뼈대 UI**를 먼저 보여주는 패턴이다.
    - 사용자는 "비어 있음"이나 "깜빡임"을 보지 않고,
    해당 구조에 데이터가 곧 채워질 것이라는 인지를 하게 되어 UX가 크게 향상된다.
    - Next.js 자체 기능은 아니지만, React 기반에서 쉽게 적용할 수 있는 UI 전략이며
    `react-loading-skeleton` 같은 라이브러리를 사용하면 빠르게 구현 가능하다.
- **코드 예제:**
  - **Skeleton UI가 적용되는 컴포넌트**
    ```ts
    <Suspense fallback={<BookListSkeleton />}>
      <BookList />
    </Suspense>
    ```
  - **Skeleton UI**
    ```ts
    export default function BookListSkeleton() {
      ...
    }
    ```
- **내가 이해한 포인트:**
  - 스켈레톤 UI는 로딩 체감 속도를 극단적으로 줄이는 기법으로,
  실제 데이터보다 UI 뼈대를 먼저 보여줘 사용자가 기다리는 동안 답답함을 덜 느끼게 한다.
  - Suspense fallback에 단순 `Loading...` 텍스트 대신,
  **실제 UI 형태와 닮은 스켈레톤을 제공하면 UX가 훨씬 자연스러워진다.**

---

### 🔹 강의 5: 에러 핸들링
- **핵심 내용:**
  - `error.tsx`
    - Next.js App Router에서 제공하는 **페이지ㆍ컴포넌트 단위 에러 경계(Error Boundary)** 역할을 하는 파일이다.
    - 기존 `try/catch` 없이도 **서버 컴포넌트에서 발생한 오류를 UI에서 처리**할 수 있다.
    - 에러가 발생하면 해당 경로의 `error.tsx`가 렌더링된다.
    - 반드시 **`use client` 지시어를 포함해야 하며, 클라이언트 컴포넌트로 동작**해야 한다.
    - 기본적으로 두 가지의 Props를 제공한다.
      - `error`
        - 실제 Error 객체(메시지/스택 접근 가능)
      - `reset()`
        - 에러 상태 초기화 → 컴포넌트를 다시 렌더링하는 역할
        (단, 클라이언트 상태 초기화일 뿐, 서버 사이드 fetch를 자동 재실행하지는 않는다.)
    - 서버 컴포넌트의 데이터를 다시 불러오고 싶다면
    `useRouter().refresh()`를 사용해야 한다.
    → 이는 Next.js 서버에 **RSC Payload를 다시 전달해달라**고 요청하는 것이다.
    - `startTransition`
      - UI 업데이트를 한 번에 처리하는 React 기능이며,
      에러 복구 시 UI Blocking 없이 자연스러운 전환을 유도할 때 유용하다.
      - 하나의 콜백 함수를 인자로 전달 받아서
      콜백 함수 안에 들어있는 UI를 변경 시키는 작업들을 일괄적으로 처리
    - `error.tsx`는 해당 폴더뿐 아니라 **동일 경로 + 모든 하위 경로에서도 동작**하며, 
    보다 상세한 에러 처리가 필요하면 특정 폴더 안에 별도 `error.tsx`를 생성해
    Local Error Boundary처럼 사용할 수 있다.
    ![](https://velog.velcdn.com/images/iamsunwoo/post/83c8dcf9-ca54-4376-a6ae-dd180f5ff45f/image.png)
    - 에러 페이지 렌더링 시 **현재 경로의 layout.tsx**까지는 유지되고, 그 아래 UI만 대체된다.
- **코드 예제:**
  - `error.tsx`    
    ```ts
    'use client';

    import { useRouter } from 'next/navigation';
    import { useEffect, startTransition } from 'react';

    export default function Error({
      error,
      reset,
    }: {
      error: Error;
      reset: () => void;
    }) {
      const router = useRouter();

      useEffect(() => {
        console.error(error.message);
      }, [error]);

      return (
        <div>
          <h3>오류가 발생했습니다.</h3>
          <button
            onClick={() => {
              // UI blocking 없이 자연스러운 전환을 위한 startTransition
              startTransition(() => {
                router.refresh(); // 서버 컴포넌트 fetch 재실행
                reset();          // 에러 상태 초기화
              });
            }}
          >
            다시 시도
          </button>
        </div>
      );
    }
    ```
- **내가 이해한 포인트:**
  - `error.tsx`는 App Router에서 기본 제공하는 **서버ㆍ클라이언트 오류 대응 UI**이다.
  - 서버 컴포넌트에서 오류가 나면 클라이언트로 넘어오는 RSC Payload가 깨지는데,
  이 상황을 감지해 해당 경로의 error boundary가 렌더링된다.
  - `reset()`은 **컴포넌트 상태 초기화**일 뿐이고,
  서버에서 데이터를 다시 가져오고 싶다면 `router.refresh()`를 통해 RSC 재요청이 필요하다.
  -  에러는 재귀적으로 bubbling되며, **가장 가까운 `error.tsx`가 처리**한다.
  - 레이아웃은 유지되고, 에러가 발생한 부분만 UI가 교체되므로 사용자 경험이 끊기지 않는다.

---

# 🎯 [한 입 크기로 잘라 먹는 Next.js] - 섹션 8: 서버 액션
> 수강일: 2025.11.18

---

## 🧩 섹션 개요
- **섹션 목표:**
  - Next.js App Router 환경에서 **서버 액션의 개념ㆍ동작 방식ㆍ사용 패턴**을 이해한다.
  - 서버 액션을 활용해 리뷰 CRUD 기능을 구현하고
  클라이언트 컴포넌트와 연동하는 전체 흐름을 익힌다.
  - 정적 캐싱과 연계된 **재검증** 매커니즘을 실습을 통해 체득한다.
- **핵심 학습 포인트:**
  - 서버 액션의 기본 개념, 호출 방식, `use server` 지시어의 역할
  - FormData와 서버 액션의 데이터 전달 구조
  - `revalidatePath`, `revalidateTag`를 이용한 다양한 캐시 재검증 전략
  - 클라이언트 컴포넌트에서 `useActionState`로 서버 액션 실행/상태 처리하기
---

## 📌 강의별 정리

### 🔹 강의 1: 서버 액션을 소개합니다
- **핵심 내용:**
  - **서버 액션(Server Action)**
    - 브라우저(클라이언트)에서 폼 제출 시, Next.js 서버에서 즉시 실행되는 비동기 함수
    - 말 그대로 `폼 전송 → 서버에서 바로 실행될 함수 호출` 패턴을 공식적으로 제공하는 기능
    - App Router 환경에서 **별도의 API 라우트(`app/api/...`)를 만들지 않아도
    자동으로 API Endpoint가 생성**되며, 해당 엔드포인트를 통해 서버 액션이 호출된다.
    - 서버 액션 내부에서 DB 접근, 비밀 키 사용, 보안이 필요한 로직 등을
    안전하게 수행 가능하다.
    ![](https://velog.velcdn.com/images/iamsunwoo/post/1f6bd91f-6aaf-4794-8fee-dc493e7da529/image.png)![](https://velog.velcdn.com/images/iamsunwoo/post/dea6dce3-233f-4307-97dc-834f80cc2927/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/744262d3-74d5-4334-bdbe-79825f521963/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/5968626d-d2fa-4998-9e98-d90d12577ea9/image.png)
  - **서버 액션의 특징**
    - 서버 액션은 컴포넌트 내부에 선언하는 방식이 기본적인 사용 형태로 소개되지만,
    코드가 길어지거나 여러 컴포넌트에서 재사용해야 하는 경우에는 
    액션을 별도 파일로 분리하는 패턴도 함께 활용된다.
     - 확실하게 서버에서 실행되도록 **`use Server`** 지시어를 명시해야 한다.
     - 폼의 `action` 속성에 액션 함수를 그대로 전달하면
     Next.js가 자동으로 액션을 위한 API를 생성한다.
     - 서버 액션이 있는 컴포넌트는 **서버 컴포넌트로 강제**된다.
     - 폼 제출 시 전달되는 `FormData`는 타입이 `FormDataEntryValue | null`이며,
     `FormDataEntryValue`는 `string | File` 타입이다.
     ![](https://velog.velcdn.com/images/iamsunwoo/post/31da077c-df3b-474b-9ed4-f32cb93b85ac/image.png)
   - **서버 액션을 사용하는 이유**
     - 불필요한 API 라우팅/핸들러 생성 없이 **코드가 매우 간결**해진다.
     - 클라이언트에서 민감한 정보를 직접 다루지 않고,
     **서버에서만 처리 할 수 있어 보안성이 높다.**
     - 기존 `fetch` 함수 패턴보다 자연스럽고 직관적이다.
- **코드 예제:**
    ```ts
    function ReviewEditor() {
      async function createReviewAction(formData: FormData) {
        'use server';

        const content = formData.get('content')?.toString();
        const author = formData.get('author')?.toString();

        console.log(content, author);
      }

      return (
        <section>
          <form action={createReviewAction}>
            <input name='content' placeholder='리뷰 내용' />
            <input name='author' placeholder='작성자' />
            <button type='submit'>작성하기</button>
          </form>
        </section>
      );
    }
    ```
- **내가 이해한 포인트:**
  - 서버 액션은 **클라이언트에서 서버 함수로 직접 접근하는 새로운 방식의 API 호출**이다.
  - 기존 API Routes를 만들 필요 없이 `form action={함수}` 만으로 서버에서 실행된다.
  - `use server`가 선언된 함수는 반드시 서버에서만 실행된다.
  - 서버 액션이 있는 컴포넌트는 서버 컴포넌트가 된다.
- **실무/프로젝트 적용 아이디어:**
  - **회원가입 / 로그인 / 리뷰 작성 / 게시글 생성**같은
  폼 중심 + 서버에서 처리해야 하는 로직에 적극 적용 가능
  - DB Insert/Update/Delete를 API 없이 곧바로 수행할 때 유용

---

### 🔹 강의 2: 리뷰 추가 기능 구현하기
- **핵심 내용:**
  - 서버 액션을 어떻게 응용할 수 있는지 보여주는 간단한 예시
  - 실제 데이터베이스에 접근하기 위해서는 추가적인 작업이 필요하기 때문에
  강의에서는 서버 액션을 적극적으로 활용하지는 않는다.
  - **참고 사항**
    - `<input>`에 `value`만 존재하고 `onChange`가 없으면
    React에서 제어 컴포넌트로 인식해서 경고가 발생할 수 있다.
    - 이런 경우 `readOnly`를 넣어서 의도적으로 값 변경이 필요 없는 필드임을 명시해야
    경고가 사라진다.
      - 보통 hidden input을 다룰 때 자주 사용하는 패턴이다.
- **코드 예제:**
  ```ts
  function ReviewEditor({ bookId }: { bookId: string }) {
    return (
      <section>
        <form action={createReviewAction}>
          <input hidden name='bookId' value={bookId} readOnly />
          <input name='content' placeholder='리뷰 내용' required />
          <input name='author' placeholder='작성자' required />
          <button type='submit'>작성하기</button>
        </form>
      </section>
    );
  }
  ```
- **내가 이해한 포인트:**
  - 서버 액션 함수는 폼 제출과 결합하면 훨씬 단순하게 데이터 처리를 연결할 수 있다.
  - hidden input에 `value`를 공급할 때
  React의 제어 컴포넌트 규칙 때문에 `readOnly`가 필요할 수 있다.

---

### 🔹 강의 3: 리뷰 조회 기능 구현하기
---

### 🔹 강의 4: 리뷰 재검증 구현하기
- **핵심 내용:**
  - `revalidatePath`
    - Next.js 서버에게 **특정 경로의 캐시를 무효화하고 재생성하도록 요청**하는 함수
    - **서버 컴포넌트 또는 서버 액션에서만 호출 가능**하다.
    → 클라이언트 컴포넌트에서는 사용할 수 없다.
    - 해당 경로에 연결된 모든 캐시(풀 라우트 캐시 + 데이터 캐시)를 전부 무효화한다.
    - 동작 방식 요약:
      1. 서버 액션에서 `revalidatePath('/book/[id]')` 호출
      2. Next.js는 해당 경로의 이전 HTML/RSC 캐시를 제거
      3. 다음 요청 시 서버는 새 데이터를 기반으로
      **다시 렌더링하여 새로운 캐시를 만들고 응답**
      ![](https://velog.velcdn.com/images/iamsunwoo/post/bef4fef0-9642-4898-a35d-b28b3ff3f27e/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/1b9e4062-d723-4ab7-9d76-2aa9a1d99683/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/9fd1cf02-ca16-4392-852e-c1350346f978/image.png)
    - 중요한 점은, 이 동작은 ISR과 유사해 보이지만
    빌드 타임에 미리 만들어둔 페이지가 있든 없든 상관없이
    **강제 리렌더링을 트리거**한다는 점이 핵심이다.


- **코드 예제:**
  ```ts
  'use server';

  import { revalidatePath } from 'next/cache';

  export default async function createReviewAction(formData: FormData) {
    const bookId = formData.get('bookId')?.toString();
    const content = formData.get('content')?.toString();
    const author = formData.get('author')?.toString();

    if (!bookId || !content || !author) return;

    try {
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_SERVER_URL}/review`,
        {
          method: 'POST',
          body: JSON.stringify({
            bookId,
            content,
            author,
          }),
        }
      );
      revalidatePath(`/book/${bookId}`);
    } catch (error) {
      console.log(error);
      return;
    }
  }
  ```
- **내가 이해한 포인트:**
  - 서버 액션 내부에서 `revalidatePath`를 호출해서, 특정 페이지의 캐시를 즉시 무효화할 수 있다.
  - 이렇게 하면 새 리뷰가 추가되었을 때 `/book/[id]` 페이지가 **즉시 최신 리뷰 목록을 반영**하게 된다.
  - 클라이언트 사이드에서 `router.refresh()`를 호출하는 방식과는 다르게,
  데이터의 신선함을 보장하는 역할을 서버에서 해결하는 형태
  - 결국, SSR처럼 항상 최신 데이터를 불러오고 싶지는 않지만
  특정 시점에는 최신 데이터를 강제로 반영하고 싶을 때 아주 유용한 도구이다.
- **실무/프로젝트 적용 아이디어:**
  - 리뷰, 댓글, 좋아요, 북마크 같은 **간단한 Mutate 작업** 후 최신 상태 반영에 적합하다.
  - 특히 다음과 같은 경우 매우 효과적이다:
    - 정적 캐싱을 사용하지만 **일부 구간만 빠르게 갱신**해야 할 때
    - 실시간은 아니어도 사용자 액션 직후 새로운 데이터가 보여야 할 때

---

### 🔹 강의 5: 다양한 재검증 방식 살펴보기
- **핵심 내용:**
  - Next.js는 캐시를 재검증하는 다양한 방식을 제공한다.
  - 페이지 단위, 레이아웃 단위, 태그 단위 등
  **캐시 무효화를 다양한 범위로 제어할 필요가 생길 수 있다.**
  - **`revalidatePath` 사용 패턴**
    - `revalidatePath(``/book/${bookId}``)`
      - 특정 URL에 해당하는 **단일 페이지만 재검증**
      - CRUD 이후 특정 페이지만 새로고침해야할 때 자주 사용
    - `revalidatePath('/book/[id]', 'page')`
      - 해당 파일 기반 라우트의 **모든 동적 페이지를 재검증**
      - 여러 페이지가 동일한 데이터 소스를 공유할 때 유용할 수 있다.
    - `revalidatePath('/(with-searchbar)', 'layout')`
      - 특정 레이아웃을 공유하는 **모든 페이지를 재검증**
      - 공통 UIㆍ공통 데이터가 레이아웃에서 로딩되는 경우 전체를 갱신하는 방식
    - `revalidatePath('/', 'layout')`
      - 루트 레이아웃 → 사실상 **전체 앱에 포함된 모든 데이터 재검증**
      - 거의 전체 캐시 초기화에 가깝다.
      - 실무에서는 자주 쓰지 않는 방식이다.
  - `revalidateTag('tag')`
    - `fetch` 함수 옵션에 `{ next: { tags: ["tag"] } }` 형태로 설정한 태그를 기준으로 데이터 캐시만 무효화
    - 페이지 전체를 지우는 재검증보다 훨씬 정교하고 안전한 방식
    - 데이터 캐시를 효과적으로 분리해둔 프로젝트일수록 효율이 극대화된다.
- **코드 예제:**
  ```ts
  "use server";

  import { revalidatePath, revalidateTag } from "next/cache";

  export async function updateBook(bookId: string) {
    // ... 책 정보 수정 로직

    // 1) 해당 책 상세 페이지만 재검증
    revalidatePath(`/book/${bookId}`);
  }

  export async function updateAllBooks() {
    // ... 책 리스트 관련 업데이트

    // 2) 동적 라우트 전체 재검증
    revalidatePath("/book/[id]", "page");
  }

  export async function updateSearchbarLayout() {
    // ... 레이아웃에 필요한 데이터 변경

    // 3) 특정 레이아웃을 갖는 페이지 전체 재검증
    revalidatePath("/(with-searchbar)", "layout");
  }

  export async function updateBookData() {
    // ... 책 데이터 변경

    // 4) 태그 기반 재검증 (정교한 캐시 무효화)
    revalidateTag("book-data");
  }
  ```
- **내가 이해한 포인트:**
  - 재검증은 단순 캐시 삭제가 아니라
  **다음 요청에서 다시 렌더하도록 Next.js에게 요청하는 과정**이다.
  - `revalidatePath`는 페이지 구조(파일, 폴더, 레이아웃)를 기준으로 재검증 범위를 제어하고,
  `revalidateTag`는 데이터 단위를 기준으로 제어한다.
  - 프로젝트 규모가 커질수록 **태그 기반 재검증이 훨씬 세밀하고 안정적**이다.
---

### 🔹 강의 6: 클라이언트 컴포넌트에서의 서버액션
- **핵심 내용:**
  - `useActionState`
    - 서버 액션과 폼 상태를 깔끔하게 결합할 수 있도록 제공하는 React 훅
    - `form` 태그의 `action`에 직접 서버 액션을 넣을 수도 있지만,
    **클라이언트 컴포넌트**에서 상태 관리가 필요할 때는 `useActionState`가 훨씬 편리하다.
    - 구조:
      ```ts
      const [state, formAction, isPending] = useActionState(actionFn, initialState)
      ```
      - `actionFn`: 서버 액션 함수
      → 작성한 서버 액션의 첫 번째 인자로 항상 `state`가 전달된다.
      - `initialState`: state의 초기값
      - `state`: 서버 액션의 반환값
      - `formAction`: `<form action={formAction}>`에 주입할 서버 액션 핸들러
      - `isPending`: 서버 액션이 실행되는 동안의 상태(true/false)
    - 서버 액션에서 반환하는 객체는 자동으로 `state`에 담기므로
    클라이언트 컴포넌트가 별도 fetch 없이 결과를 활용할 수 있다.
- **코드 예제:**
  - **서버 액션**
    ```ts
    'use server';

    import { delay } from '@/util/delay';
    import { revalidatePath } from 'next/cache';

    export default async function createReviewAction(_: any, formData: FormData) {
      const bookId = formData.get('bookId')?.toString();
      const content = formData.get('content')?.toString();
      const author = formData.get('author')?.toString();

      if (!bookId || !content || !author) {
        return {
          status: false,
          error: '리뷰 내용과 작성자를 입력해주세요',
        };
      }

      try {
        await delay(2000);
        const response = await fetch(
          `${process.env.NEXT_PUBLIC_API_SERVER_URL}/review`,
          {
            method: 'POST',
            body: JSON.stringify({
              bookId,
              content,
              author,
            }),
          }
        );
        if (!response.ok) {
          throw new Error(response.statusText);
        }
        revalidatePath(`/book/${bookId}`);
        return {
          status: true,
          error: '',
        };
      } catch (error) {
        return {
          status: false,
          error: `리뷰 저장에 실패했습니다: ${error}`,
        };
      }
    }

    ```
  - **클라이언트 컴포넌트**
    ```ts
    'use client';

    import { useActionState, useEffect } from 'react';
    import style from './review-editor.module.css';
    import createReviewAction from '@/actions/create-review-action';

    export default function ReviewEditor({ bookId }: { bookId: string }) {
      const [state, formAction, isPending] = useActionState(
        createReviewAction,
        null
      );

      useEffect(() => {
        if (state && !state.status) {
          alert(state.error);
        }
      }, [state]);

      return (
        <section>
          <form className={style.form_container} action={formAction}>
            <input hidden name='bookId' value={bookId} readOnly />
            <textarea
              disabled={isPending}
              name='content'
              placeholder='리뷰 내용'
              required
            />
            <div className={style.submit_container}>
              <input
                name='author'
                disabled={isPending}
                placeholder='작성자'
                required
              />
              <button type='submit' disabled={isPending}>
                {isPending ? '...' : '작성하기'}
              </button>
            </div>
          </form>
        </section>
      );
    }
    ```
- **내가 이해한 포인트:**
  - 클라이언트 컴포넌트에서도 서버 액션을 직접 호출할 수 있으며,
  `useActionState`를 사용하면 상태ㆍ결과ㆍ로딩을 모두 얻을 수 있다.
  - 서버 액션이 반환하는 값은 클라이언트에서 `state`로 접근할 수 있으므로
  응답 처리 로직을 클라이언트에서 작성할 필요가 없다.
  - 서버 액션의 첫 번째 인자는 항상 `state`이므로
  `createReviewAction(state, formData)` 형태로 호출된다는 점을 기억해야 한다.
  - `isPending`은 서버 액션 실행 여부를 반영하기 때문에
  버튼 비활성화, 로딩 UI 처리 등을 매우 간단하게 만들 수 있다.

---

### 🔹 강의 7: 리뷰 삭제 기능 구현하기
- **핵심 내용:**
  - 리뷰 삭제 기능 역시 서버 액션을 사용해 구현할 수 있다.
  - 이번에는 `revalidatePath` 대신 **`revalidateTag`**를 사용하여
  **데이터 캐시 단위로 더 정교하게 재검증**하는 패턴을 학습한다.
- **코드 예제:**
  ```ts
  'use server';

  import { revalidatePath, revalidateTag } from 'next/cache';

  export async function deleteReviewAction(_: any, formData: FormData) {
    const reviewId = formData.get('reviewId')?.toString();
    const bookId = formData.get('bookId')?.toString();

    if (!reviewId) {
      return {
        status: false,
        error: '삭제할 리뷰가 없습니다',
      };
    }

    try {
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_SERVER_URL}/review/${reviewId}`,
        { method: 'DELETE' }
      );

      if (!response.ok) {
        throw new Error(response.statusText);
      }

      revalidateTag(`review-${bookId}`);

      return {
        status: true,
        error: '',
      };
    } catch (error) {
      return {
        status: false,
        error: `리뷰 삭제 실패: ${error}`,
      };
    }
  }
  ```
- **내가 이해한 포인트:**
  - 재검증 전략을 페이지 단위에서 데이터 단위로 세밀하게 적용하는 예시이다.
  - 데이터 fetch 시 `{ next: { tags: ["tag"] } }`로 태깅만 해두면
  나중에 필요할 때 해당 태그만 골라서 무효화할 수 있다.

---

# 🎯 [한 입 크기로 잘라 먹는 Next.js] - 섹션 9: 고급 라우팅 패턴
> 수강일: 2025.11.19

---

## 🧩 섹션 개요
- **섹션 목표:**
  - Parallel Route와 Intercepting Route의 개별 동작 원리를 정확히 이해한다.
  - 두 라우팅 기술을 조합하여 모달 기반의 자연스러운 UX를 구현하는 방법을 학습한다.
  - CSR / SSR 접근 방식에 따라 동일한 URL이 다른 방식으로 렌더링되는 흐름을 이해한다.
- **핵심 학습 포인트:**
  - Parallel Route의 동작 구조
  - Intercepting Route의 핵심 동작
  - Parallel + Intercepting 조합 패턴
---

## 📌 강의별 정리

### 🔹 강의 1: 패럴렐 라우트
- **핵심 내용:**
  - `Parallel Route(병렬 라우트)`
    - 하나의 화면에서 **여러개의 페이지 컴포넌트를 동시에 병렬로 렌더링**할 수 있는 기능
    - 여러 UI 영역을 독립적으로 구성하고, 각각을 별도 라우트처럼 다룰 수 있다.
  ![](https://velog.velcdn.com/images/iamsunwoo/post/7e1d03ba-d02b-4516-a932-1bc3b6b9b6b6/image.png)![](https://velog.velcdn.com/images/iamsunwoo/post/b9e8a080-bba6-45eb-818b-af7391657607/image.png)
    - **slot(슬롯)**
    ![](https://velog.velcdn.com/images/iamsunwoo/post/298a2735-f241-473d-9995-0c66d7ed7ad4/image.png)
      - 폴더 이름에 `@` 접두사를 붙이면 해당 폴더는 **슬롯**으로 인식된다.
      - 슬롯은 병렬로 렌더링될 페이지 컴포넌트를 보관하는 폴더이며,
    슬롯 내부에 페이지 컴포넌트를 추가하면 **부모 layout이 자동으로 Props를 전달받는다.**
      - 개발 모드에서 반영이 안되면 `.next` 폴더 삭제 후 서버 재시작이 필요할 수 있다.
      - 슬롯은 **URL 경로에 포함되지 않으며**, 단순히 UI 구성 단위로만 사용된다.
      - 원하는 만큼 여러 슬롯을 만들 수 있고, 슬롯 내부에 또 다른 폴더 생성도 가능하다.
      - **슬롯별 업데이트 규칙**
        - 특정 슬롯의 페이지만 새로 업데이트 될 수 있으며,
      다른 슬롯들은 이전 상태를 그대로 유지한다.
        - 이 동작은 **클라이언트 사이드 렌더링(Link를 통한 이동)**에서만 유효하다.
    - `default.tsx`
      - URL을 통해 Parallel Router 내부 폴더로 접근했으 때 404 대신
      **fallback 역할을 할 기본 페이지를 제공**하는 파일
      
    <blockquote>
  
    📦admin
     ┣ 📂@dashboard
     ┃ ┣ 📂chart
     ┃ ┃ ┗ 📜page.tsx
     ┃ ┣ 📜default.tsx ← `admin/chart`를 URL로 접근 시 404 대체
     ┃ ┗ 📜page.tsx
     ┣ 📜default.tsx ← **@dashboard의 부모 default.tsx도 필수로 존재해야 함🔥**
     ┣ 📜layout.tsx
     ┗ 📜page.tsx
  
     </blockquote>
  
- **코드 예제:**
  - 부모 Layout에서 병렬 슬롯 받기
    ```ts
    import { ReactNode } from 'react';

    export default function Layout({
      children,
      sidebar,
    }: {
      children: ReactNode;
      sidebar: ReactNode;
    }) {
      return (
        <div>
          {sidebar}
          {children}
        </div>
      );
    }
    ```
- **내가 이해한 포인트:**
  - Parallel Routes는 한 화면에서 여러 페이지를 동시에 보여줘야 하는 상황에
  최적화된 라우팅 방식이다.
  - 슬롯이라는 개념을 통해 UI 영역을 완전히 독립적으로 관리할 수 있다.
- **실무/프로젝트 적용 아이디어:**
  - 페이스북ㆍXㆍ인스타그램처럼 **리스트 + 상세페이지**가 동시에 보여야 하는 레이아웃
---

### 🔹 강의 2: 인터셉팅 라우트
- **핵심 내용:**
  - **Intercepting Route(인터셉팅 라우트)**
  ![](https://velog.velcdn.com/images/iamsunwoo/post/0233596b-5305-41bd-8ae9-93d29de8725c/image.png)
    - 동일한 URL 경로로 접근하더라도,
    **접근한 상황(초기 진입인지, 내부 네비게이션인지 등)에 따라 다른 UI를 렌더링하는 기능**
    - 예를 들어,
      - URL을 직접 입력한 경우 → 초기 진입이므로 **원래의 전체 페이지**
      - 리스트에서 클릭하여 이동한 경우 → **모달로 인터셉트된 페이지**
      ![](https://velog.velcdn.com/images/iamsunwoo/post/a3bf88d6-ad38-4de3-a36e-dcd110ad61ee/image.png)
    - **인터셉팅 발생 조건**
      - 초기 접속 요청인지 여부(CSR/SSR)에 따라
      원래 페이지 또는 인터셉트 페이지 중 하나를 선택한다.
      - 즉, 클라이언트 사이드 네비게이션일 때만 인터셉트가 동작한다.
      서버 요청(브라우저 주소창 입력)은 인터셉트 되지 않는다.
    - **인터셉팅 라우트 문법**
      - 페이지를 인터셉트하려면 폴더 이름을 `(.)book/[id]` 형태로 지정한다.
      - `(.)`
        - 현재 경로의 같은 레벨의 라우트를 인터셉트하겠다는 의미
      - `(..)`
        - 현재 경로의 이전 레벨의 라우트를 인터셉트하겠다는 의미
        - `(..)(..) …` 형태도 가능
      - `(...)`
        - **App 루트** 바로 아래의 라우트를 인터셉트하겠다는 의미
    - **동작 방식 정리**
      - CSR 이동일 때만 인터셉트
      - SSR 또는 URL 직접 입력은 원래 페이지가 뜬다.
    - **createPortal을 이용한 모달 구성**
      - 인터셉트된 페이지는 UI적으로 **모달**로 표시하는 경우가 많아
      `createPortal`을 활용해 독립된 DOM 노드에 렌더링한다.
- **코드 예제:**
  - **인터셉팅 페이지 컴포넌트**
    ```ts
    import BookPage from '@/app/book/[id]/page';

    export default function Page(props: any) {
      return (
        <div>
          <BookPage {...props} />
        </div>
      );
    }
    ```
  - **모달 컴포넌트**
    ```ts
    'use client';

    import { ReactNode, useEffect, useRef } from 'react';
    import style from './modal.module.css';
    import { createPortal } from 'react-dom';

    export default function Modal({ children }: { children: ReactNode }) {
      const dialogRef = useRef<HTMLDialogElement>(null);

      useEffect(() => {
        if (!dialogRef.current?.open) {
          dialogRef.current?.showModal();
          dialogRef.current?.scrollTo({
            top: 0,
          });
        }
      }, []);

      return createPortal(
        <dialog className={style.modal} ref={dialogRef}>
          {children}
        </dialog>,
        document.getElementById('modal-root') as HTMLElement
      );
    }
    ```
  - **모달 스타일**
    ```css
    .modal {
      width: 80%;
      max-width: 500px;

      margin-top: 20px;
      border-radius: 5px;
      border: none;
    }

    .modal::backdrop {
      background: rgba(0, 0, 0, 0.7);
    }
    ```
- **내가 이해한 포인트:**
  - 인터셉팅 라우트는 URL은 같지만 UI는 다르게 보여줘야할 때 유용하다.
  - 동작 조건이 **CSR 기반**이라는 게 핵심
  즉, 어떻게 이동했는지에 따라 렌더링되는 UI가 달라진다.
- **실무/프로젝트 적용 아이디어:**
  - **모달 상세 페이지**
    - 목록 화면에서 카드 클릭 → 모달 상세
    - URL은 그대로 유지 가능
    - 새로고침하면 전체 상세 페이지로 정상 이동
  - **대화 리스트 + 채팅 모달**
    - 리스트에서 클릭 시 채팅방을 모달로 띄우고, 직접 URL 접근하면 전체 채팅화면으로 렌더링

---

### 🔹 강의 3: 패럴렐 & 인터셉팅 라우트
- **핵심 내용:**
  - **Parallel + Intercepting Route Pattern**
    - `/book/[id]` 페이지를 인터셉팅하여 모달로 띄우면서,
    동시에 기존 인덱스 페이지 위에서 모달이 동작하게 하고 싶을 때 폴더 구조를 아래와 같은 방식으로 구성해야 한다.
      <blockquote>

      📦app
       ┣ 📂@modal
       ┃ ┗ 📂(.)book
       ┃ ┃ ┗ 📂[id]
       ┃ ┃ ┃ ┗ 📜page.tsx
       ┣ 📜favicon.ico
       ┣ 📜globals.css
       ┣ 📜layout.tsx ← 여기서 modal을 Props로 받아서 설정해야 한다.
       ┗ 📜page.tsx
  
      </blockquote>
    - 즉, 상세 페이지를 모달로 띄우되, 그 모달이 현재 보고 있던 페이지를 덮는 형태로 보여지길 원할 때
    → Parallel Route의 슬롯(`@modal`)과 Interception Router의 `(.)` 문법을 함께 사용한다.
- **내가 이해한 포인트:**
  - Parallel Route는 기존 화면을 유지한 채 특정 UI만 병렬로 렌더링하는 구조를 만든다.
  - Intercepting Route는 **CSR/SSR 접근 방식에 따라 다른 UI를 렌더링하는 조건부 라우팅**을 만든다.
  - 두 기능을 조합하면:
    - 리스트 페이지에서 항목 클릭 시 → 상세 페이지를 모달로 인터셉트
    - URL 직접 접근 시 → 모달이 아닌 정상적인 전체 페이지
---
# 🎯 [한 입 크기로 잘라 먹는 Next.js] - 섹션 10: 최적화와 배포
> 수강일: 2025.11.19

---

## 🧩 섹션 개요
- **섹션 목표:**
  - Next.js 애플리케이션을 실제 배포 환경에 적합한 형태로 최적화하는 방법을 이해한다.
  - Vercel 배포 후 제공되는 설정을 활용해 서비스 성능을 체계적으로 향상시키는 방법을 익힌다.
- **핵심 학습 포인트:**
  - `<Image>` 컴포넌트 기반 이미지 최적화 원리 이해
  - SEO 구성 방법
  - Vercel 배포에서 고려해야 하는 설정
---

## 📌 강의별 정리

### 🔹 강의 1: 이미지 최적화
- **핵심 내용:**
  - 웹에서 이미지 최적화는 필수이며, Next.js는 이를 `<Image>` 컴포넌트를 통해
  **자동화된 방식**으로 제공한다.
  - `<Image>`는 브라우저별 최적화된 포맷(WebP 등), 크기 조절, Lazy Loading 등 다양한 기능을 기본적으로 적용해준다.
  ![](https://velog.velcdn.com/images/iamsunwoo/post/4f2105f2-9b3f-4e99-99d7-00d452bc9346/image.png)
  - `<Image>` 컴포넌트에서 사용하는 `src`는 **프로젝트 내부의 정적 파일이거나**,
  **외부 이미지를 허용한 도메인**이어야 한다.
  - 외부 이미지를 사용할 경우 `next.config.ts`에 반드시 도메인을 등록해야 한다.
  ![](https://velog.velcdn.com/images/iamsunwoo/post/e8279da4-581a-4b42-aa8d-f75879870122/image.png)
  - **이미지 최적화 전**
  ![](https://velog.velcdn.com/images/iamsunwoo/post/2db430c8-834b-405c-b3be-796a73f6dc6b/image.png)
  - **이미지 최적화 후**
  ![](https://velog.velcdn.com/images/iamsunwoo/post/d6e5c005-8b89-4788-9ed7-b5ceb4e83754/image.png)
- **코드 예제:**
  - `<Image>` 컴포넌트 사용 예제
    ```ts
    <Image
    src={coverImgUrl}
    width={80}
    height={105}
    alt={`도서 ${title}의 표지 이미지`}
    />
    ```
  - `next.config.ts`
    ```ts
    import type { NextConfig } from 'next';

    const nextConfig: NextConfig = {
      ...
      
      images: {
        domains: ['shopping-phinf.pstatic.net'],
      },
    };
    ```
- **내가 이해한 포인트:**
  - Next.js의 `<Image>`는 성능 최적화를 자동 처리해준다.
  - 외부 이미지 사용 시 반드시 `images.domains` 설정이 필요하다.
  - HTML `<img>`로는 불가능한 다양한 최적화를 기본 제공한다.
  - 이미지 최적화 여부에 따라 실제 트래픽과 렌더링 성능 차이가 명확하게 발생한다.
---

### 🔹 강의 2: 검색 엔진 최적화(SEO)
- **핵심 내용:**
  - 검색 엔진 최적화 방법 
  ![](https://velog.velcdn.com/images/iamsunwoo/post/b37c9cd7-a668-4cfe-ae7f-1a471865515f/image.png)
  - **메타 데이터 설정하기**
    - 페이지 단위에서 `metadata` 객체 또는 `generateMetadata()` 함수로 SEO 정보를 선언적인 방식으로 관리할 수 있다.
    - **정적 메타 데이터**
      - 페이지 파일에 `export const metadata`를 추가해 설정
    - **동적 메타 데이터**
      - 쿼리 파라미터, 동적 세그먼트 등에 따라 메타 태그가 달라져야 하는 경우
      `generateMetadata()` 함수를 사용
  - favicon은 `app/favicon.ico` 경로 기준으로 자동 인식된다.
- **코드 예제:**
  - `'/'` 페이지에 정적 메타 데이터 설정하기
    ```ts
    export const metadata: Metadata = {
      title: '한입 북스',
      description: '한입 북스에 등록된 도서를 만나보세요',
      openGraph: {
        title: '한입 북스',
        description: '한입 북스에 등록된 도서를 만나보세요',
        images: ['/thumbnail.png'],
      },
    };

    export default function Home() {
    ```
  - 동적 경로에서 메타 데이터 설정하기
    ```ts
    export async function generateMetadata({
      searchParams,
    }: {
      searchParams: Promise<{ q?: string }>;
    }): Promise<Metadata> {
      const { q } = await searchParams;

      return {
        title: `${q}: 한 입 북스 `,
        description: `${q}의 검색 결과 입니다.`,
        openGraph: {
          title: `${q}: 한 입 북스`,
          description: `${q}의 검색 결과 입니다.`,
          images: ['/thumbnail.png'],
        },
      };
    }

    export default async function Page({
      searchParams,
    }: {
      searchParams: { q?: string };
    }) {
      return (
        <Suspense key={searchParams.q} fallback={<BookListSkeletion count={3} />}>
          <SearchResult q={searchParams.q || ''} />
        </Suspense>
      );
    }
    ```
- **내가 이해한 포인트:**
  - 정적/동적 메타 데이터를 나눠 설정할 수 있어, 페이지 특성에 맞춰 SEO를 세밀하게 제어할 수 있다.
  - `generateMetadata`는 서버 사이드에서 실행되므로, 검색어 기반 페이지 타이틀ㆍ설명을 안전하게 구성할 수 있다.
---

### 🔹 강의 3: 배포하기
---

### 🔹 강의 4: 배포 후 최적화
- **핵심 내용:**
  - Next.js 프로젝트를 Vercel에 배포한 후에는
  **지역(Region) 설정**을 통해 응답 속도를 최적화할 수 있다.
  - 서비스 이용자가 한국에 많다면, Vercel Dashboard에서 Region을 Seoul로 선택해
  데이터 전송 거리를 줄이고 더 빠른 페이지 로딩을 기대할 수 있다.
---

### 🔹 강의 5: 마치면서
---
