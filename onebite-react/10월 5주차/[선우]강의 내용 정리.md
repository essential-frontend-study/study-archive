# 🎯 [한 입 크기로 잘라 먹는 리액트] - 섹션 13: 프로젝트3. 감정 일기장
> 수강일: 2025.10.16 ~ 2025.10.21

---

## 🧩 섹션 개요
- **섹션 목표:**
  - 외부 폰트 사용법 익히기
  - 이미지 최적화 및 사용 방법
  - 여러 페이지 구조 설계 및 라우팅 구현
  - 공통 컴포넌트로 UI 모듈화
  - 복잡한 데이터를 다루는 방법
  - 리액트 앱을 실제로 배포하는 방법
- **핵심 학습 포인트:**
  - SPA VS MPA의 구조적 차이
  - React Router를 활용한 페이지 이동
  - Vite의 이미지 최적화 동작 원리
  
---

## 📌 강의별 정리

### 🔹 강의 2: 페이지 라우팅 1. 소개
- **핵심 내용:**
  - 페이지 라우팅이란?
    → 브라우저의 경로(path)에 따라 적절한 페이지를 렌더링하는 과정
    ![](https://velog.velcdn.com/images/iamsunwoo/post/7870dc4f-3a6c-48b8-ba53-a55440dd9381/image.png)
  - **MPA vs SSR vs SPA**
    - **MPA(Multi Page Application)**
      - 서버가 여러 HTML 파일을 보유하고, 요청 시 해당 HTML을 반환
      - 페이지 이동 시 전체 페이지를 교체 → 화면 깜빡임, 서버 부하 증가
        ![](https://velog.velcdn.com/images/iamsunwoo/post/b578343e-7071-4800-a16f-375897403cb5/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/cb42f508-d4bd-403d-a207-d3c5b470cb4e/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/a3ae759e-4431-466d-a448-39b44f1df4dc/image.png)
    - **SSR(Server Side Rendering)**
      - 서버에서 HTML을 미리 렌더링 후 클라이언트에 전달
      - 초기 로딩 속도는 빠르지만, 클라이언트 상호작용은 JS가 실행된 뒤 가능
        ![](https://velog.velcdn.com/images/iamsunwoo/post/1b341a1d-1f28-4737-81df-02a28fa0fb3d/image.png)
    - **SPA(Single Page Application)**
      - React App의 대표적 구조
      - 어떤 경로로 접근해도 `index.html` 단 하나의 파일을 반환
      - 이후 JS 파일들을 번들링해서 한 번에 반환(Vite 담당)
      - 브라우저에서 JS가 직접 DOM을 렌더링하는 CSR(Client Side Rendering) 구조
        ![](https://velog.velcdn.com/images/iamsunwoo/post/4f30f26f-c39d-429d-aead-37a9f30b48d7/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/7eaa5328-5b50-498c-b580-1f2126f0b726/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/2b6cd9e5-e1a7-4923-b857-e3167d15b7c8/image.png)![](https://velog.velcdn.com/images/iamsunwoo/post/884e8f67-8c46-48a9-acae-1199cbed6d05/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/c1b7a8e4-b07b-42cd-8cab-1488bdd1440e/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/aa104acb-9bea-4121-9421-469031ca7c57/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/a5324268-652c-43fb-81e6-31a45edd0a9b/image.png)

- **내가 이해한 포인트:**
  - SPA 구조에서는 라우팅이 실제 HTML 파일 교체가 아니라 **컴포넌트 교체 수준**에서 발생한다.
- **실무/프로젝트 적용 아이디어:**
  - 사내 대시보드나 관리자 페이지처럼 데이터 기반으로 화면 전환이 많은 경우 SPA 구조가 적합
  - SEO가 중요한 서비스(예: 블로그)는 SSR 혹은 SSG 도입 고려

---

### 🔹 강의 3: 페이지 라우팅 2. 라우팅 설정하기
- **핵심 내용:**
  - `react-router-dom` 설치
    ```bash
    npm i react-router-dom
    ```
  - `main.jsx`에서 `App` 컴포넌트를 `BrowserRouter`로 감싼다.
  - `BrowserRouter`
    - 브라우저의 현재 주소를 저장하고 감지하는 역할
    - `App` 컴포넌트를 감싸게 되면 모든 컴포넌트들이 현재 브라우저의 주소를 불러와서 쓸 수 있고, 주소의 변화를 감지할 수도 있게 된다.
    
      ![](https://velog.velcdn.com/images/iamsunwoo/post/dbf186ee-85a2-4cbc-b54b-ab135ddfd68e/image.png)
      - 컴포넌트 트리 구조 상, BrowserRouter에 보관되는 데이터들은 Context 객체의 Provider(Navigation, Location) 컴포넌트를 통해 App 컴포넌트의 모든 자손에게 공급이 가능하다.
  - `<Routes>` 안에 `<Route>`를 정의해 경로별 컴포넌트를 연결한다.
    - `Routes`  사용 시 유의 사항
      1. `Routes` 컴포넌트 안에는 `Route` 컴포넌트만 사용이 가능하다.
      2. `Routes` 컴포넌트 바깥에 배치된 요소들은 페이지 라우팅과는 관련 없이, 모든 페이지에 다 동일하게 렌더링 된다.
      3. `Route`의 `path` 프로퍼티에 와일드카드(`*`) 사용 시 Not Found 페이지를 반환한다.
- **코드 예제:**
  - `Main.jsx`
  ```js
  import { createRoot } from 'react-dom/client';
  import { BrowserRouter } from 'react-router-dom';
  import App from './App.jsx';
  import './index.css';

  createRoot(document.getElementById('root')).render(
    <BrowserRouter>
      <App />
    </BrowserRouter>
  );
  ```
  - `App.jsx`
  ```js
  import { Route, Routes } from 'react-router-dom';
  import Home from './pages/Home';
  import New from './pages/New';
  import Diary from './pages/Diary';
  import NotFound from './pages/NotFound';

  // 1. "/": 모든 일기를 조회하는 Home 페이지
  // 2. "/new": 새로운 일기를 작성하는 New 페이지
  // 3.  "/diary": 일기를 상세히 조회하는 Diary 페이지
  function App() {
    return (
      <Routes>
        <Route path='/' element={<Home />} />
        <Route path='/new' element={<New />} />
        <Route path='/diary' element={<Diary />} />
        <Route path='*' element={<NotFound />} />
      </Routes>
    );
  }

  export default App;
  ```
- **내가 이해한 포인트:**
  - `BrowserRouter`는 Context 기반으로 경로 정보를 전파한다.

---

### 🔹 강의 4: 페이지 라우팅 3. 페이지 이동
- **핵심 내용:**
  - 내부 이동 시 `<Link>` 컴포넌트를 사용
  → `<a>`는 페이지 전체를 다시 로드하기 때문에 CSR이 깨진다.
  - 동적 이동 시 `useNavigate()` 훅을 활용
  - `Link` 컴포넌트를 이용해서 페이지를 이동할 수 있다.
- **코드 예제:**
  - `Link`를 사용한 페이지 이동
    ```js
    <Link to={'/'}>Home</Link>
    ```
  - `useNavigate` 훅을 사용한 페이지 이동
    ```js
    const nav = useNavigate();

    const onClickButton = () => {
      nav('/new');
    };

    return (
      <button onClick={onClickButton}>New 페이지로 이동</button>
    )
    ```
- **내가 이해한 포인트:**
  - 상태를 유지한 채 화면만 교체할 수 있다는 점이 CSR의 핵심
- **실무/프로젝트 적용 아이디어:**
  - `useNavigationType()`으로 이동 원인(push/back 등)을 구분할 수 있다.
  - `useNavigate(-1)`로 브라우저 뒤로가기 구현이 가능하다.
  - 사용자가 브라우저 뒤로가기를 눌렀을 때 특정 동작(예: 폼 경고) 구현이 가능하다.

---

### 🔹 강의 5: 페이지 라우팅 4. 동적 경로
- **핵심 내용:**
  - **URL Parameter**
    - `/diary/:id` 형태로 고정된 값 전달
    - `useParams()` 훅으로 Parameter 추출
  - **Query String**
    - 자주 변하는 검색어, 필터 값 등에 활용
    - `useSearchParams()` 훅은 현재 값과 값을 변경할 수 있는 함수를 제공한다.
- **코드 예제:**
  - **URL Parameter**
    - `App.jsx`
      ```js
      <Route path='/diary/:id' element={<Diary />} />
      ```
    - `Diary.jsx`
      ```js
      const Diary = () => {
        const params = useParams();
        return <div>Diary {params.id}</div>;
      };
      ```
   - **Query String**
     - `Home.jsx`
      ```js
      import { useSearchParams } from 'react-router-dom';

      const Home = () => {
        const [params, setParams] = useSearchParams();

        // 도메인?value=123&color=red
        console.log(params.get('value')); // 123
        console.log(params.get('color')); // red

        return <div>Home</div>;
      };

      export default Home;
      ```
- **내가 이해한 포인트:**
  - URL Parameter는 **리소스 식별용**, Query String은 **검색/필터용**으로 구분
- **실무/프로젝트 적용 아이디어:**
  - 페이지 새로고침 시에도 유지되어야 하는 필터 상태를 Query String으로 관리하면 좋다.
  
---

### 🔹 강의 6: 폰트, 이미지, 레이아웃 설정하기
- **핵심 내용:**
  - **폰트**
    - `public` 폴더에 폰트 파일을 두고 `@font-face`로 등록
  - **이미지**
    - `src > assets` 폴더에 위치시키면 Vite가 자동 최적화(Data URI 캐싱)
	![](https://velog.velcdn.com/images/iamsunwoo/post/e93b295c-31b1-450c-ae65-1ad66a7eff63/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/b80b1d29-87bc-4839-a960-3de4c5671c2a/image.png)
    - 대규모 이미지(10만 개 이상)는 `public`에 저장 권장(메모리 절약)
  - **빌드**
    - `npm run build` → `dist/assets` 내부에 모든 리소스 번들링
    - `npm run preview` → 실제 배포 형태 확인 가능
- **코드 예제:**
  - **폰트 설정**
    ```css
    @font-face {
      /* font-family property는 내가 원하는대로 작성하면 된다. */
      font-family: 'NanumPenScript';
      /* "/": public 폴더를 가리킨다. */
      src: url('/NanumPenScript-Regular.ttf');
    }

    body * {
      font-family: 'NanumPenScript';
    }
    ```
  - **이미지 불러오기(1)**
    ```js
    import emotion1 from './assets/emotion1.png';
    import emotion2 from './assets/emotion1.png';
    import emotion3 from './assets/emotion1.png';
    import emotion4 from './assets/emotion1.png';

    <img src={emotion1} />
    ```
  - **이미지 불러오기(2)**
    ```js
    <img src={"/emotion1.png"}
    ```
  - **이미지 불러오기(3)**
    ```js
    import emotion1 from '../assets/emotion1.png';
    import emotion2 from '../assets/emotion2.png';
    import emotion3 from '../assets/emotion3.png';
    import emotion4 from '../assets/emotion4.png';
    import emotion5 from '../assets/emotion5.png';

    export default function getEmotionImage(emotionId) {
      switch (emotionId) {
        case 1:
          return emotion1;
        case 2:
          return emotion2;
        case 3:
          return emotion3;
        case 4:
          return emotion4;
        case 5:
          return emotion5;
        default:
          return null;
      }
    }
    ```
- **내가 이해한 포인트:**
  - 이미지 경로 구조는 최적화 여부 기준으로 구분된다.
  - Vite의 번들러는 자주 쓰이는 리소스를 Data URI로 캐싱 처리한다.
- **실무/프로젝트 적용 아이디어:**
  - favicon, 오픈그래프용 이미지 등은 `public`에 두는 것이 효율적이다.
---

### 🔹 강의 17: 웹 스토리지 이용하기
- **핵심 내용:**
  - **Web Storage**
    - 웹 브라우저에 기본적으로 내장된 간단한 데이터 저장소
    - 별도 설치나 라이브러리 없이 자바스크립트 내장 함수로 접근 가능하다.
    - 쿠키와 달리 서버와 자동으로 통신하지 않으며, **클라이언트 단에서만 데이터 관리** 가능
    - 주요 종류:
      - **localStorage**
        - **도메인(사이트 주소)**별로 데이터가 저장된다.
        - 사용자가 직접 삭제하거나 `removeItem()`를 호출하기 전까지 데이터가 유지된다.
      - **sessionStorage**
        - **브라우저 탭 단위**로 데이터가 유지된다.
        - 탭을 닫으면 데이터가 삭제되지만, 새로고침 시에는 유지된다.
- **코드 예제:**
  ```js
  localStorage.setItem(key, value);
  localStorage.getItem(key);
  ```
- **내가 이해한 포인트:**
  - 로그인 상태나 테마 설정처럼 **간단하고 서버 동기화가 필요 없는 데이터**는 웹 스토지리를 활용할 수 있다.
  - 단, 보안 민감 정보(토큰 등)은 localStorage에 저장하면 안 된다.
  → `httpOnly` 쿠키나 백엔드 세션 관리로 대체해야 한다.
---

### 🔹 강의 18: 배포 준비하기
- **핵심 내용:**
  - 배포 전, 메타데이터, 페이지별 타이틀를 동적으로 변경하는 작업
  - Next.js에서는 `Head` 컴포넌트로 처리 가능하지만, React APP은 DOM에 접근하는 방식으로 구현해야 한다.
- **코드 예제:**
  ```js
    // 페이지별 타이틀 변경
    useEffect(() => {
      const $title = document.getElementsByTagName('title')[0];
      $title.innerText = '새 일기 쓰기';
    }, []);
  ```
- **내가 이해한 포인트:**
  - CSR 환경에서는 페이지 이동 시 브라우저가 자동으로 `<title>`을 변경하지 않기 때문에, 수동으로 변경해야 한다.
- **실무/프로젝트 적용 아이디어:**
  - `react-helmet` 같은 라이브러리를 사용하면 페이지별 메타데이터 관리가 훨씬 깔끔해진다.

---

### 🔹 강의 19: 배포하기
- **핵심 내용:**
  - Vercel을 이용해 React 프로젝트를 손쉽게 배포할 수 있다.
  - CLI 명령어를 통한 기본 배포 과정:
    - `npm i vercel`
    - `vercel login`
    - 가입한 방식 선택
    - `vercel` → 프로젝트 초기 설정
    - 설정 완료 후 자동으로 배포 링크 생성
- **실무/프로젝트 적용 아이디어:**
  - `.env` 파일에 민감한 API 키를 저장하고, Vercel의 Environment Variables 설정을 통해 환경변수를 관리할 수 있다.
  - 배포 후에도 캐시 문제나 404 처리를 위해 `vercel.json`을 활용할 수 있다.
---



