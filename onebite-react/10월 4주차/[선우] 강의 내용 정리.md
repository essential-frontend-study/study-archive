# 🎯 [한 입 크기로 잘라 먹는 리액트] - 섹션 7: 프로젝트1. 카운터 앱
> 수강일: 2025.10.13

---

## 🧩 섹션 개요
- **섹션 목표:** React의 상태 관리 기본 개념을 실습을 통해 익히고, 컴포넌트 간 데이터 흐름을 명확히 이해한다.
- **핵심 학습 포인트:**
  - 상태(state)의 올바른 위치 선정
  - 부모-자식 간 데이터 전달(props)의 방향성과 원칙
  - 이벤트 핸들러를 통한 상태 변경의 안전한 패턴

---

## 📌 강의별 정리

### 🔹 강의 1: 프로젝트 소개 및 준비
- **핵심 내용:**
  ![](https://velog.velcdn.com/images/iamsunwoo/post/c0a2b990-b645-4ad8-b172-4b1f85b2d798/image.png)
  - 카운터 앱 프로젝트의 전반적인 구조와 구현 목표를 소개
  - React의 가장 기본적인 개념인 state 관리와 props 전달을 실제로 구현해보는 것을 목표로 한다.
- **내가 이해한 포인트:**
  - 작은 규모의 프로젝트일수록 컴포넌트 구조와 데이터 흐름을 명확히 설계하는 것이 중요하다.
- **실무/프로젝트 적용 아이디어:**
  - 간단한 기능이라도 상태의 위치를 잘못 설정하면 이후 유지보수 시 불필요한 복잡도가 생길 수 있다.

---

### 🔹 강의 2: UI 구현하기
### 🔹 강의 3: 기능 구현하기
- **핵심 내용:**
  ![](https://velog.velcdn.com/images/iamsunwoo/post/0b3117d5-4875-40f1-80a1-6331a7477bc2/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/c0a2b990-b645-4ad8-b172-4b1f85b2d798/image.png)
  - 컴포넌트 구조가 위와 같을 때, `count` 상태는 어디에 위치해야 할까?
  - **props는 부모 → 자식 방향으로만 전달 가능**하기 때문에, `count` 상태를 `App` 컴포넌트에 두는 것이 적절하다.
  - `App`에서 `count`와 상태 변화 이벤트 핸들러를 자식 컴포넌트(`Viewer`, `Controller`)로 내려주면 데이터 흐름이 명확해진다.
    ![](https://velog.velcdn.com/images/iamsunwoo/post/60064ac5-aff0-4c69-aa45-26569837da5d/image.png)
  - 강의 수강 전에는 `setState` 함수 자체를 `Controller` 컴포넌트에 넘겼지만, 이는 자식이 부모의 상태를 직접 변경하게 되므로 바람직하지 않은 패턴이다.
  - 대신 부모에서 이벤트 핸들러를 생성하고, 이를 props로 전달하여 자식이 요청만 하게 만드는 것이 올바른 구조이다.
  ![](https://velog.velcdn.com/images/iamsunwoo/post/27a0e91f-8d6b-4a05-ad79-be9fdb7fbab4/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/aa3e9f6d-0fab-48ff-9437-7ae1e5c11139/image.png)
  - 이렇게 위에서 아래로 흐르는 구조는 React의 핵심 철학인 **단방향 데이터 흐름**을 구현한 것이다.
  - 데이터 흐름이 단순해지면, 상태 변경의 원인을 추적하기 쉽고 디버깅이 편해진다.
- **코드 예제:**
![](https://velog.velcdn.com/images/iamsunwoo/post/6f97270c-a683-4440-b7d7-2adff27ce791/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/adba6e99-a9dc-41c5-9869-052069ab5beb/image.png)
- **내가 이해한 포인트:**
  - React의 데이터는 항상 한 방향으로 흐른다.
  - 상태를 어디에 둘지 결정하는 것은 설계 단계에서 가장 중요한 판단 중 하나다.
- **실무/프로젝트 적용 아이디어:**
  - 컴포넌트 간 의존 관계가 복잡해질수록 누가 상태를 소유할지를 먼저 명확히 해야 한다.

---

# 🎯 [한 입 크기로 잘라 먹는 리액트] - 섹션 8: 라이프사이클
> 수강일: 2025.10.13

---

## 🧩 섹션 개요
- **섹션 목표:** React 컴포넌트의 생명주기를 이해하고, `useEffect` 훅을 활용해 마운트ㆍ업데이트ㆍ언마운트 시점의 동작을 제어한다.
- **핵심 학습 포인트:**
  - 컴포넌트의 렌더링 흐름과 생명주기(Lifecycle) 이해
  - `useEffect` 훅의 의존성 배열(deps)을 통한 실행 제어
  - 마운트, 업데이트, 언마운트 시점에서의 사이드 이펙트 관리
 
---

## 📌 강의별 정리

### 🔹 강의 1: 라이프사이클이란?
- **핵심 내용:**
  ![](https://velog.velcdn.com/images/iamsunwoo/post/d27bce87-f4c9-4abf-b462-0d9b39c48911/image.png)![](https://velog.velcdn.com/images/iamsunwoo/post/ef50c728-92a3-417b-9b53-5d8a606d884b/image.png)![](https://velog.velcdn.com/images/iamsunwoo/post/f552386c-a5c9-4305-ab68-b3468b0c2131/image.png)![](https://velog.velcdn.com/images/iamsunwoo/post/f6f150d4-4859-4069-a85c-ed224c219285/image.png)![](https://velog.velcdn.com/images/iamsunwoo/post/29e03e76-4b37-4a3b-8027-9b782cd2b936/image.png)![](https://velog.velcdn.com/images/iamsunwoo/post/8e303e4f-6f4d-45b8-96b6-10b5a4520eb1/image.png)
  - React 컴포넌트는 생성(Mount) → 갱신(Update) → 소멸(Unmount)의 주기를 가진다.
  - 이 과정에서 데이터 요청, DOM 접근, 이벤트 등록/해제 등 부수 효과(Side Effect)를 처리해야 할 때가 있다.
  - 이런 시점을 제어하기 위해 `useEffect` 훅이 사용된다.
- **내가 이해한 포인트:**
  - 컴포넌트의 생명주기를 이해하면 렌더링 시점과 부수효과 발생 시점을 명확히 구분할 수 있다.
- **실무/프로젝트 적용 아이디어:**
  - API 호출, 이벤트 리스너 등록/해제, 타이머 관리 등의 로직을 라이프사이클에 맞춰 적절히 배치하면 버그를 줄일 수 있다.

---

### 🔹 강의 2: useEffect 사용하기
- **핵심 내용:**
  - `useEffect`는 리액트 컴포넌트의 **사이드 이펙트(부수효과)**를 제어하는 훅이다.
  - 의존성 배열(deps)을 통해 특정 상태나 props가 변경될 때만 실행할 수 있다.
- **코드 예제:**
 ```js
   useEffect(() => {
    console.log(`count: ${count}, input: ${input}`);
  }, [count, input]); // 의존성 배열(deps)
 ```
 ```js
  const handleButtonClick = (num) => {
    setCount((prev) => prev + num); // react의 상태 업데이트는 비동기로 업데이트
    console.log(count); // 여전히 이전 값이 출력됨
  };
 ```
- **내가 이해한 포인트**:
  - React의 상태 업데이트는 **비동기적**으로 처리되기 때문에 `setCount` 직후 콘솔에 찍히는 값은 이전 상태값이다.
  - `useEffect`를 사용하면 상태가 변경된 이후의 값을 기반으로 안전하게 부수효과를 처리할 수 있다.
- **실무/프로젝트 적용 아이디어:**
  - 입력 값 검증, API 요청, 로깅 등 상태 변화 이후에 처리되어야 할 로직은 `useEffect` 안에 두는 것이 좋다.

---

### 🔹 강의 3: useEffect로 라이프사이클 제어하기
- **핵심 내용:**
  - `useEffect`를 통해 컴포넌트의 마운트, 업데이트, 언마운트 시점을 제어할 수 있다.
- **코드 예제:**
 ```js
// 1. Mount - 의존성 배열을 빈 배열로 넘기면 처음 마운트 시 한 번만 실행
useEffect(() => {
    console.log("Mount");
}, [])
// 2. Update - 의존성 배열이 없으면 모든 렌더링마다 실행
useEffect(() => {
    console.log("Update");
})
// 3. Unmount - 컴포넌트가 언마운트 될 때 실행(clean-up 함수)
useEffect(() => {
    return () => console.log("Unmount")
}, [])
 ```
- **내가 이해한 포인트:**
  - `useEffect`는 전통적인 클래스형 컴포넌트의 `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`를 대체한다.
  - 의존성 배열을 적절히 활용하면 불필요한 렌더링이나 메모리 누수를 방지할 수 있다.
- **실무/프로젝트 적용 아이디어:**
  - 모달 창 닫힘, 타이머 정리, 소켓 연결 해제 등 **언마운트 시점의 정리 로직**은 반드시 `useEffect`의 clean-up 함수에 작성핟나.

---

### 🔹 강의 4: React 개발자 도구 사용하기
- **핵심 내용:**
  ![](https://velog.velcdn.com/images/iamsunwoo/post/3e1d761b-eb80-4a62-940a-11dc2591f0e0/image.png)
  - React Developer Tools를 사용하면 각 컴포넌트의 state, props, 렌더링 여부를 시각적으로 확인할 수 있다.
  - 어떤 컴포넌트가 렌더링되고 있는지, 상태 변화가 어디서 발생했는지 쉽게 추적 가능하다.
- **내가 이해한 포인트:**
  - React DevTools는 디버깅 도구 이상의 학습 도구이다.
  - 렌더링 흐름을 직접 눈으로 확인하면 상태 관리의 개념이 훨씬 명확해진다.
- **실무/프로젝트 적용 아이디어:**
  - 성능 최적화나 불필요한 리렌더링을 찾을 때 DevTools의 "Highlight Updates" 기능을 적극적으로 활용할 수 있다.
  
---

# 🎯 [한 입 크기로 잘라 먹는 리액트] - 섹션 10: useReducer
> 수강일: 2025.10.15

---

## 🧩 섹션 개요
- **섹션 목표:**
  - `useReducer`의 동작 원리를 이해하고, 복잡한 상태 관리 로직을 컴포넌트 외부로 분리하는 방법을 익힌다.
  - `useState`와의 차이점을 비교하며, 프로젝트 규모가 커질 때 어떤 상황에서 `useReducer`가 유용한지 학습한다.
- **핵심 학습 포인트:**
  - `useReducer`는 컴포넌트 내부 상태 관리 로직을 **Reducer 함수**로 분리해 가독성과 유지보수성을 높인다.
  - `dispatch(action)` 패턴으로 명확한 상태 변경 흐름을 만든다.
---

## 📌 강의별 정리

### 🔹 강의 1: useReducer를 소개합니다
- **핵심 내용:**
  - `useReducer`
    - `useState`와 동일하게 컴포넌트 내부에서 state를 관리하지만, 상태 관리 로직을 컴포넌트 외부의 **reducer 함수**로 분리할 수 있다는 점이 다르다.
    - 모든 `useState`는 이론적으로 `useReducer`로 대체할 수 있다.
    - `useReducer`는 **상태 변화 규칙이 명확하거나 액션이 다양한 경우**에 더 적합하다.
    - 상태 관리 로직이 컴포넌트 내부에 많아질수록 UI 렌더링 코드와 섞이게 되는데, 이런 경우 `useReducer`를 사용하면 UI와 상태 로직을 명확히 분리할 수 있다.
    - useReducer는 **상태 관리 코드를 컴포넌트 외부로 분리**할 수 있음
  ![](https://velog.velcdn.com/images/iamsunwoo/post/756de8b8-62b0-4ade-8346-82cfff7b818a/image.png)![](https://velog.velcdn.com/images/iamsunwoo/post/369e0a87-52aa-4af3-a10f-925719179ec7/image.png)
  
  > 즉, `useReducer`는 **컴포넌트의 복잡도를 낮추는 구조적 도구**이다.
  
  - **동작 흐름 요약**
    - `useReducer`는 두 개의 인자를 받는다. → (reducer, initialState)
    - 반환 값은 `[state, dispatch]` 형태
    - `dispatch(action)`이 호출되면 `reducer(state, action)`이 실행되어 새로운 state를 반환한다.
    - `action` 객체에는 일반적으로 `type`(변화 종류)과 `payload`(추가 데이터)가 포함된다.
    
- **코드 예제:**
  ```js
  import { useReducer } from 'react';

  // reducer: 변환기
  // → 상태를 실제로 변화시키는 변환기 역할
  // reducer(현재의 state 값, 요청의 내용이 담긴 액션 객체)
  function reducer(state, action) {
    if (action.type === 'INCREASE' || action.type === 'DECREASE') {
      return state + action.data;
    } else {
      return state;
    }
  }

  const Exam = () => {
    // state: 새로운 state
    // dispatch(발송): 상태 변화가 있어야 한다는 사실을 알리는(발송하는) 함수
    // useReducer(실제로 상태를 변화시킬 함수, 초기값)
    const [state, dispatch] = useReducer(reducer, 0);

    const onClickPlus = () => {
      // 인수: 상태가 어떻게 변화되길 원하는지
      // dispatch(액션 객체)
      dispatch({
        // type: 상태를 어떻게 변화시키길 원하는지 작성
        type: 'INCREASE',
        // data: 얼마나 변화시키길 원하는지 작성
        data: 1,
      });
    };

    const onClickMinus = () => {
      dispatch({
        type: 'DECREASE',
        data: -1,
      });
    };

    return (
      <div>
        <h1>{state}</h1>
        <button onClick={onClickPlus}>+</button>
        <button onClick={onClickMinus}>-</button>
      </div>
    );
  };

  export default Exam;
  ```

- **내가 이해한 포인트:**
  - `useReducer`는 상태 관리 로직을 중앙 집중화하고 명확히 정의하는 패턴이다.
  - 상태 변화가 여러 곳에서 일어나는 컴포넌트에 특히 유용하다.
---

### 🔹 강의 2: 투두리스트 업그레이드
- **핵심 내용:**
  - 기존 `useState` 기반 App 컴포넌트를 `useReducer`로 리팩토링
  - 상태 업데이트 로직(`onCreate`, `onUpdate`, `onDelete`)을 reducer 내부의 `action.type`별 분기로 관리하도록 변경
  - 각 기능이 하나의 액션으로 정의되어 더 명확한 흐름을 갖게 되었다.
  - 상태 변경 로직은 전부 외부 reducer에 있고, App은 **UI와 dispatch 호출만 담당하는 순수 View 역할**로 단순화 되었다.
- **코드 예제:**
  - **useState** 기반의 상태 관리
    ```js
    ...

    function App() {
      const [todos, setTodos] = useState(mockData);
      const idRef = useRef(3);

      const onCreate = (content) => {
        const newTodo = {
          id: idRef.current++,
          isDone: false,
          content,
          date: new Date().getTime(),
        };

        setTodos((prev) => [newTodo, ...prev]);
      };

      const onUpdate = (targetId) => {
        setTodos(
          todos.map((todo) =>
            todo.id === targetId
              ? {
                  ...todo,
                  isDone: !todo.isDone,
                }
              : todo
          )
        );
      };

      const onDelete = (targetId) => {
        setTodos(todos.filter((todo) => todo.id !== targetId));
      };

        ...
    }
    ```
  - **useReducer** 기반의 상태 관리
    ```js
      ...

      function reducer(state, action) {
        switch (action.type) {
          case 'CREATE':
            return [action.data, ...state];
          case 'UPDATE':
            return state.map((todo) =>
              todo.id === action.targetId
                ? {
                    ...todo,
                    isDone: !todo.isDone,
                  }
                : todo
            );
          case 'DELETE':
            return state.filter((todo) => todo.id !== action.targetId);
        }
      }

      function App() {
        const [todos, dispatch] = useReducer(reducer, mockData);
        const idRef = useRef(3);

        const onCreate = (content) => {
          dispatch({
            type: 'CREATE',
            data: {
              id: idRef.current++,
              isDone: false,
              content: content,
              date: new Date().getTime(),
            },
          });
        };

        const onUpdate = (targetId) => {
          dispatch({
            type: 'UPDATE',
            targetId,
          });
        };

        const onDelete = (targetId) => {
          dispatch({
            type: 'DELETE',
            targetId,
          });
        };

          ...
      }
    ```
---

# 🎯 [한 입 크기로 잘라 먹는 리액트] - 섹션 11: 최적화
> 수강일: 2025.10.15

---

## 🧩 섹션 개요
- **섹션 목표:**
  - 리액트 앱의 성능 저하 원인을 이해하고, `useMemo`, `useCallback`, `React.memo`를 활용해 불필요한 렌더링과 연산을 줄이는 방법을 익힌다.
- **핵심 학습 포인트:**
  - 불필요한 리렌더링의 원리
  - useMemo를 활용한 연산 최적화
  - React.memo를 활용한 컴포넌트 렌더링 최적화
  - useCallback을 활용한 함수 재생성 방지
  - 무조건적인 최적화는 금물
  
---

## 📌 강의별 정리

### 🔹 강의 1: 최적화란
- **핵심 내용:**
  - 웹 서비스 최적화란, **성능을 개선하는 모든 행위**를 말한다.
  - 일반적인 웹 성능 개선 방법
    - 서버 응답 속도 개선
    - 정적 리소스(이미지, 폰트, JS, CSS 등) 로딩 최적화
    - 불필요한 네트워크 요청 최소화
  - React App 내부에서의 최적화 포인트
    - 컴포넌트 내부의 불필요한 연산 방지
    - 함수 재생성 방지
    - 불필요한 리렌더링 방지
- **내가 이해한 포인트:**
  - 최적화는 성능을 높이는 게 아니라 낭비를 줄이는 것이다.
  - React App에서는 **렌더링이 낭비되는 순간**을 잡아내는 게 핵심이다.
- **실무/프로젝트 적용 아이디어:**
  - 렌더링이 잦은 대화형 컴포넌트(채팅, 검색, 폼)에 우선 적용
  - 성능 문제를 먼저 체감한 뒤 최적화를 적용하는 습관

---

### 🔹 강의 2: useMemo와 연산 최적화
- **핵심 내용:**
  - `useMemo`는 **값을 메모이제이션(memoization)**하여 불필요한 연산을 방지
  - 의존성 배열(`deps`)이 변하지 않으면 이전 연산 결과를 재사용
  - 단순한 값뿐 아니라, 객체나 배열 계산 결과에도 활용 가능
  - `useMemo`에 인자로 작성한 콜백함수가 반환하는 값을 그대로 반환
  ![](https://velog.velcdn.com/images/iamsunwoo/post/560c4633-49cc-412a-b155-6d9fe6593772/image.png)![](https://velog.velcdn.com/images/iamsunwoo/post/51e86032-c7ef-4868-9db9-a1077b91d924/image.png)![](https://velog.velcdn.com/images/iamsunwoo/post/72bc1eed-e5d6-4551-8d89-2c39bf3bd967/image.png)
  
- **코드 예제:**
  - 렌더링마다 불필요한 연산을 하는 코드
    ```js
    const List = ({ todos, onUpdate, onDelete }) => {
      const [input, setInput] = useState('');

      const getAnalyzedData = () => {
        const totalCount = todos.length;
        const doneCount = todos.filter((todo) => todo.isDone).length;
        const notDoneCount = totalCount - doneCount;

        return {
          totalCount,
          doneCount,
          notDoneCount,
        };
      };

      const { totalCount, doneCount, notDoneCount } = getAnalyzedData();
    ```
  - `deps` 값이 변할때만 연산을 하는 코드
    ```js
      // useMemo(콜백함수, deps)
      // 해당 콜백함수가 반환하는 값을 그대로 반환
      const { totalCount, doneCount, notDoneCount } = useMemo(() => {
        const totalCount = todos.length;
        const doneCount = todos.filter((todo) => todo.isDone).length;
        const notDoneCount = totalCount - doneCount;

        return {
          totalCount,
          doneCount,
          notDoneCount,
        };
      }, [todos]);
    ```
- **내가 이해한 포인트:**
  - 매 렌더링마다 새로 계산할 필요가 없는 값은 `useMemo`로 묶어두면 된다.
  - 특히 `filter`, `map`, `reduce` 같이 연산량이 많은 계산에서 효과적이다.
- **실무/프로젝트 적용 아이디어:**
  - Todo, 게시글 목록 등에서 통계 계산 시 `useMemo`로 성능 개선
  - 너무 남용하면 오히려 코드 복잡도와 메모리 사용량 증가
---

### 🔹 강의 3: React.memo와 컴포넌트 렌더링 최적화
- **핵심 내용:**
  - `React.memo`는 **컴포넌트를 메모이제이션**하여, 부모 컴포넌트가 리렌더링 되어도 전달 받는 props가 변경되지 않으면 리렌더링을 방지
  - 내부적으로 `prevProps`와 `nextProps`를 얕은 비교(`===`)로 판단
  - 고차 컴포넌트(HOC, Higher Order Component)의 한 형태
    - 컴포넌트를 인수로 받아 해당 컴포넌트를 최적화 또는 메모이제이션 등의 기능이 추가된 컴포넌트를 반환하는 함수를 고차 컴포넌트라고 한다.
  - 필요 시 커스텀 비교 함수로 최적화 조건을 세밀하게 제어 가능
    ![](https://velog.velcdn.com/images/iamsunwoo/post/2944b368-5c28-4f18-bc33-a932c475e396/image.png)
  - `Header` 컴포넌트 `memo` 적용 전
  <img src="https://velog.velcdn.com/images/iamsunwoo/post/c3b38861-a711-40d6-940e-409bfed0eb28/image.gif"/>
  
  - `Header` 컴포넌트 `memo` 적용 후
  <img src="https://velog.velcdn.com/images/iamsunwoo/post/20c56bca-6d93-42e1-b9a6-e4ce9aec13ff/image.gif" />
  
- **코드 예제:**
  - 일반적인 memo 사용법
    ```js
    import { memo } from 'react';
    import './Header.css';

    const Header = () => {
      return (
        <div className='Header'>
          <h3>오늘은 🗓️</h3>
          <h1>{new Date().toDateString()}</h1>
        </div>
      );
    };

    export default memo(Header);
    ```
  - memo의 두 번째 인자로 콜백 함수 전달
    - `memo`를 적용해도 props로 **함수를 전달받는 경우**, 부모 컴포넌트가 리렌더링되면 자식 컴포넌트도 함께 리렌더링 됨
    - 따라서, 이런 경우 `memo`의 두 번째 인자로 콜백 함수를 작성하여 props 비교를 콜백 함수의 반환 값으로 판단
 
      ```js
      // 부모 컴포넌트가 리렌더링 할 때마다 전달받은 Props가 변경되었는지 스스로 판단하는 게 아니라 콜백 함수로 판단
      export default memo(TodoItem, (prevProps, nextProps) => {
        // True → Props 바뀌지 않음 → 리렌더링 X
        // False → Props 바뀜 → 리렌더링 O

        if (prevProps.id !== nextProps.id) return false;
        if (prevProps.isDone !== nextProps.isDone) return false;
        if (prevProps.content !== nextProps.content) return false;
        if (prevProps.date !== nextProps.date) return false;

        return true;
      });
      ```
- **내가 이해한 포인트:**
  - `React.memo`는 props가 변하지 않으면 굳이 다시 그리지 말자는 개념
  - 다만, props로 함수를 전달받는 경우는 주의해야 함
  - [참고하면 좋을 사이트](https://patterns-dev-kr.github.io/design-patterns/hoc-pattern/)
- **실무/프로젝트 적용 아이디어:**
  - 자주 렌더링되는 리스트형 UI에 적합
  - 정적 UI(`Header`, `Sidebar`)는 한 번 memoize 해두면 불필요한 렌더링 방지 가능
  - 복잡한 비교 로직이 필요한 경우 `React.memo(Component, areEquals)` 형태로 커스텀
---

### 🔹 강의 4: useCallback과 함수 재생성 방지
- **핵심 내용:**
  - `useCallback`은 함수를 메모이제이션하여 **렌더링마다 새로 생성되는 함수 참조 문제**를 방지
  - `React.memo`와 함께 쓰면 가장 큰 시너지를 발휘
  - 의존성 배열을 기준으로 함수를 재사용 → 불필요한 렌더링 감소
- **내가 이해한 포인트:**
  - 함수형 컴포넌트는 렌더링 될 때마다 내부 함수가 다시 생성된다.
  - 이 때, `useCallback`을 사용하면 **함수의 주소값이 고정**되어 함수를 재생성하지 않는다.
  - [참고하면 좋을 사이트](https://goongoguma.github.io/2021/04/26/When-to-useMemo-and-useCallback/) 
- **실무/프로젝트 적용 아이디어:**
  - 이벤트 핸들러(onClick, onChange 등)를 자식 컴포넌트에 넘길 때 반드시 `useCallback`으로 감싸기
  -  최적화는 기능 완성 후, 필요한 곳에만 적용하는 게 원칙
---

# 🎯 [한 입 크기로 잘라 먹는 리액트] - 섹션 12: Context
> 수강일: 2025.10.16

---

## 🧩 섹션 개요
- **섹션 목표:**
  - React의 `Context API` 개념을 이해하고, `Props Drilling` 문제를 해결하는 방법을 배운다.
  - Context를 분리하여 불필요한 리렌더링을 줄이는 최적화 방법을 익힌다.
- **핵심 학습 포인트:**
  - `createContext`, `Provider`, `useContext`의 동작 원리
  - Context로 인한 렌더링 이슈와 해결 전략
    - `Context 분리`
---

## 📌 강의별 정리

### 🔹 강의 1: Context란
- **핵심 내용:**
  - **Props Drilling**
    ![](https://velog.velcdn.com/images/iamsunwoo/post/5238d0ed-5ccc-4b4b-a8cd-dc08a989f3e5/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/b9c652c0-02fc-41d0-81f4-79199a26a7d1/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/de28b8a1-830c-4824-9fcb-46678ac693fd/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/5ec25fca-e9b7-4ff9-b504-63f1159438a8/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/a5bdef0d-73e3-4b27-911d-3a23a3618652/image.png) 
  - **React Context**
     - 컴포넌트 간 데이터를 전달하는 또 다른 방법
     - 기존의 `props` 방식이 가진 단점을 해결할 수 있다.
       - 특히 **Props Drilling** 문제 해결
     - 상위 → 하위로 여러 단계를 거치지 않고, 필요한 컴포넌트에서 직접 데이터 접근 가능
     - Context를 사용하면 코드 구조가 훨씬 단순해지고 유지보수가 쉬워진다.
     
   ![](https://velog.velcdn.com/images/iamsunwoo/post/814cfc4a-5321-4fc7-a0bb-59820b5ffdf5/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/ead68276-a7e9-434e-8cc0-93a8cc2ee13c/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/b49f44cc-1af9-4385-8e2b-d871e2e056b5/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/db2728db-dad2-4496-8a79-f8fe50517904/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/316fea46-43d9-4130-8bf9-6e39b5572fa4/image.png)
- **내가 이해한 포인트:**
  - Context는 전역 상태를 쉽게 공유할 수 있는 수단이지만, 무분별하게 사용하면 오히려 렌더링 성능이 떨어질 수 있다.
  - 단순한 props 전달 구조에서는 Context가 오히려 복잡도를 높일 수 있으므로 **필요한 경우에만** 도입하는 것이 좋다.
- **실무/프로젝트 적용 아이디어:**
  - 로그인 정보, 테마 등 **여러 컴포넌트에서 공통으로 사용하는 전역 상태 관리에 적합**하다.
---

### 🔹 강의 2: Context 사용하기
- **핵심 내용:**
  - Context API를 활용하여 기존 프로젝트 내 `Props Drilling` 이슈 해결
  - `createContext`
    - Context 객체를 생성, 객체 안에는 여러 프로퍼티가 있는데 `Provider`를 주로 사용한다.
    - **컴포넌트 외부에 선언**해야 렌더링마다 객체가 재생성되지 않는다.
  - `Provider`
    - Context가 공급할 데이터를 지정하고, 해당 데이터를 사용할 컴포넌트를 감싼다.
    - Provider로 감싸면 자식 컴포넌트 어디에서든 `useContext()`로 접근 가능하다.
    
    ![](https://velog.velcdn.com/images/iamsunwoo/post/6581506d-f0ff-47c8-b8ff-30bd15a04a72/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/97f50a21-2f79-450a-a928-feebe60b4174/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/ed5f96a4-b927-42c0-b234-cf9f670a29ed/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/3196ce67-3acb-4abb-bb8d-bc6b0b08f1cc/image.png)
    
- **코드 예제:**
  ```js
  import { useState, createContext } from 'react';
  import List from './components/List';

  ...

  const TodoContext = createContext();

  ...

  function App() {
      const [state, setState] = useState('');
      ...
      return (
          <TodoContext.Provider value={state}>
              <List />
          </TodoContext.Provider>
      )
  }
  ```
- **내가 이해한 포인트:**
  - `Provider` 내부의 모든 자식은 Context 변경 시 리렌더링된다.
  - 따라서, Context 사용 범위는 필요한 최소 단위로 좁혀햐 한다.

---

### 🔹 강의 3: Context 분리하기
- **핵심 내용:**
  - `TodoItem`에 적용해둔 최적화(`React.memo`)가 풀린 이유
    - `Provider`도 컴포넌트이기 때문에, `App`이 리렌더링되면 Context에 전달된 값도 변경된다.
    - 그 결과, Context를 구독하는 모든 컴포넌트(`TodoItem` 포함)가 다시 렌더링 된다.
  - 이를 해결하기 위해 **Context를 역할에 따라 분리**해야 한다.
    - 값이 자주 바뀌는 데이터(`state`)
    - 거의 변하지 않는 핸들러(`dispatch`)
    - 각각 다른 Context로 관리

    ![](https://velog.velcdn.com/images/iamsunwoo/post/1552253c-b819-4084-80b9-9d373904c250/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/f6c8ff27-50fc-434d-9776-531edb626dab/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/4ab9ba5d-59e5-4796-955c-84fa29e06edf/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/f149db9e-5a5d-4c8b-93a8-b1cc5d93203b/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/d6db5eb1-a50b-429f-9522-03154baa494e/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/0830e16c-61be-42b3-8ea1-c8324db5e4b1/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/98877d2d-3c00-44c9-afc6-7b707ee2ab8a/image.png)![](https://velog.velcdn.com/images/iamsunwoo/post/d34f14e3-b7ae-416c-80dc-c0dbd899bbf8/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/212c430a-ba95-4e62-9a34-5a76562606f3/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/eab3021d-800f-4ae1-9e46-04425520665e/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/576e7d64-968d-46f8-8932-6f05edee1552/image.png)

- **코드 예제:**
  ```js
  import { createContext, useCallback, useMemo, useReducer} from 'react';
  import Editor from './components/Editor';
  import List from './components/List';
  
  ...
  
  // createContext: 컴포넌트 내부에 선언 시 렌더링 시 매번 재생성 되기 때문에 컴포넌트 외부에 선언
  // export const TodoContext = createContext();
  export const TodoStateContext = createContext();
  export const TodoDispatchContext = createContext();
  
  function App() {
    const [todos, dispatch] = useReducer(reducer, mockData);
  
    const onCreate = useCallback((content) => {
      dispatch(...);
    }, []);
  
    const onUpdate = useCallback((targetId) => {
      dispatch(...);
    }, []);
  
    const onDelete = useCallback((targetId) => {
      dispatch(...);
    }, []);
  
    // Context의 Provider 값으로 객체 자체를 남길 때는 App 컴포넌트가 리렌더링 될 때 새로운 주소값을 넘기게 됨
    // 따라서, { onCreate, onUpdate, onDelete } 객체가 다시 생성되지 않도록 useMemo를 활용
    const memoizedDispatch = useMemo(() => {
      return { onCreate, onUpdate, onDelete };
    }, []);
  
    return (
  
    ...
  
  {/* <TodoContext.Provider
        value={{
          todos,
          onCreate,
          onUpdate,
          onDelete,
        }}
      >
        <Editor />
        <List />
      </TodoContext.Provider> */}
      <TodoStateContext.Provider value={todos}>
        <TodoDispatchContext.Provider value={memoizedDispatch}>
          <Editor />
          <List />
        </TodoDispatchContext.Provider>
      </TodoStateContext.Provider>
  
    ...
  
    );
  }
  ```

- **내가 이해한 포인트:**
  - Context 값이 객체 형태일 경우, 객체가 새로 생성되면 하위 컴포넌트도 리렌더링된다.
  - `useMemo`를 사용해 불필요한 객체 재생성을 막을 수 있다.
  - `StateContext`와 `DispatchContext`를 분리하면 렌더링 최소화에 효과적이다.
- **실무/프로젝트 적용 아이디어:**
  - 대규모 앱에서 전역 상태를 Context로 관리할 경우, 데이터 성격에 따라 Context를 세분화하면 성능을 크게 개선할 수 있다.

---
