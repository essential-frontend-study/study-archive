# 🎯 핵심 개념
### Context :  컴포넌트 트리 전체에 데이터 제공할수있는  React의 기능. 


# 📌 기존의 문제점
### Prop Drilling
![[Pasted image 20251018182437.png]]
props는 부모 -> 자식으로만 데이터 전달이 가능하다. 하지만 만약에 deps가 더 깊어진다한다면, 더 깊은 deps의 컴포넌트는 부모의 상태값을 알수없게 된다. 부모의 상태를 알려면 그 부모의 자식의 자식의 자식을 통해서 상태를 전달해줘야한다. 마치 끝없이 드릴처럼 뚫고 내려간다는 의미로서 props drilling이라고 한다.

그래서 대안으로 나온것이  *Context* 이다.
Context는 부모 컴포넌트가 그 아래의 트리 전체에 데이터를 전달할 수 있도록 도와준다.

그럼 context의 사용법을 알아보자.

# 🛠️ Context 사용 방법 (3단계)

### 1단계: Context 생성하기
```javascript
import { createContext } from 'react';

//  컴포넌트 내부에 선언시,리렌더링 될때마다 생성되므로 컴포넌트 외부에 작성.
export const TodoContext = createContext(); // 기본값

export default function App(){
	const [todos, dispatch] = useReducer(reducer, mockData);
	const idRef = useRef(3);

  const onCreate = useCallback((content) => {
   ...
  }, []);

  const onUpdate = useCallback((targetId) => {
    ...
  }, []);

  const onDelete = useCallback((targetId) => {
    ...
  }, []);

  return (
    <div className="App">
      <Header />
        <Editor />
        <List />
    </div>
  );
}
```

2단계: Context 제공
```javascript
import { createContext } from 'react';

//  컴포넌트 내부에 선언시,리렌더링 될때마다 생성되므로 컴포넌트 외부에 작성.
export const TodoContext = createContext(); // 기본값

export default function App(){
	const [todos, dispatch] = useReducer(reducer, mockData);
	const idRef = useRef(3);

  const onCreate = useCallback((content) => {
   ...
  }, []);

  const onUpdate = useCallback((targetId) => {
    ...
  }, []);

  const onDelete = useCallback((targetId) => {
    ...
  }, []);

  return (
    <div className="App">
      <Header />
      // context.Provider(공급자)를 감싸면 Editor,List 컴포넌트는 TodoContext가 제          공하는 값을 공급 받을수 있다.
   <TodoContext.Provider
        value={{
          todos,
          onCreate,
          onUpdate,
          onDelete,
        }}
      >
        <Editor />
        <List />
      </TodoContext.Provider>
    </div>
  );
}
```

위 내용을 사진으로 표현하자면 이렇다.

![[Pasted image 20251018185019.png]]

`TodoContext` 객체가 제공한 `TodoContext.Provider`이라는 공급자를 App 컴포넌트 대신 부모 컴포넌트설정한 상태이다. 이러면 `TodoContext.Provider`  가 포함한 모든 컴포넌트는 다이렉트로 데이터를 제공받을수 있다.

개발자도구의 컴포넌트 탭에서 보면 
![[Pasted image 20251018185719.png]]

Context.Provider가 계층구조에 추가된것을 확인할수있고, value로서 공급한 함수들이 보인다.

3단계: Context 데이터 읽기

>💡 useContext는 Hook이므로 컴포넌트 최상단에서만 사용

```javascript
// useContext 호출
import { useRef, useState, useContext } from "react";
...

// 
import { TodoContext } from "../App";

const Editor = () => {
  // TodoContext를 인수로 넣고 onCreate 함수 호출
  const { onCreate } = useContext(TodoContext);
  const [content, setContent] = useState("");
  const inputRef = useRef();

  const onChangeContent = (e) => {
    setContent(e.target.value);
  };

  const onKeydown = (e) => {
    if (e.keyCode === 13) {
      onSubmit();
    }
  };

  const onSubmit = () => {
    if (content === "") {
      inputRef.current.focus();
      return;
    }
    onCreate(content);
    setContent("");
  };

  return (
    <div className="Editor">
      <input
        ref={inputRef}
        value={content}
        onChange={onChangeContent}
        onKeyDown={onKeydown}
        placeholder="새로운 Todo..."
      />
      <button onClick={onSubmit}>추가</button>
    </div>
  );
};

export default Editor;
```

# 📌 Context 분리하기

기존의 코드에서 `TodoItem`에 React.memo를 사용해서 todo props가 변경되지않으면 리렌더링이 되지않도록 최적화를 진행했었다. 하지만 Context를 사용함에 따라 최적화가 풀린것을 알수있다. 

왜그럴까?

그 이유는  `TodoContext` value props 안의  todo props가 직접적으로 변경되지않아도 `onDelete`나 `onCreate`, `onUpdate` 가 변경 될 경우, `TodoContext` 객체 자체가 재생성되기 때문이다.

그럼 어떻게해야할까? 

![[Pasted image 20251018191941.png]]

이렇게 변경될수있는 값과 변경되지않는 값을 구분하여 Context를 생성하여 각각 감싸주면된다.

```javascript
import "./App.css";
import {
  ...
  createContext,
  useMemo,
} from "react";

...

export const TodoStateContext = createContext();
export const TodoDispatchContext = createContext();

function App() {
  const [todos, dispatch] = useReducer(reducer, mockData);
  const idRef = useRef(3);
  
  ...

  const memoizedDispatch = useMemo(() => {
    // useMemo를 사용해서 마운트 되면 한번만 실행하게끔 작성
    return { onCreate, onUpdate, onDelete };
  }, []);

  return (
    <div className="App">
      <Header />
      <TodoStateContext.Provider value={todos}>
        <TodoDispatchContext.Provider value={memoizedDispatch}>
          <Editor />
          <List />
        </TodoDispatchContext.Provider>
      </TodoStateContext.Provider>
    </div>
  );
}

export default App;
```

# 👍Context가 적합한 경우 (전역적으로 데이터를 공유해야할때 )

- ✅ 테마 (다크모드 등)

- ✅ 현재 로그인한 사용자

- ✅ 라우팅 정보

- ✅ 전역 상태 관리

# 🎓 기억할 점

1. Context는 전역 데이터용이지, 모든 props 대체 수단이 아니다.

2. Provider의 value가 바뀌면 하위 컴포넌트들이 자동으로 리렌더링됩니다 (= Context.Provider 객체가 재생성되기 때문)

3. 여러 Context를 동시에 사용할 수 있습니다 (서로 독립적)


# ⚠️ Context와 useReducer의 차이

>React의 Context와 useReducer는 서로 다른 목적을 가진 기능

## 핵심 차이점

| 특징  | Context      | useReducer   |
| --- | ------------ | ------------ |
| 목적  | 상태를 전역적으로 공유 | 복잡한 상태 로직 관리 |
| 역할  | "데이터 전달 방식"  | "상태 업데이트 로직" |
| 비유  | 택배 배송 시스템    | 창고 관리 시스템    |

예시 1 )

```javascript
// ❌ Context 없이 - prop drilling
function App() {
    const [user, setUser] = useState(null);
    
    return (
      <div>
        <Header user={user} />  {/* user 전달 */}
        <Main user={user} />     {/* user 전달 */}
        <Footer user={user} />   {/* user 전달 */}
      </div>
    );
  }
  
  // ✅ Context 사용 - 직접 접근
  const UserContext = createContext();
  
  function App() {
    const [user, setUser] = useState(null);
    
    return (
      <UserContext.Provider value={user}>
        <Header />  {/* user를 prop으로 받지 않음 */}
        <Main />    {/* user를 prop으로 받지 않음 */}
        <Footer />  {/* user를 prop으로 받지 않음 */}
      </UserContext.Provider>
    );
  }
  
  function Header() {
    const user = useContext(UserContext); // 직접 접근!
    return <div>{user.name}</div>;
  }
```

예시 2 )

```javascript
// ❌ useState로 복잡한 로직 관리 (복잡함)
function TodoApp() {
  const [todos, setTodos] = useState([]);
  const [filter, setFilter] = useState("all");

  const addTodo = (text) => {
    setTodos([...todos, { id: Date.now(), text, done: false }]);
  };

  const toggleTodo = (id) => {
    setTodos(
      todos.map((todo) =>
        todo.id === id ? { ...todo, done: !todo.done } : todo
      )
    );
  };

  const deleteTodo = (id) => {
    setTodos(todos.filter((todo) => todo.id !== id));
  };

  // ... 더 많은 함수들
}

// ✅ useReducer로 관리 (깔끔함)
const initialState = { todos: [], filter: "all" };

function todoReducer(state, action) {
  switch (action.type) {
    case "ADD_TODO":
      return {
        ...state,
        todos: [
          ...state.todos,
          {
            id: Date.now(),
            text: action.text,
            done: false,
          },
        ],
      };
    case "TOGGLE_TODO":
      return {
        ...state,
        todos: state.todos.map((todo) =>
          todo.id === action.id ? { ...todo, done: !todo.done } : todo
        ),
      };
    case "DELETE_TODO":
      return {
        ...state,
        todos: state.todos.filter((todo) => todo.id !== action.id),
      };
    default:
      return state;
  }
}

function TodoApp() {
  const [state, dispatch] = useReducer(todoReducer, initialState);

  return (
    <div>
      <button onClick={() => dispatch({ type: "ADD_TODO", text: "새 할일" })}>
        추가
      </button>
      {/* ... */}
    </div>
  );
}

```

예시 3) 함께 사용하기 

Context와 useReducer를 함께 사용하면 전역 상태 관리 시스템을 만들 수 있습니다.

```javascript
// 1. Reducer 정의
function themeReducer(state, action) {
  switch (action.type) {
    case "TOGGLE_THEME":
      return { ...state, theme: state.theme === "light" ? "dark" : "light" };
    case "SET_LANGUAGE":
      return { ...state, language: action.language };
    default:
      return state;
  }
}

// 2. Context 생성
const ThemeContext = createContext();

// 3. Provider 컴포넌트
function ThemeProvider({ children }) {
  const [state, dispatch] = useReducer(themeReducer, {
    theme: "light",
    language: "ko",
  });

  return (
    <ThemeContext.Provider value={{ state, dispatch }}>
      {children}
    </ThemeContext.Provider>
  );
}

// 4. 사용
function App() {
  return (
    <ThemeProvider>
      <Header />
      <Main />
    </ThemeProvider>
  );
}

function Header() {
  const { state, dispatch } = useContext(ThemeContext);

  return (
    <div>
      <p>현재 테마: {state.theme}</p>
      <button onClick={() => dispatch({ type: "TOGGLE_THEME" })}>
        테마 변경
      </button>
    </div>
  );
}

```


