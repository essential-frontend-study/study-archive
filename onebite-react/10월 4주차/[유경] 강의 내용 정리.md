# Section08 라이프사이클

## 7.1 라이프사이클이란?

라이프사이클(LifeCycle) = 생애 주기

Mount → Update → UnMount

1. Mount
- 컴포넌트가 탄생하는 순간
- 화면에 처음 렌더링 되는 순간
- A 컴포넌트가 Mount 되었다 → A 컴포넌트가 화면에 처음으로 렌더링 되었다.

2. Update
- 마운트 이후 컴포넌트가 다시 렌더링 되는 순간
- 리렌더링 될 때
- A 컴포넌트가 업데이트 되었다 → A 컴포넌트가 리렌더링 되었다

3. UnMount
- 컴포넌트가 화면에서 사라지는 순간
- 렌더링에서 제외 되는 순간을 의미
- A 컴포넌트가 언마운트 되었다 → A 컴포넌트가 화면에서 사라졌다

라이프 사이클 제어

- 컴포넌으의 라이프사이클의 단게별로 우리 컴포넌트들이 각각 다른 작업을 수행하도록 만드는 것
- useEffect로 구현

## 7.2 useEffect 사용하기

useEffect

- 리액트 컴포넌트의 사이드 이펙트를 제어하는 새로운 React Hook
- side effect: 부작용, 부수적인 효과, 파생되는 효과
- React 컴포넌트의 사이드 이펙트: 컴포넌트의 동작에 따라 파생되는 여러 효과
- useEffect로 사이드 이펙트를 새롭게 만들거나 제어할 수 있음
    - 컴포넌트의 어떤 값이 변경되었을 때 특정 코드를 실행시키거나 라이브 사이클을 제어

- 첫 번째 인수 `{}`: 콜백함수
- 두 번째 인수 `[]` : 의존성 배열(deps; dependency array), 값 여러 개 가능
- 배열의 값이 바뀌게 되면 sideEffect로서 첫 번째 인수의 콜백함수를 실행

```sql
useEffect(()=>{}, [])
```

- 컴포넌트 내에서 원하는 값이 바뀌었을 때만 특정 동작을 callback 함수로 실행하도록 만들 수 있음

```sql
const [count, setCount] = useState(0);
const [input, setInput] = useState("");

useEffect(() => {
	console.log(`count: ${count} / input: ${input}`);
}, [count, input]);
```

그냥 이벤트 핸들러만 쓰면? → X

- 상태 변화 함수가 비동기로 동작(함수 결과가 나중에 나옴)

```sql
const onClickButton = (value) => {
	setCount(count+value); // 호출만 지금되고, 비동기로 업데이트 -> sideEffect 사용을 위해서는 useEffect 사용 필요
	console.log(count); // 변경되지 전의 값이 출력 된다
};
```

## 7.3) useEffect로 라이프사이클 제어하기

모든 리액트 컴포넌트는 Mount → Update → UnMount의 라이프사이클을 가진다 → useEffect로 제어 가능

1. Mount

```sql
useEffect(() => {
	console.log("mount");
}, []);
```

2. Update

```sql
// 2. Update
useEffect(() => {
	console.log("update"); // mount, update 시점에 출력
});

// 2-1. Update (without mount)
const isMount = useRef(false); // flag

useEffect(() => {
	if (!isMount.current){
		isMount.current = true;
		return;
	}
	console.log("update"); // update 시점에만 출력
})
```

3. UnMount

```sql
// Even.jsx
import {useEffect} from "react";

const Even = () => {
	useEffect(() => {
		// useEffect가 반환하는 함수: 클린업, 정리함수 -> useEffect가 끝날 때 실행
		return () => {
				console.log("unmount")
			};	
	}, []);
	return <div>짝수입니다</div>
}

export default Even;
```

```sql
// App.jsx
import from './components/Even';

...
	return (
		...
		{count % 2 === 0? <Even/> : null}
		...
```

## 7.4) React 개발자 도구 사용하기

크롬에 설치해서 사용할 수 있는 무료 확장 프로그램

개발자도구 → Components*

state, props, Ref 등 확인 가능

Highlight updatees when components render → 불필요한 리렌더링 발생하는 컴포넌트 확인 가능

# section10 useReduver

## 9.1 useReducer를 소개합니다

useReducer

- 컴포넌트 내부에 새로운 State를 생성하는 React Hook
- 모든 useState는 useReducer로 대체 가능
- 상태 관리 코드를 컴포넌트 외부로 분리할 수 있음
- 컴포넌트 내부에서는 state 생성만 해놓고, 실제 state 관리 코드들은 Reducer 함수를 통해 컴포넌트 외부에서 관리

React 컴포넌트의 가장 주된 역할: UI를 렌더링하는 것

- state 관리 코드가 많아지는 것은 좋지 않음
- 파일을 열었을 때 해당 컴포넌트가 렌더링하는 UI 요소가 무엇인지 한 눈에 파악하기가 힘듦 → 가독성, 유지보수 불리
- 컴포넌트 외부에 상태 관리 코드를 분리 → useReducer (React Hook)

```sql
// Exam.jsx

import { useReducer } from "react";

// reducer: 변환기 -> 상태를 변화시키는 변환기 역할
function reducer(state, action){{
	console.log(state, action);
	
	/*
	if (action.type === "INCREASE"){
		return state+action.data;
	}
	
	else if (action.type === "INCREASE"){
		return state-action.data;
	}
	*/
	
	switch(action.type){
		case: "INCREASE":
			return state+action.data;
		case "DECREASE":
			return state-action.data;
		default:
			return state;
}

const Exam = () => {
	// dispatch: 발송하다, 급송하다
	// -> 상태 변화가 있어야 한다는 사실을 알리는, 발송하는 함수
	const [state, dispatch] = useReducer(reducer, 0);
	
	const onClickPlus = () => {
		// 인수: 상태가 어떻게 변화되길 원하는지 -> 액션 객체
		dispatch({
			type: "INCREASE",
			data: 1,
		})
	}

	const onClickPlus = () => {
		dispatch({
			type: "DECREASE",
			data: 1,
		});
	};

	return {
		<div>
			<h1>{state}</h1>
			<button onClick = {onClickPlus}>+</button>
			<button onClick = {onclickMinus}>+</button>

		</div>	
		
	}
};

export default Exam;
```

```sql
// App.jsx
...
	return (
	<>
		<Exam />
	</>
```

## 9.2) 투두리스트 업그레이드

// TODO: 투두리스트 실습 후 리듀서 쓰는 것 까지 직접 해보기

# Section11 최적화

## 10.1) 최적화란

최적화(Optimization)

- 웹 서비스의 성능을 개선하는 모든 행위를 일컫음
- 아주 단순한 것 부터 아주 어려운 방법까지 매우 다양함

일반적인 웹 서비스 최적화 방법

- 서버의 응답속도 개선
- 이미지, 폰트, 코드 파일 등의 정적 파일 로딩 개선
- 불필요한 네트워크 요청 줄임

React App 내부의 최적화 방법

- 컴포넌트 낸부의 불필요한 연산, 함수 재생성, 리렌더링 방지

## 10.2) useMemo와 연산 최적화

useMemo

- 메모이제이션 기법을 기반으로 불필요한 연산을 최적화하는 리액트 훅
- 프로그래밍에서 동일한 연산을 반복적으로 수행 → 연산 낭비
→ 최초로 한 번 계산했을 때의 결과값을 메모리에 보관한 후 나중에 돌려줌

useMemo는 첫 번째 인수로 전달한 콜백함수가 반환하는 값을 그대로 반환 → 처음 렌더링 될 때만 연산

두 번째 인수를 기준으로 메모이제이션

```jsx
// TODO list

import { useMemo } from "react";

/*
const getAnalyzedData = () => {
	const totalCount = todos.length;
	const doneCount = todos.filter(
		(todo) => todo.isDone
	).length;
	const notDonecount = totalCount - doneCount;
	
	return {
		totalCount;
		doneCount,
		notDoneCount
	};
};

// 구조 분해 할당
const { totalCount, doneCount, notDoneCount } = getAnalyzedCount();
*/

const { totalCount, doneCount, notDoneCount } = 
	useMemo(() => {
		const totalCount = todos.length;
		const doneCount = todos.filter(
			(todo) => todo.isDone
		).length;
		const notDonecount = totalCount - doneCount;
		
		return {
			totalCount;
			doneCount,
			notDoneCount
		};
	}, [todos]);
	
return (
	<div>
		<div>total: {totalCount}</div>
		<div>done: {doneCount}</div>
		<div>notDone: {notDoneCount}</div>
	</div>
};
```

## 10.3) React.memo와 컴포넌트 렌더링 최적화

React.memo

- 컴포넌트를 인수로 받아, 최적화된 컴포넌트로 만들어 반환
- MemoizedComponent는 부모 컴포넌트가 리렌더링 되더라도 props가 바뀌지 않으면 리렌더링 되지 않도록 메모이제이션 → 불필요한 리렌더링 방지 → 최적화 가능

```jsx
// Header.jsx
import { memo } from "react";

const Header = () => {
	...
};

/*
const memoizeHeader = memo(Header);

export default memoizeHeader;
*/

export default memo(Header);
```

```jsx
// TodoItem.jsx
import { memo } from "react";

...

// 메모이제이션 같은 ㅊ가적인 기능을 덧붙여서 기능이 추가된 새로운 컴포넌트 반환 -> 고차 컴포넌트(HOC: Higher Order Component)
export default memo(TodoItem, (prevProps, nextProps) => {
	// 반환 값에 따라 props가 바뀌었는지 판단
	// T -> props가 바뀌지 않음 -> 리렌더링 X
	// F -> props가 바뀜 -> 리렌더링 O
	
	if (prevProps.id !== nextProps.id) return false;
	if (prevProps.isDone !== nextProps.isDone) return false;
	if (prevProps.content !== nextProps.content) return false;
	if (prevProps.date !== nextProps.date) return false;

	return true;
});
```

onDelete, onCreate가 계속해서 새롭게 생성된다.

- 함수는 객체 타입에 해당 → 주소 값으로 저장된다 → 객체 값의 비교가 일어남
- 함수가 리렌더링 될 때 마다 매번 새롭게 생성
- memo: 현재 vs 과거 (얕은 비교)

HOC ?

https://patterns-dev-kr.github.io/design-patterns/hoc-pattern/

## 10.4) useCallback과 함수 재생성 방지

memo는 props가 바뀌었는지, 안 바뀌었는 지 여부를 얕은 비교로 판단 → 객체 타입의 props를 줄 때에는 제대로된 최적화가 이루어지지 않음 → 별도의 콜백함수 전달 필요 → props 변경 시 귀찮아짐
→ onUpdate, onDelete 함수가 애초에 다시 생성되지 않도록 최적화 하는게 더 좋은 방법

```jsx
const func = useCallback(()=>{},[])
```

```jsx
// 마운트 시에만 생성
const onDelete = useCallback(targetId) => {
	dispatch({
		type: "DELETE",
		targetId: targetId,
	});
}, []);

export default memo(TodoItem); 

```

1. 기능
2. 최적화

메모도 연산이 필요하다

- props 비교
- 메모리

ex)

간단한 ui면 다시 리렌더링 하는 게 빠를 수 있다 → 사소한 것 까지 다 최적화하지는 않음

TODO 아이템 컴포넌트처럼 유저의 행동에 따라서 개수가 많아질 수 있는 컴포넌트

함수를 많이 가지고 있어서 무거운 컴포넌트

https://goongoguma.github.io/2021/04/26/When-to-useMemo-and-useCallback/

# Section12 Context

## 11.1) Context란

React Context

컴포넌트간의 데이터를 전달하는 또 다른 방법

기존의 Props가 가지고 있던 단점 해결(Props Drilling 해결)

props의 단점: propsDrilling

props는 부모에서 자식에게 전달 가능

컴포넌트 계층 구조가 깊어지면 다이렉트로 전달 불가능

Context: 데이터 보관소 객체

- 여러 개 만들기 가능

## 11.2) Context 사용하기

컨텍스트는 컴포넌트 외부에 선언

Provider: 해당 컨텍스트가 공급할 데이터 설정, 컨텍스트 데이터를 공급받을 컴포넌트를 설정하기 위해 사용

```jsx
import { createContext } from 'react';

const TodoContext = createContext();

	return (
		<div className="App">
		<Header />
		<TodoContext.Provider
			value={{
				todos,
				onCreate,
				onUpdate,
				onDelete,
			}}
		>
```

## 11.3) Context 분리하기

객체 자체가 다시 생성 → memo 최적화 풀림

useContext 로 불러온 값이 변경이 되면 이것은 props가 변경된 것과 동일하게 리렌더링을 발생시킴

→ TodoContext → TodoStateContext + TodoDispatchContext 로 분리

```jsx
import {
	useRef,
	useState,
	useReducer,
	useCallback,
	createContext
	useMemo
} from "react";

export const TodoStateContext = createContext();
export const TodoDispatchContext = createContext();

function App() {
	...
	const memoizedDispatch = useMemo(() => {
		return { onCreate, onUpdae, onDelete };
	}, []);
	
	return (
		<div className="App">
			<TodoStateContext.Provider value={todos}>
				<TodoDispatchContext.Provider
					value={memoizedDistpatch}
				>
		</div>
		
```

useMemo 사용 이유: 리렌더링 될 때 마다 업데이트 X

disPatchContext: 변하지 않는 값만 공급

왜 구조 분해 할당을 하지 않는가? → 개별로 꺼내쓸 수 있게 공급되었기 때문
