## section 8

### 리액트 컴포넌트의 라이프 사이클

- Mount: 탄생: 서버에서 데이터를 불러오는 작업
- Update: 변화: 어떤 값이 변경되었는지 콘솔에 출력
- UnMount: 죽음: 컴포넌트가 사용하던 메모리 정리

### useEffect: 컴포넌트의 사이드 이펙트를 제어하는 훅

- useEffect로 컴포넌트의 마운드, 업데이트, 언마운트를 다루는 방법은 아래와 같다.

  ```jsx
  const App() {
    const [count, setCount] = useState(0);

      useEffect(()=>{
          ...
      }, []) // 마운트

      useEffect(()=>{
          console.log(`count가 바뀔 때마다 실행 ${count}`);
      }, [count]) // 업데이트

      useEffect(()=>{
          ...
          return () => {
              ...
          } // 클린업 함수
      }, [...]) // 업데이트
  }
  ```

  - 최초 컴포넌트가 마운트될 때 useEffect 내부의 콜백함수가 실행된다.
  - 의존성 배열이 빈 배열인 경우 (mount)
    - 컴포넌트가 마운트 될 때만 실행이 되기 떄문에 컴포넌트 마운트될 때에만 실행하고 싶을 때 유용하게 사용할 수 있다. 과거 프로젝트에서는 Link 컴포넌트로 페이지 이동할 때, 이전 페이지에서 스크롤 위치가 그대로 유지되는 문제 때문에, 마운트 시 스크롤을 초기화할 때 사용했었다.
  - 의존성 배열에 값이 있는 경우 (update)
    - 컴포넌트가 마운트 될 때 한 번 실행되고 의존성 배열의 값이 변경될 때 마다 콜백함수가 실행된다. 데이터를 fetch할 때 사용될 수 있다. 잘못 설정할 경우 무한루프가 발생할 수 있으니 주의 해야한다.
  - useEffect 내부에 클린업 함수가 있는 경우 (unmount)
    - 클린업 함수는 컴포넌트가 언마운트 될때 실행되는 함수이다. 주로 이벤트 리스너를 해제, 타이머 정리 등으로 메모리 누수를 방지할 때 사용한다. 만약 useEffect의 의존성 배열에 값이 있다면 클린업 함수는 업데이트 전에도 실행되어 이전 effect를 정리한 뒤 새로운 effect가 실행된다.(언마운트: 클린업 함수 실행 -> 업데이트 (useEffect 콜백 함수 실행) 방식으로 진행된다.)

### useLayoutEffect vs useEffect
- 둘 다 컴포넌트가 렌더링 과정에서 특정 작업(부수효과)을 실행하게 해주는 훅이다.
- 다만 useEffect는 렌더링 후, 브라우저가 화면에 그린 다음 실행되고, useLayoutEffect는 렌더링 직후, 브라우저가 화면에 그리기 전에 실행된다. 자세한 차이점은 다음과 같다.

  | 구분 | useEffect | useLayoutEffect |
  |------|-----------|----------------|
  | **실행 시점** | 렌더링 후, 브라우저가 화면에 그린 다음 | 렌더링 직후, 브라우저가 화면에 그리기 **전** |
  | **동기/비동기** | 비동기적으로 실행 (렌더링이 먼저 됨) | 동기적으로 실행 (렌더링 중 실행, 화면 그리기 전) |
  | **용도** | 데이터 fetching, 이벤트 등록, 타이머 설정 등 화면 표시와 상관없는 작업 | DOM 측정, 레이아웃 계산, 화면에 표시되기 전에 DOM 조작 필요할 때 |
  | **성능 영향** | 화면 렌더링 지연 없음 | 렌더링 전에 실행되므로 과도하면 성능에 영향 가능 |

- 대부분의 경우 useEffect를 사용하지만, 렌더링 직전에 처리해야 하는 DOM 측정이나 레이아웃 조정 작업에는 useLayoutEffect를 사용한다고 한다.

## section 10

### useReducer
- useReducer는 useState와 동일하게 컴포넌트에 새로운 state를 생성하는 훅이다. 모든 useState는 useReducer로 대체할 수 있다.
- useReducer를 사용하면 상태를 관리하는 코드를 컴포넌트 외부로 분리할 수 있다.
- useReducer의 필요성은 다음과 같다.
  - useState를 사용하게 되면 상태 관리 로직이 컴포넌트 내부에 있다.
  - 상태 값이 많아지면 덩달아 상태 관리를 위한 코드 또한 많아져서 컴포넌트 내부의 코드가 길어지고 복잡해진다.

    ```jsx
    import { useReducer } from 'react';

    const reducer = (state, action) => {
      switch (action.type) {
        case 'INCREASE': 
          return state + action.data;
        case 'DECREASE': 
          return state - action.data;
        default: return state
      }
    }

    const App = () => {
      const [state, dispatch] = useReducer(reducer, 0);

      const handleClickPlus = () => {
        dispatch({
          type: "INCREASE",
          data: 1,
        })
      }

      const handleClickMinus = () => {
        dispatch({
          type: "DECREASE",
          data: 1,
        })
      }

      return (
        <>
          <div>{state}</div>
          <div onClick={handleClickPlus}>+</div>
          <div onClick={handleClickMinus}>-</div>
        </>
        )
    }
    ```
    - useReducer는 두 개의 인자를 받는다. (reducer함수, 초기 state 값) 그리고 state에는 현재 상태 값이 담기고  dispatch에는 사용자의 action객체를 reducer 함수로 전달한다. 사용자가 클릭할 때 이벤트 핸들러에서 handleClick 함수를 호출하고 이 함수 내부에서는 다음과 같다.
      - handleClick 함수는 dispatch함수를 실행한다. 이 함수는 reducer에게 type, data를 전달하게 된다.
    - 이벤트 핸들러에서 dispatch함수가 실행되면 컴포넌트 외부에 reducer함수가 실행된다. (이 reducer 함수는 다른 파일로 분리할 수도 있음)
      - reducer 함수에서는 switch case별로 클릭 이벤트에서 실행된 action.type에 따라 작성된 로직이 실행된다. 이 함수에서는 상태를 반환하면 그 상태가 다음 렌더링 시 반영된다. (useState와 동일)
      - reducer 함수는 순수 함수여야 한다. 즉, 같은 입력(action, state)에 대해 항상 같은 결과를 반환해야 하고, 외부 상태를 직접 변경하면 안 된다.

## section 11

### useMemo
- useMemo는 리렌더링 사이에 계산 결과를 캐싱할 수 있게 해주는 React Hook이다.
- 비용이 높은 로직이 다시 계산되는 것을 생략할 때 유용하게 쓰인다.
  ```jsx
  import { useMemo } from 'react';

  const TodoList = ({todos, tab}) => {
    const visibleTodos = useMemo(
      () => filterTodos(todos, tab),
      [todos, tab]
    )
  }
  ```
  - 매개변수로는 calculateValue, depencies가 필요하다. **콜백 함수**는 캐싱하려는 값을 계산하는 함수이다. 이 함수는 순수해야 하며 인자를 받지 않고 모든 타입의 값을 반환할 수 있어야 한다. React는 초기 렌더링 중 콜백 함수를 호출하고, dependencies가 변경되지 않았을 때 동일한 값을 다시 반환한다. dependencies가 바뀐다면 콜백 함수는 호출하고 결과를 반환하고, 나중에 재사용 가능하도록 저장한다. **의존성 배열**은 코드 내에서 참조된 모든 반응형 값들의 목록이다. React는 Object.is 비교를 통해 의존성들은 이전에 저장되어 있는 값과 비교한다.
  - 동작 방식은 다음과 같다.
    - 초기 렌더링 시 useMemo는 콜백 함수를 호출한 결과를 반환한다.
    - 다음 렌더링에서, 마지막 렌더링에서 의존성 배열의 종속성이 변경되지 않았다면 저장된 값을 반환하고, 의존성 배열의 종속성이 변경되었다면 콜백 함수를 다시 호출하고 반환된 값을 저장한다.
  
  -짚고 넘어가기
    - useMemo는 언제 사용하면 좋은지?
      - 입력하는 계산이 눈에 띄게 느리고 종속성이 거의 변경되지 않는 경우
      - memo로 감싸진 컴포넌트에 prop로 전달 할 경우 값이 변경되지 않았다면 렌더링을 건너뛰고 싶을 것이다. 메모이제이션을 사용하면 의존성이 동일하지 않은 경우에만 컴포넌트를 다시 렌더링할 수 있다.
      - 위 예시 이외에는 계산을 useMemo로 감싸는 것에 대한 이득이 없다고 공식문서에 나와있다. React 개발자 도구 프로파일러를 사용해서 어떤 컴포넌트가 메모이제이션을 통해 가장 큰 이점을 얻을 수 있는지 확인하고 사용하는 것이 좋다.
  
  ### memo
  - memo는 컴포넌트의 props가 변경되지 않은 경우에 리렌더링을 건너뛸 수 있다.
    ```jsx
    import { memo } from 'react';
    const MemoizedComponent = memo(const SomeCompo = () => {
      ...
    }, arePropsEqual);
    ```
    - 컴포넌트를 memo로 감싸면 해당 컴포넌트의 메모이제이션된 버전을 얻을 수 있다. 이러한 컴포넌트는 부모 컴포넌트가 리렌더링 되어도 부모 컴포넌트에게 전달 받고 있는 props가 변경되지 않았다면 리렌더링 되지 않는다.
    - optional로 arePropsEqual처럼 두 번째 인수를 받을 수 있는데, 두 번째 인수인 콜백함수에서는 prevProps와 nextProps를 비교하게 하여 해당 컴포넌트를 리렌더링 시킬지 동일한 결과를 재사용할지 커스텀 하여 사용할 수 있다. 이전 props와 새로운 props가 동일한 경우 true를 반환하게 하고, 아니라면 false를 반환하게 해야한다.
      ```jsx
      const MemoizedComponent = memo(const SomeCompo = () => {
        ...
      }, (prevProps, nextProps) => {
        ...
      });
      ```
    - optional 콜백을 생략하게 되면 리액트가 Object.is로 props를 비교하는데, 자바스크립트의 객체는 생성될 때마다 메모리 주소가 바뀌기 때문에 이를 해결하기 위해서는 optional 콜백을 사용해야 한다. (useCallback으로 대체 가능, 상위 컴포넌트에서 useCallback으로 감싸서 Props로 넘겨주는 방식을 대부분의 경우 더 선호한다.)

    - 이렇게 memo를 통해 부모 컴포넌트가 리렌더링 되더라도 props가 변경되지 않는 한 React는 이를 리렌더링하지 않는다.
  
  ### useCallback

  - useCallback은 리렌더링 간에 함수 정의를 캐싱해 주는 React Hook이다. 앞서 살펴본 React.memo로 최적화한 컴포넌트가 받는 props가 이벤트 핸들러에 부착 될 함수라면 이는 제대로 작동하지 않는다(React는 기본적으로 Object.is로 비교). 따라서 이러한 함수들은 매번 생성될 때마다 다른 주솟값을 가지게 되어 useCallback으로 다시 생성되지 않게 해줘야 한다.
    ```jsx
    import { useCallback } from 'react';
    const cachedFn = useCallback(fn, dependencies);
    ```
    - fn은 캐싱할 함수값이다. React는 첫 렌더링에서 이 함수를 반환하고 다음 렌더링에서 의존성 배열의 값이 이전과 같다면 같은 함수를 반환하고, 다르다면 새로운 함수를 반환하고 이를 재사용할 수 있도록 저장한다.
    - 의존성 배열엔 반응형 값이 들어가고 React는 Object.is를 이용해 각 의존성을 이전 값과 비교한다.

    - useCallback의 반환 값은 함수이며, 첫 렌더링에선 useCallback은 전달한 fn 함수를 그대로 반환한다. 이후 렌더링에서는 이전 렌더링에서 저장해 두었던 fn함수를 그대로 반환하거나(의존성이 변하지 않으면) 현재 렌더링 중 전달한 fn함수를 그대로 반환한다.(의존성이 변하면)

    - 앞서 React.memo에서는 memo할 컴포넌트가 받는 props가 함수 값일 경우에는 제대로 동작하지 않았는데 이때 커스텀 콜백을 이용해서 일일히 반환 값을 줘야했다. 하지만 useCallback으로 함수 자체를 감싸서 자식 컴포넌트로 props를 내려준다면 자식 컴포넌트에서는 React.memo를 하면(커스텀 콜백 미 지정) 해당 컴포넌트는 정상적으로 최적화가 된다.


## section 12

### createContext와 useContext

- 부모컴포넌트에서 트리의 깊은 곳까지 props로 데이터를 전달 할 때, 중간 컴포넌트에게도 props를 넘겨주는 깊이가 깊어지는 props drilling 문제를 해결하기 위해 -> context 개념이 등장하였다.

- context는 부모 컴포넌트가 트리 아래에 있는 모든 컴포넌트에게 깊이 상관 없이 정보를 명시적으로 props를 통해 전달하지 않고도 사용할 수 있게 해준다.

  #### createContext

  - createContext는 React에서 전역적으로 데이터를 공유할 수 있도록 해주는 기능이다. 이것은 저장소라고 볼 수 있을 것 같다.

  - createContext를 사용하면 컴포넌트가 context를 제공하거나 읽을 수 있다. 컴포넌트 외부에서 createContext를 호출하여 컨텍스트를 생성한다.

    ```jsx
    import { createContext } from 'react';

    const SomeContext = createContext(defaultValue);
    ```

    - defaultValue는 컴포넌트가 컨텍스트를 읽을 때 상위에 일치하는 컨텍스트 제공자가 없는 경우 컨텍스트가 가져야 할 값이다. 저장소의 기본 값이라고 볼 수 있다. provider로 감싸지지 않은 컴포넌트가 context를 읽을 때 이 기본값이 지정된다.(실제로 대부분은 Provider로 감싸서 값을 읽는 경우가 많다.)

    - createContext는 컨텍스트 객체를 반환하고 이 객체는 어떠한 정보도 갖고 있지 않다. provider를 이용해서 컨텍스트 값을 제공한다. 강의에서 나온 아래와 같은 방식은 React 19에서는 사용되지 않는다고 한다. React 19에서는 다음과 같이 사용한다.
      ```jsx
      import { createContext, useState } from 'react';

      const ThemeContext = createContext('light');

      const App = () => {
        const [theme, setTheme] = useState('light');
        ...

        return (
          // React 19버전
          <ThemeContext value={theme}>
            <Page />
          </ThemeContext>

          // 기존 방식
          <ThemeContext.Provider value={theme}>
            <Page />
          </ThemeContext.Provider>
        )
      }
      ```
      - 여기서 value={theme} 이것은 컨텍스트를 읽는 모든 컴포넌트에 전달하려는 값이다. 컨텍스트 값은 어떤 유형이든 될 수 있고, 제공자 내부에서 useContext(ThemeContext)를 호출하는 컴포넌트는 그 위의 가장 가까운 해당 컨텍스트 제공자의 value를 받게 된다.

  #### useContext
  - useContext는 컴포넌트에서 Context()를 읽고 구독할 수 있는 React Hook이다.
    ```jsx
    import { useContext } from 'react';
    import ThemeContext from '../App'

    const Component = () => {
      const value = useContext(ThemeContext);
      ...
    }
    ```
    - useContext를 컴포넌트 최상위에서 호출하여 Context를 읽고 구독한다.
    - ThemeContext는 createContext로 생성한 context이다. 이때 ThemeContext가 변경되면 React는 해당 context를 구독중인 컴포넌트를 다시 렌더링한다.

  #### context 사용하기 전 고려해야할 점
  - children을 사용하면 계층이 줄어든다.
  - props로 전달하는 것은 어떤 컴포넌트가 어떤 데이터를 사용하는지 매우 명확히 알 수 있다. 데이터 흐름이 props를 통해 분명해지기에 코드를 유지보수 하기에도 좋다.
