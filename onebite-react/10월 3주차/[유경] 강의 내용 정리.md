# Node.js 기초

## **3.2) Node.js 설치하기**

**Node.js**

- 자바스크립트를 실행시켜주는 구동기
- 자바스크립트 런타임
- 초기에는 웹 브라우저 내에서만 동작하도록 설계 -> 매우 유연, 생산성 높음
- 웹서버, 모바일앱, 데스크톱앱 설계 가능

- Current: 가장 최신 버전
- LTS: Long Term Support - 장기적으로 지원(추천)
- node 홀수 버전은 **6개월짜리 실험 릴리스**로, 새로운 기능이 안정화되기 전에 포함

## **3.3) Node.js 사용하기**

프로젝트

- 특정 목적을 갖는 프로그램의 단위

패키지

- Node.js에서 사용하는 프로그램의 단위

package script

- 매크로의 역할
- npm run ${script}

## **3.4) Node.js 모듈 시스템 이해하기**

모듈(Module)

- 기능별로 나누어진 각각의 js 파일

모듈 시스템

- 모듈을 생성하고, 불러오고, 사용하는 등의 모듈을 다루는 다양한 기능을 제공하는 시스템
- CommonJS(CJS)
    - module.exports = {
    - require("./math");
- ESModule(ESM)
    - 패키지 설정 필요
        - "type": "module"
    - export { add, sub };
    - import {add, sub} from "./math.js" (.js 필요)
    - export function ...
    - export default -> 한 파일에 하나만, 중괄호 없이, 별칭으로 가능

객체 분해 할당

## **3.5) Node.js 라이브러리 사용하기**

라이브러리

- 프로그램을 개발할 때 필요한 다양한 기능들을 미리 만들어 모듈화 해 놓은 것

`npm i randomcolor` 에서 **i는 install의 줄임말**

package.json "dependencies": 의존

package-lock.json

- 패키지 정보를 package.json보다 더 정확하게 저장
- ^: 버전 범위 (대략적인 버전)

node_modules

- 실제로 설치된 라이브러리의 저장소

npm install : package.json 정보를 토대로 라이브러리 다시 설치 가능

package.json만 알면 다시 설치할 수 있으므로 다른 사람에게 공유 시 node_modules 폴더는 공유할 필요 없음 (무거움)

# React.js 개론

## **4.1) React.js를 소개합니다**

**React.js**

- Meta(Facebook)이 개발한 오픈소스 JavaScript 라이브러리
- 대규모 웹 서비스의 UI를 더 편하게 개발하기 위해 만들어진 기술
- ex) netflix, facebook, instagram, notion

React의 기술적인 특징

1. 컴포넌트를 기반으로 UI를 표현한다.
    1. 중복 코드 발생 시 대응 용이
2. 화면 업데이트 구현이 쉽다.
    1. 업데이트: 사용자의 행동(클릭, 드래그)에 따라 웹 페이지가 스스로 모습을 바꿔 상호작용 하는 것
    2. 선언형 프로그래밍: 과정은 생략하고 목적만 간결히 명시하는 방법 (React) -> **업데이트를 위한 복잡한 동작을 직접 정의할 필요 없이 특정 변수의 값을 바꾸는 것 만으로도 화면을 업데이트 시킬 수 있다.**
    3. 명령형 프로그래밍: 목적을 이루기 위한 모든 일련의 과정을 설명하는 방식 (JS)
3. 화면 업데이트가 빠르게 처리된다.
    1. 브라우저의 렌더링 과정 (Critical Rendering Path)
        1. HTML -> DOM(Document Object Model) -> RenderTree
        2. CSS -> CSSOM -> RenderTree
        3. RenderTree(웹 페이지의 청사진) -> Layout(요소의 배치를 잡는 작업) -> Painting(실제로 화면에 그려내는 과정)
    2. Reflow, Repaint -> 오래 걸리는 작업 -> 성능 악화
    3. React Virtual DOM: 업데이트 -> 업데이트 모음 -> 한 번에 수정 -> DOM
        1. Virtual DOM: DOM을 자바스크립트 객체로 흉내낸 것, 복제판

## **4.2) 첫 React App 생성하기**

Vite(비트)

- 차세대 프론트엔드 개발 툴
- 기본 설정이 적용된 React App 생성 가능
- React 공식 문서에서도 권장

배포 시에는 devDependencies 내용은 포함 X

처음에는 package-lock.json, node_modules 설치 X -> npm i로 설치

public: 이미지, 폰트와 같이 코드가 아닌 정적인 파일 저장하는 곳

src: 자바스크립트 파일 저장

eslint: 개발자간 코드 스타일 통일 시켜주는 도구

## **4.3) React App 구동원리 살펴보기**

React Web Server

localhost:5173

- localhost: 내 컴퓨터 주소
- 5173: 포트 번호

ReactDOM.createRoot(document.getElementByID('root').render

- 인수로 전달받은 HTML 요소를 HTML 루트로 만들어줌
- render -> 렌더링하겠다

# React.js 입문

## **5.1) 실습 준비하기**

eslint.config.js == eslintrc.js (eslint 옵션 설정)

eslint: 미리 코드의 오류를 vscode 상에서 볼 수 있음

"no-unused-vars":"off",

"react/prop-types":"off",

## **5.2) React 컴포넌트**

component

- html 요소를 반환하는 함수
- 함수 선언식, 화살표 함수, 클래스형 컴포넌트
- 함수 이름 첫 글자는 대문자

다른 컴포넌트 내부에 포함되는 컴포넌트 -> 자식 컴포넌트 (ex. Header)

모든 컴포넌트는 App 컴포넌트(Root 컴포넌트)의 자식 컴포넌트로 존재해야 함(관례)

`src/components/Header.jsx`

ESModule 시스템을 쓰고 있지만 vite를 쓰면 확장자(js, jsx)를 명시하지 않아도 된다

## **5.3) JSX로 UI 표현하기**

자바스크립트에서는 HTML를 리턴할 수 없음

React.js에서는 JSX문법을 활용하므로 HTML 리턴 적법하다고 판단

JSX(JavaScript Extensions): 확장된 자바스크립트 문법 -> JavaScript + HTML 혼용

삼항연산자도 값으로 평가되어 사용 가능

```bash
cont number = 10;
return (
    <h2>{number%2 === 0 ? "짝수":"홀수"}</h2>
```

JSX 주의 사항

1. 중괄호 내부에는 자바스크립트 표현식만 넣을 수 있다.
2. 숫자, 문자열, 배열 값만 렌더링 된다. (undefined, true, null, 객체 불가능)
3. 모든 태그는 닫혀있어야 한다.
    1. 셀프 클로징
    2. 닫는 태그
4. 최상위 태그는 반드시 하나여야만 한다.
    1. 없으면 빈 태그로 설정 `<> </>`

조건에 따라 각각 다른 컴포넌트 렌더링 하는 방법

```jsx
<>
    {user.isLogin ? (
        <div>로그아웃</div>
    ) : (
        <div>로그인</div>
    )}
</>

if (user.isLogin) {
    return <div>로그아웃</div>;
} else {
    return <div>로그인</div>;
}
```

스타일 설정 방법

1. 요소에 직접 스타일 설정
    1. 스타일 속성 규칙: 연결되는 단어 대문자로(Camel Case)
    2. 가독성이 떨어짐

```java
<div
    style = {{
        backgroundColor: "red",
        borderBottom: "5px solid blue",
    }}
```

1. css 파일 분리
    1. class 가 아니라 className임을 주의

```xml
<div className="logout">로그아웃</div>
```

## **5.4) Props로 데이터 전달하기**

props(properties)

- 전달하는 값

props에 해당되는 값이 무조건 들어올 것이라고 가정하고 코드를 짜면 위험하다 -> 기본값 설정

react19

- 구조분해할당 형식으로 기본값 설정

```jsx
function Button({text, color="black"}){
    return (
        <button style = {{color: color}}>{text}</button>
    )
}

export default Button;
```

여러 props를 전달해야 할 때 -> spread 연산자

- 객체 정의하고 `{...buttonProps}로 작성

**props에는 일반적인 자바스크립트 값 뿐만 아니라 HTML 요소나 React 컴포넌트까지 전달 가능**

## **5.5) 이벤트 처리하기**

이벤트 핸들링

- 이벤트가 발생했을 때 그것을 처리하는 것
    - ex) 버튼 클릭 시 경고창 노출
- 이벤트: 웹 내부에서 발생하는 사용자의 행동
    - ex) 버튼 클릭, 메시지 입력, 스크롤
- 핸들링: 다루다, 취급하다

이벤트 핸들러

```sql
onClick={() => {
}}
```

콜백 함수를 전달하듯이 함수 이름만 전달 (결과 전달 () X)

onMouseEnter

이벤트 객체

```jsx
const onClickButton = (e) => {
    console.log(e);
    console.log(text);
}
```

합성 이벤트

- 모든 웹 브라우저의 이벤트 객체를 하나로 통일한 형태(통합 규격)
- Cross browsing Issue: 웹 브라우저마다 스펙이 달라 문제 발생 (이벤트 객체가 서로 다름)
    - chrome: target
    - safari: ETarget

## **5.6) State로 상태관리하기**

State: 상태

- 현재 가지고 있는 형태나 모양을 정의
- 변화할 수 있는 동적인 값

리 렌더(Re-Render), 리 렌더링(Re-Rendering)

- 컴포넌트가 다시 렌더링 되는 상황
- 컴포넌트의 함수를 다시 호출하고 새롭게 반환

useState: React가 제공하는 내장 함수

```cpp
const state = useState(0);
console.log(state);// [0,f]
```

- 0: state의 상태 값
- f: state를 변경시키는 상태 변화 함수
- -> 그래서 구조 분해 할당을 쓰는 것이 일반적

```cpp
const [state, setState] = useState(0);
```

```xml
const [count, setCount] = useState(0);

return(
    <>
    <div>{count}</div>
    <button
        onClick={()=>{
           setCount(count+1);
        }
    }
```

삼항 연산자 적극 이용 -> 깔끔해짐

let, const와 다른 점 -> 값이 바뀐다고 해서 렌더링이 다시 되지는 않는다

react 컴포넌트는 가변적인 값을 관리할 때 state 이용

## **5.7) State와 Props**

컴포넌트는 state가 변경되지 않아도, 부모로 부터 받는 props가 바뀌면 리렌더링 된다.

React 에서 리렌더링 되는 경우

1. state 값이 변경 되었을 때
2. props 값이 변경 되었을 때
3. 부모 컴포넌트가 리렌더링 되었을 때

**서로 관련이 없다면 다른 컴포넌트로 분리하자 (불필요한 리렌더링을 막기 위함)**

- Bulb
- Counter

## **5.8) State로 사용자 입력 관리하기 1**

간단한 회원가입 폼

1. 이름
2. 생년월일
3. 국적
4. 자기소개

```sql
const [name, setName] = useSate("name");
const onChangeName = (e) => {
	setName(e.taraget.value);
}
return(
	<input
		value = {name}
		onChange={onchangeName}
		placeholder={"name"}
	/>
	<input
		value={bitrh}
		onChange={onChangeBirth}
		type = "date"
	/>
	<select value={country} onChange={onChangeCountry}>
		<option></option>
		<option value="kr">korea</option>
		<option>usa</option>
		<option>england</option>
		
	<textarea value = {bio} onChange={onChangeBio}/>
)
```

일반적으로 select 컴포넌트에서 실제 보이는 선택지는 길게 배치(한국), 실제로 전달하는 값은 간단하게(kr)

## **5.9) State로 사용자 입력 관리하기**

모든 state를 하나의 객체로 합침

```php
const [input, setInput] = useState({
    name:"",
    birth:"",
    country: "",
    bio: "",
})

const onChangeName = (e) => {
    setInput({
    ...input, // ... 중요!
    name: e.target.value,
    });
);
```

통합 이벤트 핸들러

[propertyKey]: propertyValue,

```csharp
const onChange = (e) => {
    setInput({
        ...input,
        [e.target.name]: e.target,value,
    });
};
```
