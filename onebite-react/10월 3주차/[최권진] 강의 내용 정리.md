## section 4

### 리액트의 특징

1. 컴포넌트를 기반으로 UI를 표현한다

- 컴포넌트 단위로 모듈화할 수 있기 때문에 Header와 같이 여러 페이지에서 공통으로 사용되는 경우 중복 코드가 발생하지 않는다. (재사용성, 유지보수 용이)

2. 화면 업데이트 구현이 쉽다

- 화면이 업데이트 된다는 것은 사용자의 동작이나 상태 변화로 인해 컴포넌트가 리렌더링되고, 그 결과 Virtual DOM과 실제 DOM이 비교되어 실제 화면이 변경되는 것을 의미한다.리액트에서 화면이 리렌더링 조건은 다음과 같다.
  - 컴포넌트의 상태가 변경 된 경우 -> 해당 컴포넌트가 리렌더링되고, 변경된 부분이 있다면 실제 화면에 반영(변경된 부분 없다면 render phase만 일어남(리렌더링만 됨))
  - 부모 컴포넌트가 리렌더링 된 경우 -> 자식 컴포넌트 리렌더링 (이 때 props로 받은 값이 바뀌지 않으면 commit phase(화면 업데이트)는 일어나지 않음, 리렌더링만 일어남(render phase만 수행))

3. 화면 업데이트가 빠르게 처리된다
   브라우저 렌더링 과정은 다음과 같다.

- HTML을 파싱해 DOM을 만들고 CSS를 파싱해 CSSOM을 만든다.
- 그리고 이 두 가지(DOM, CSSOM)을 합쳐서 Render Tree를 만든다.
- 그 다음 이 Render Tree를 기반으로 요소의 배치를 잡는 작업인 Layout 과정이 일어난다.
- 마지막으로 실제 화면에 그려내는 Painting 과정이 일어난다.

이때, Layout과정을 reflow, Painting과정을 repaint라고 한다. DOM이 자주 변경되면 reflow/repaint가 자주 발생해 성능이 나빠진다. (reflow, repaint는 무거운 작업)

여기서 DOM이 수정되면 브라우저는 렌더링 과정을 거치는데 리액트에서는 DOM의 복제본인 Virtual DOM을 객체 구조로 만들고 이 Vritual DOM애 수정 사항이 있다면 수정된 내용을 한 번에 모아서 처리하기에(Batch Update) 최소한의 횟수로 DOM을 수정해 빠른 화면 업데이트가 가능하다.

### Vite로 구성한 React App 구동원리

- 리액트는 SPA구조로 하나의 index.html에서 <div id="root"></div> 이 id가 root인 div태그에 코드가 추가된다고 생각하면 된다.

- main.jsx 파일에서 ReactDom.createRoot메서드로 index.html에 있는 <div id="root"></div> 이 요소에 <App> 컴포넌트를 렌더시킨다고 볼 수 있다.

- 여기서 main.jsx파일은 index.html에서 실행하고 있다.

<br>

## section 5

### jsx 주의 사항

1. 중괄호 내부에는 자바스크립트 표현식만 넣을 수 있다.
2. 숫자, 문자열, 배열 값만 렌더링 된다.
3. 모든 태그는 닫혀있어야 한다.
4. 최상위 태그는 반드시 하나여야만 한다.

### props란?

- props란 부모 컴포넌트에서 자식 컴포넌트를 렌더링 할 때, 자식 컴포넌트에게 값을 전달 할 수 있는데 이를 위해 사용하는 객체다. 리액트에서 컴포넌트는 기본적으로 함수처럼 동작하기 때문에, 인자로 데이터를 전달받는 형태라고 생각할 수 있다.

- props는 읽기 전용으로 자식 컴포넌트가 전달받은 props를 직접 수정할 수 없다. 만약 값을 바꾸고 싶다면 부모에서 상태를 바꾸고 다시 내려보내야 한다.

- props는 컴포넌트의 재사용성을 높여준다. 같은 컴포넌트를 props만 다르게 전달해서 여러 형태로 사용할 수 있다. 또, children props를 통해 데이터 (혹은 컴포넌트)를 전달 할 수 있다.

### 합성 이벤트란?

- 모든 웹 브라우저의 이벤트 객체를 하나로 통일한 형태 (크로스 브라우징 이슈 해결)

- e.target을 통해 이벤트가 일어난 발원지를 알 수 있다.

### state

- state 정의 및 동작 원리

  - 현재 가지고 있는 형태나 모양을 정의하며 변화할 수 있는 동적인 값
  - useState를 통해 상태를 만들 수 있는데, useState는 현재 상태값과 상태값을 변경할 수 있는 함수가 있다.

    ```jsx
    const [state, setState] = useState(0);

    const handleClick = () => {
      setState(state + 1);
    };

    return <button onClick={handleClick}>클릭~</button>;
    ```

    - 위 코드의 동작 방식은 다음과 같다.
      - 컴포넌트가 처음 렌더링이 되면 state의 초기값으로 useState를 사용해 0을 전달했으므로 [0, setState]를 반환한다. React는 0을 최신 state 값으로 기억한다.
      - 사용자가 버튼을 클릭하면 setState(state + 1)를 호출한다. state는 0이므로 setState(0 + 1)이다. React는 이 값을 state에 기억하게 한다.
      - 또 클릭을 하면 반복 (React는 현재 state가 1인걸 기억하고 있는다.)

- state는 독립적으로 작동한다.

  - state는 화면에서 컴포넌트 인스턴스에 지역적이다. 다시 말해, 동일한 컴포넌트를 두 번 렌더링하면 그 안에 있는 state 값은 독립적으로 동작한다. 하나의 컴포넌트의 state가 바뀌어도 또 다른 하나의 컴포넌틑의 state는 바뀌지 않는다는 의미이다.

- state는 스냅샷처럼 동작한다.

  - state는 스냅샷처럼 동작한다. setter 함수로 state를 변경하여도 state 변수는 바로 변경되지 않고, 리렌더링을 통해 새로운 값으로 바꿔준다. 즉, 리액트에게 이 상태 값을 다음 렌더링 때 반영해달라고 요청하는 것과 동일하다.

    ```jsx
    import { useState } from "react";

    export default function Counter() {
      const [number, setNumber] = useState(0);

      return (
        <>
          <h1>{number}</h1>
          <button
            onClick={() => {
              setNumber(number + 1);
              setNumber(number + 1);
              setNumber(number + 1);
            }}
          >
            +3
          </button>
        </>
      );
    }
    ```

    - 위 코드에서 버튼을 클릭하면 number는 1씩 증가한다. 그 이유는 위에서 말했듯이 상태 값은 다음 렌더링 때 변경되기 때문이다. 만약 한 번에 3씩 증가하기 위해서는 업데이터 함수를 이용해서 상태 값을 변경해줘야 한다.

      ```jsx
      <button
        onClick={() => {
          setNumber((number) => number + 1);
          setNumber((number) => number + 1);
          setNumber((number) => number + 1);
        }}
      >
        +3
      </button>
      ```

- state는 batching된다.

  - 섹션 4에서 리액트의 특징 중 배치 업데이트라는 개념이 등장했었다. 리액트에서는 여러 state 업데이트를 한 번에 모아서 처리한다. 공식문서에서는 이를 state 업데이트 큐라고 표현한다.

- 불변성을 지켜라
  - 객체나 배열 state를 업데이트할 때는 불변성을 지켜서 객체를 직접 수정하지 말고 항상 새 객체로 교체해서 업데이트 해야 한다. 객체를 직접 바꾸면 리렌더가 안 되고 이전 렌더의 스냅샷을 오염시켜 버그가 나기 때문에 전개 구문으로 복사한 뒤, 변경된 필드만 덮어써서 새 객체를 setState로 넘겨야 한다. 중첩된 객체는 immer를 사용하자.

### useRef

- 새로운 reference 객체를 생성한다. 값이 변경되어도 리렌더링을 유발하지 않는다. 즉 Ref는 컴포넌트가 일부 정보를 기억하고 싶지만, 해당 정보가 렌더링을 유발하지 않도록 할 때 사용한다.

  ```jsx
  import { useRef } from "react";

  const ref = useRef(0);

  // 아래와 같은 객체 반환
  {
    current: 0;
  }
  ```

  ref.current를 통해 해당 Ref의 current 값에 접근할 수 있다.

  Ref는 보통 DOM을 조작할 때 사용한다.

### React Hooks

- 리액트 훅은 클래스 컴포넌트에서 사용되는 기능을 함수형 컴포넌트에서도 사용할 수 있도록 하기 위한 것이다. 리액트 훅에는 다음과 같은 규칙이 있다.
  - 함수 컴포넌트, 커스텀 훅 내부에서만 호출 가능
  - 조건부로 호출될 수는 없다.
  - 커스텀 훅을 직접 만들 수 있다.
