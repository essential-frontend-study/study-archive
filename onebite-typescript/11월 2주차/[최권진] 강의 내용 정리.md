## section 6

### 타입스크립트 클래스
```ts
class Employee {
    // 필드
    name: string;
    age: number;
    position: string;

    // 생성자
    constructor(name: string, age: number, position: string) {
        this.name = name;
        this.age = age;
        this.position = position;
    }

    // 메서드
    work() {
        console.log('일함');
    }
}

class ExecutiveOfficer extend Employee {
    // 필드
    officeNumber: number;

    // 생성자
    constructor(
        name: string, 
        age: number, 
        position: string, 
        officeNumber: number
        ) {
            super(name, age, position);
            this.officeNumber = officeNumber;
        }
}
```
- 타입스크립트에서 클래스를 만들 때, 필드와 생성자 매개변수에는 타입을 지정해줘야 한다.
- 또한 상속을 받으면 super 키워드를 사용해줘야 오류가 안난다. super의 매개변수도 다 넣어줘야 한다.
- 타입스크립트의 클래스는 타입으로도 활용할 수 있다.

#### 접근 제어자
```ts
class Employee {
    // 필드
    name: string; -> 생략 = public
    private age: number;
    protected position: string;
}
```
- public은 해당 값을 외부에서 읽기 쓰기 가능
- private는 해당 값을 해당 클래스 내부에서만 접근 가능
- protected는 해당 값을 해당 클래스, 상속받은 클래스에서 접근 가능

#### 인터페이스와 클래스
```ts
interface CharacterInterface {
    name: string;
    moveSpeed: number;
    move(): void;
}

class Character implements CharacterInterface {
    constructor (
        public name: string,
        public moveSpeed: number,
        private extra: string,
    ) {
        ...
    }

    move(): void {
        console.log(`${this.moveSpeed} 속도로 이동!`)
    }
}
```
- implements는 구현한다라는 의미이다 즉 Character클래스는 CharacterInterface를 구현하는것이라고 볼 수 있다.
- 기본적으로 interface에 정의된 속성은 public이다. 해당 클래스에 private가 필요하다면 interface에 정의하지 말고 따로 클래스에 정의하면 된다.

## section 7

### 제네릭
- 제네릭이란 함수나 인터페이스, 타입 별칭, 클래스 등을 다양한 타입과 함께 동작하도록 만들어주는 타입스크립트의 기능이다.
- 제네릭이 필요한 상황을 알아보자.  다음 함수는 다양한 타입의 매개변수를 받아서 반환하는 함수이다.
    ```ts
    function func(value: any) {
        return value;
    }

    let num = func(10);
    let str = func('string');
    ```
    - 이때 num과 str은 any 타입이 되고 value: unknown으로 바꾼다면 메서드를 사용할 때 타입 좁히기를 통해 사용해야만 한다.
        ```ts
        if (typeof num === 'number') num.toFixed();
        ```
    - 하지만 func를 제네릭 함수로 만들면 다음과 같이 표현할 수 있다.

### 제네릭 함수
```ts
function func<T>(value: T) {
    return value;
}

let num = func(10); // 이때의 num 변수는 number 타입으로 추론
let str = func('10'); // 이때의 str 변수는 string 타입으로 추론
```
- 제네릭 함수로 만들려면 함수 이름 뒤어 꺽쇠를 열고('<') 타입을 담는 변수인 타입 변수 T를 선언한다. 그리고 다시 꺽쇠를 닫아준다.('>') 매개변수와 반환값의 타입을 타입 변수 T로 설정할 수 있는데 이렇게 되면 func함수가 호출될 때 인자가 타입 변수 T에게 전달된다.

- 즉, 제네릭 함수에서 타입 변수는 해당 함수가 호출될 때 타입이 결정된다.
- 만약 해당 제네릭 함수를 튜플 타입으로 추론하게 하고 싶다면 다음과 같다.
    ```ts
    let arr = func<[number, number, number]>([1, 2, 3]);
    ```
- 이렇게 되면 func 함수가 호출될 때 [number, number, number] 타입이 타입 변수 T로 전달되는 방식이다. 즉, func 함수의 매개변수 value의 타입은 [number, number, number] 튜플 타입이다.

### 제네릭 사용 사례
- 총 3가지의 사례를 살펴보자
    ```ts
    function swap<T, U>(a: T, b: U) {
        return [b, a]
    }

    const [a, b] = swap('1', 2);
    ```

    - 타입 변수는 함수에서 여러개 지정할 수 있다. swap 함수는 두 매개변수를 받아 서로 순서를 바꿔주는 함수인데, 전달해주는 타입이 위와 같이 string, number라면 타입 변수를 T, U로 설정해줘서 각각 타입 변수를 설정해줄 수 있다.

    ```ts
    function returnFirstValue<T>(data: T[]) {
        return data[0];
    }
    // 이때의 data 타입은 unknown 타입이다. 함수가 호출되면 타입 변수의 타입이 결정되는데, 아직 함수를 호출하기 전이기 때문.

    let num = returnFirstValue([0, 1, 2]);

    let str = returnFirstValue([1, 'hello', 'mynameis']);
    ```

    - str 변수의 경우 string | number 유니온 타입이 된다. 하지만 해당 함수는 배열에서 첫 요소만 반환하는 것이기 때문에 number 타입으로 추론되게 하려면 다음과 같이 해야한다.
        ```ts
        function returnFirstValue<T>(data: [T, ...unknown[]]) {
            ...
        }  
        ```
        - 이처럼 data의 타입을 첫 번째 요소는 T이고 나머지 요소는 unknown인 튜플 타입으로 만들어주면 str 변수의 타입은 number타입으로 잘 추론된다.

    ```ts
    function getLength<T>(data: T) {
        return data.length;
    }

    let var1 = getLength([1, 2, 3]);
    let var2 = getLength('12345');
    let var3 = getLength({length: 10});
    let var4 = getLength(10);
    ```
    - 해당 함수는 매개변수의 length를 반환하는 타입이다. 즉, 매개변수에 length라는 속성이 있으면 다 반환을 해줘야한다. 현재는 데이터 타입 T에 length 속성이 없기에 오류가 난다. 오류를 해결하려면 다음과 같이 작성해야 한다.
    ```ts
    function getLength<T extends { length: number }>(data: T) {
        return data.length
    }
    ```
    - 이 의미는 타입 변수 T의 타입을 제한해주는 것이다. 이 타입 변수 T는 number타입인 length 속성이 있어야 한다는 것을 의미한다. 즉, 이 함수를 사용할 때, 매개변수는 length 속성이 있어야 사용할 수 있다.

### 제네릭으로 map, forEach 메서드 타입 정의하기
- map을 먼저 살펴보자
    ```ts
    function _map<T, U>(arr: T[], callback: (item: T) => U) {
        let result = [];

        for (let i = 0; i < arr.length; i++) {
            result.push(callback(arr[i]));
        }

        return result;
    }

    _map([1,2,3], v => String(v) );
    _map(['123', '1234'], v => parseInt(v));
    ```
    - map 함수는 arr과 callback 함수를 매개변수로 받는다. arr이 number[]타입이라면 callback 함수의 item은 number 타입을 가진다. 즉 arr: T[]을 가지고, item: T를 가지게 된다. 또, map 함수는 타입 변수를 두 개 가져야하는데 그 이유는 반환값의 타입은 arr타입과 다를 수 있기 떄문이다. 따라서 반환값 타입은 또 다른 타입 변수인 U로 지정해야 한다.

- forEach를 살펴보자
    ```ts
    function _forEach<T>(arr: T[], callback: (v: T) => void) {
        for (let i = 0; i < arr.length; i++) {
            callback(arr[i]);
        }
    }

    _forEach([1,2,3], v => console.log(v.toFixed()));
    ```
    - forEach는 map과 거의 동일하다 forEach는 반환값이 없기 때문에 void를 반환해주기에 타입 변수가 하나만 필요하다.

### 제네릭 인터페이스와 제네릭 타입 별칭
- 제네릭은 인터페이스에도 적용할 수 있다. 인터페이스에 타입 변수를 선언해 사용하면 된다.
    ```ts
    interface KeyPair<K, V> {
        key: K;
        value: V;
    }

    let keyPair: KeyPair<string, number> = {
        key: 'string',
        value: 0,
    }

    let keyPair1: KeyPair<boolean, string[]> = {
        key: true,
        value: ['1', '2'],
    }

    // 인덱스 시그니처
    interface Map<V> {
        [key: string]: V;
    }

    let stringMap: Map<string> = {
        key: '123',
    }

    let booleanMap: Map<boolean> = {
        key: true,
    }
    ```
    - 이런식으로 인터페이스에 타입 변수를 선언해 사용하면 유연하게 객체 타입을 지정해줄 수 있다.
    - 또, 제네릭 인터페이스와 인덱스 시그니처를 통해 객체의 타입을 유연하게 지정해줄 수 있다.

    ```ts
    // 제네릭 타입 별칭
    type Map<V> = {
        [key: string]: V;
    }

    let stringMap: Map<string> = {
        key: '123',
    }
    ```
    - 제네릭 타입 별칭도 제네릭 인터페이스와 문법만 다르고 거의 동일하게 동작한다.

#### 제네릭 인터페이스의 활용예시
- 유저 관리 프로그램을 만들고 학생유저와 개발자유저로 유저를 구분한다고 가정해보자
    ```ts
    interface Student {
        type: 'student';
        school: string;
    }

    interface Developer {
        type: 'developer';
        skill: string;
    }

    interface User {
        name: string;
        profile: Student | Developer;
    }

    function goToSchool(user: User) {
        if (user.profile.type !== 'student') {
            console.log('잘 못 오셨습니다');
            return;
        }

        const school = user.profile.school;
        console.log(`${school}로 등교 완료`)
    }

    const developerUser: User = {
        name: '이정환',
        profile: {
            type: 'developer',
            skill: 'TypeScript'
        }
    }

    const studentUser: User = {
        name: '홍길동',
        profile: {
            type: 'student',
            school: '가톨릭대학교'
        }
    }
    ```
    - 이렇게 유저관리 프로그램을 만들었다. 하지만 여기서 만약 유저 구분이 학생과 개발자뿐만 아닌 다른 유저들이 계속 생긴다면 모든 메서드에는 goToSchool 함수와 같이 타입 좁히기를 사용해줘야 할 것이다. 그래서 이럴 때 제네릭 인터페이스를 사용할 수 있다.
        ```ts
        interface Student {
            type: 'student';
            school: string;
        }

        interface Developer {
            type: 'developer';
            skill: string;
        }

        interface User<T> {
            name: string;
            profile: T;
        }

        function goToSchool(user: User<Student>) {
            const school = user.profile.school;
            console.log(`${school}로 등교 완료`)
        }

        const developerUser: User<Developer> = {
            name: '이정환',
            profile: {
                type: 'developer',
                skill: 'TypeScript'
            }
        }

        const studentUser: User<Student> = {
            name: '홍길동',
            profile: {
                type: 'student',
                school: '가톨릭대학교'
            }
        }
        ```
        - 이제 유저가 많아져도 각 함수에 타입 좁히기가 필요없어지고 기존처럼 profile 타입을 유니온 타입으로 늘려나갈 필요도 없다.

### 제네릭 클래스
```ts
class NumberList {
    constructor(private list: number[]) {}

    push(data: number) {
        this.list.push(data);
    }

    pop() {
        return this.list.pop();
    }

    print() {
        console.log(this.list);
    }
}

const numberList = new NumberList([1, 2, 3]);
numberList.pop();
numberList.push(4);
numberList.print() // [1, 2, 4]
```
- 이렇게 NumberList 클래스는 숫자배열을 받아서 해당 숫자를 push, pop, print 할 수 있는 클래스다. 하지만 StringList 클래스나 BooleanList 클래스와 같이 다른 타입을 가진 배열을 받아 동일한 행동을 하는 클래스는 만들어주기 위해서 제네릭 클래스를 사용할 수 있다.
    ```ts
    // 제네릭 클래스
    class List<T> {
        constructor(private list: T[]) {}

        push(data: T) {
            this.list.push(data);
        }

        pop() {
            return this.list.pop();
        }

        print() {
            console.log(this.list);
        }
    }

    const numberList = new List([1, 2, 3]);
    const stringList = new List(['1', '2', '3']);
    const booleanList = new List([true, false, false]);
    ```
    - 제네릭 클래스를 이용해서 다양한 타입을 받는 범용적인 클래스를 만들어줄 수 있다.
    - 제네릭 클래스는 제네릭 인터페이스나 제네릭 타입 변수와는 다르게 
        ```ts
        const numberList = new List<number>([1, 2, 3]);
        ```
    - 이런식으로 클래스의 생성자를 호출할 때 생성자의 인수로 전달되는 값을 기준으로 타입변수의 타입을 추론하기에 number 타입이라고 명시해주지 않아도 된다.

### 프로미스와 제네릭
```ts
const promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(20);
    }, 3000);
})

promise.then((res) => {
    console.log(res * 10);
})
```
- 이렇게 프로미스 객체를 만들어서 사용할 때, res는 unknown 타입이 된다. 그 이유는 new Promise()는 타입 매개변수를 받는 제네릭 타입이다.
    ```ts
    new Promise<T>((resolve, reject) => {...})
    ```
    - 따라서 resolve의 타입은 기본적으로 아래와 같다.
    ```ts
    resolve(value: T | PromiseLike<T>): void
    ``` 
    - 즉, 타입변수 T를 지정해주지 않으면 unknown 타입으로 추론되는 것이다. number 타입으로 추론하게 하려면 new Promise<number>.. 와 같이 타입변수를 지정해주면 res가 number로 정확하게 추론된다.
- 이제 프로미스가 실패할 때를 살펴보자
    ```ts
    const promise = new Promis<number>((resolve, reject) => {
        setTimeout(() => {
            reject('~~때문에 실패');
        }, 3000);
    })

    promise.then((res) => {
        console.log(res * 10);
    }).catch(err => {
        if (typeof err === 'string') {
            console.log(err);
        }
    })
    ```
    - reject의 매개변수는 선택적 프로퍼티에다가 any 타입이여서 어떤 타입의 값이 올 수 있고 안와도 된다. 또한 catch메서드의 매개변수 타입도 any타입이다. 

- 중간 정리하자면 Promise의 resolve는 제네릭 타입변수 T에 의해 결정되며, T를 지정하지 않으면 unknown으로 추론된다. 반면 reject는 별도의 타입 매개변수를 가지지 않아 기본적으로 any 타입이다. (제네릭으로 제어할 수 없음)

#### 프로미스를 반환하는 함수의 타입을 정의
- 서버로부터 하나의 게시글의 데이터를 불러오는 함수를 만든다고 가정
```ts
interface Post {
    id: number;
    title: string;
    content: string;
}

function fetchPost(): Promise<Post> {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve({
                id:1,
                title: '게시글',
                content: '게시글 내용'
            });
        }, 3000);
    })
}

const postRequest = fetchPost();

postRequest.then((post) => {
    post.id;
})
```
- 이때 new Promise<Post>로 해줄 수 있지만 협업의 관점으로 볼 때 함수의 반환값 타입을 직접 정의하는 방식이 더 선호된다.

## section 8

### 타입 조작하기
- 타입을 조작한다는 것은 기본 타입이나 타입 별칭 또는 인터페이스로 만든 원래 존재하던 타입들을 상황에 따라 유동적으로 다른 타입으로 변환하는 기능이다.

- 이전 시간에 배운 제네릭도 함수나 인터페이스, 타입 별칭, 클래스 등에 적용해서 상황에 따라 달라지는 가변적인 타입을 정의할 수 있기 때문에 타입 조작에 해당한다.

- 제네릭 외에도 타입 조작하기는 다음과 같다

- 제네릭, 인덱스드 엑세스 타입, keyof 연산자, Mapped(맵드)타입, 템플릿 리터럴 타입, 조건부 타입

- 먼저 인덱스드 엑세스 타입부터 알아보자

### 인덱스드 엑세스 타입
- 인덱스를 이용해서 다른 타입내에 특정 프로퍼티 타입을 추출하는 타입이다.
    ```ts
    interface Post {
        title: string;
        content: string;
        author: {
            id: number;
            name: string;
        }
    }

    function printAuthorInfo(author: Post['author']) {
        console.log(`${author.name}-${author.id}`)
    }

    const post: Post = {
        title: '게시글 제목',
        content: '게시글 본문',
        author: {
            id: 1,
            name: '이정환',
        }
    }
    ```
    - author: Post['author'] 이런식으로 작성하면 author의 타입이 Post 인터페이스의 author의 타입이 된다. 즉, printAuthorInfo의 매개변수 author는 Post의 author타입을 갖게 되는 것이다.
    - Post['author'] 이부분을 인덱스트 엑세스 타입이라고 부르는데 대괄호 안의 'author' 이 string 리터럴 타입을 특별히 인덱스라고 부른다. 
    - 이 인덱스를 이용해서 특정 타입의 프로퍼티에 접근한다고 하여 인덱스드 엑세스 타입으로 부르는 것이다.

    - 주의 사항으로는 인덱스에는 변수는 사용하지 못하고, 타입만 작성할 수 있다.

    ```ts
    function getId(id: Post['author']['id']) {
        console.log(`${author.id} 가져옴`)
    }
    ```
    - 이때 id는 number 타입으로 추론된다. 이런식으로 중첩된 프로퍼티 접근도 가능하다. 

    ```ts
    type PostList = Post[];
    type Item = PostList[number];
    ```
    - 이렇게 위에서 정의한 Post의 배열타입인 PostList타입이 있을 때, 이 배열 요소의 타입 하나를 추출하려면 PostList[number]; 와 같이 사용하면 된다. 즉, Item 타입은 Post 타입을 가지게 된다.

    ```ts
    type Tuple = [number, string, boolean];

    type A = Tuple[0]; // A는 number 타입
    type B = Tuple[1]; // B는 string 타입
    type C = Tuple[2]; // C는 boolean 타입
    type D = Tuple[number]; // string | number | boolean
    ```
    - 이처럼 튜플 타입의 각 요소 타입 추출할 수 있다. 

### keyof 연산자
- keyof 연산자는 객체 타입으로부터 프로퍼티의 모든 key들을 string 리터럴 타입으로 추출하는 연산자이다.
    ```ts
    interface Person {
        name: string;
        age: number;
    }

    function getPropertyKey(person: Person, key: keyof Person) {
        return person[key];
    }

    const person: Person = {
        name: '123',
        age: 27,
    }
    ```
    - 이렇게 keyof 연산자를 사용하면 해당 key의 타입을 'name' | 'age'처럼 유니온 타입으로 추출한다.
    - 주의 사항으로는 keyof 연산자는 타입에만 적용할 수 있다. 
    - 마지막으로 타입스크립트에서 typeof는 자바스크립트에서 동작하는 것과 달리 어떤 변수의 타입을 뽑아낼 수 있는데 keyof와 같이 조합해서 사용할 수 있다.
        ```ts
        type Person = typeof person;

        const person = {
            name: '123',
            age: 27,
        }
        ```
        - 이 의미는 person 변수의 타입을 추출해서 Person 타입에 넣으라는 의미이다.
        즉, Person타입은 {name:string; age:number;} 타입이 된다. 그렇다면 함수에서도 다음과 같이 쓸 수 있다.
        ```ts
        function getPropertyKey(person: Person, key: keyof typeof person) {
            return person[key];
        }
        ```
        - 이 의미는 typeof person을 통해 {name:string; age:number;}이 타입을 뽑아내고 {name:string; age:number;}이 타입에 keyof를 하면 'name' | 'age' 문자열 리터럴 타입이 추출된다.

### 맵드 타입
- 맵드 타입은 기존의 객체 타입을 기반으로 새로운 객체 타입을 만드는 기능이다.
    ```ts
    interface User {
        id: number;
        name: string;
        age: number;
    }

    type ParialUser = {
        // [key in 'id' | 'name' | 'age']?: User[key];
        readonly [key in keyof User]?: User[key];
    }

    function fetchUser(): User {
      return {
        id: 1,
        name: "이정환",
        age: 27,
      };
    }

    function updateUser(user: ParialUser) {
        // ... 유저 정보 수정 기능
    }

    updateUser({age: 25});
    ```
    - [key in “id” | “name” | “age”] 는 이 객체 타입은 key가 한번은 id,
    한번은 name, 한번은 age가 된다는 뜻이다. 
    - key가 “id” 일 때 -> id ?: User[id] → id : number
    - key가 “name”일 때 -> name ?: User[user] → name : string
    - key가 “age”일 때 -> age ?: User[age] → age : number
    - 즉, {id?: number; name?: string; age?: number;} 타입이 되는 것이다.

### 템플릿 리터럴 타입
- 템플릿 리터럴 타입은 템플릿 리터럴을 이용해 특정 패턴을 갖는 string 타입을 만드는 기능이다.
    ```ts
    type Color = "red" | "black" | "green";
    type Animal = "dog" | "cat" | "chicken";

    type ColoredAnimal = `${Color}-${Animal}`
    ```
    - ColoredAnimal은 Color과 Animal의 조합으로 만들 수 있는 모든 가지수의 문자 리터럴 타입을 유니온 타입으로 만든 것이다.

## section 9

### 조건부 타입
- 조건부 타입은 extends와 삼항 연산자를 이용해 조건에 따라 따라 각각 다른 타입을 정의하도록 돕는 문법이다.
    ```ts
    type A = number extends string ? number : string;
    ```
    - 조건부 타입은 위 코드 처럼 number extends string ? 과 같은 조건식이 있고 이 조건이 참이라면 ? 우측의 타입인 Number 타입이 결과가 되고 아니라면 : 우측의 타입인 String 타입이 결과가 된다.
    
    ```ts
    type ObjA = {
        a: number;
    };

    type ObjB = {
        a: number;
        b: number;
    };

    type B = ObjB extends ObjA ? number : string;
    ```
    - 이때 B의 타입은 ObjB는 ObjA의 서브 타입 이므로 조건식이 참이되어 number 타입이 된다.

### 제네릭 조건부 타입
- 조건부 타입은 제네릭이랑 사용할 수 있다.
    ```ts
    type StringNumberSwitch<T> = T extends number ? string : number;

    let varA: StringNumberSwitch<number>;
    // string

    let varB: StringNumberSwitch<string>;
    // number
    ```
    - varA는 T에 number 타입을 할당하고, 그 결과 조건식이 참이 되어 string 타입이 된다.
    varB는 조건식이 거짓이 되어 number 타입이 된다.

    ```ts
    function removeSpaces<T>(text: T): T extends string ? string : undefined;
    function removeSpaces(text: any) {
    if (typeof text === "string") {
        return text.replaceAll(" ", "");
    } else {
        return undefined;
    }
    }

    let result = removeSpaces("hi im winterlood");
    // string

    let result2 = removeSpaces(undefined);
    // undefined
    ```
    - 오버로드 시그니처를 통해 removeSpaces 함수가 T타입 변수가 string을 확장하면 string, 그렇지 않으면 undefined 타입을 사용한다고 선언한다.
    - 그리고 해당 함수에서 매개변수 text의 타입은 기본적으로 any타입이지만 string 타입을 확장하면 string, 그게 아니라면 undefined 타입이 된다. 따라서 이 함수는 string or undefined 타입만 반환할 수 있다.

### 분산적인 조건부 타입
```ts
type StringNumberSwitch<T> = T extends number ? string : number;

let a: StringNumberSwitch<number>;

let b: StringNumberSwitch<string>;

let c: StringNumberSwitch<number | string>; // c의 타입은 number | string
```
- 분산적 조건부 타입은 제네릭을 통해 <number | string>을 넘겨주면 한 번은 number가 들어가고 한 번은 string이 들어가서 그 결과들이 유니온으로 묶인다.
- StringNumberSwitch<number> | StringNumberSwitch<string>
- number | string가 되는 것이다.

### infer
- infer는 조건부 타입 내에서 특정 타입을 추론하는 문법이다.
    ```ts
    type ReturnType<T> = T extends () => infer R ? R : never;

    type FuncA = () => string;

    type FuncB = () => number;

    type A = ReturnType<FuncA>;
    // string

    type B = ReturnType<FuncB>;
    // number
    ```
    - 조건식 T extends () => infer R에서 infer R은 이 조건식을 참이 되도록 만들 수 있는 최적의 R 타입을 추론하라는 의미이다.
    - 따라서 A 타입을 계산할 때의 위 코드의 흐름은 다음과 같다.
        - 타입 변수 T에 함수 타입 FuncA가 할당된다.
        - T는 () ⇒ string 이 된다.
        - 조건부 타입의 조건식은 다음 형태가 된다.  () ⇒ string extends () ⇒ infer R ? R : never
        - 조건식을 참으로 만드는 R 타입을 추론 합니다 그 결과 R은 string이 된다.
        - 추론이 가능하면 이 조건식을 참으로 판단합니다 따라서 결과는 string이 된다. 만약 다음과 같이 추론이 불가능하다면 조건식을 거짓으로 판단한다.
 
## section 10

### 유틸리티 타입
- 제네릭, 맵드 타입, 조건부 타입 등의 타입 조작 기능을 이용해 실무에서 자주 사용되는 타입을 미리 만들어 놓은 것

    #### Partial<T>
    - 특정 객체 타입의 모든 프로퍼티를 선택적 프로퍼티로 바꿔주는 타입
    ```ts
    interface Post {
        title: string;
        tags: string[];
        content: string;
        thumbnailURL?: string;
    }

    const draft: Partial<Post> = {
        title: '임시글1',
        conetent: '초안...',
    }
    ```
    - 이와 같이 임시 저장된 글을 표현하는 draft 객체가 있을 때, 이 글은 아직 미완성 글이기 때문에 content, thumbnailURL과 같은 데이터가 없다. draft는 Post 타입을 사용해야하는데 이때 content가 없어서 에러가 나기에 모든 프로퍼티를 선택적 프로퍼티로 바꿔주는 Partial을 사용할 수 있다. Partial<Post>와 같은 형태로 작성하면 타입 변수로 전달한 Post의 모든 프로퍼티는 선택적 프로퍼티가 된다.
    - Partial 타입은 다음과 같이 구현할 수 있다.
        ```ts
        type Partial<T> = {
            [key in keyof T]?: T[key];
        };
        ```
        - 여기서 keyof 연산은 특정 객체 타입으로부터 모든 키를 유니온 타입으로 추출한다. 즉, 타입변수 T가 Post라면 keyof T는 'title |  tags | content | thumbnailURL'이 된다. 또 in 연산자는 왼쪽의 key가 오른쪽의 유니온 타입에 하나씩 매핑이 된다. 따라서 Post 타입의 프로퍼티 키를 하나씩 추출하는 것이다. 이를 각 프로퍼티 키의 결과값으로 그대로 매핑하되 선택적 프로퍼티로 적용하여 매핑하는 원리이다.

    #### Required<T>
    - 특정 객체 타입의 모든 프로퍼티를 필수 프로퍼티로 바꿔주는 타입

    ```ts
    const withThubnailPost: Required<Post> = {
        title: '게시글1',
        tags: ['ts'],
        content: '게시글1 내용',
        thumbnailURL: 'https://...',
    }
    ```
    - 위의 withThubnailPost은 썸네일이 포함된 글을 표현하는 객체이다. 이 객체는 반드시 thumbnailURL을 가지고 있어야하는데 Post타입에서는 선택적 프로퍼티로 적용되어있다. 이를 위해 모든 프로퍼티를 필수 프로퍼티로 바꿔주는 Required<Post>를 사용할 수 있다. 동작 원리는 Partial과 동일하다.
        ```ts
        type Required<T> = {
            [key in keyof T]-?: T[key];
        };
        ```
        - -? 는 ?로 선택적 프로퍼티인 프로퍼티에서 ?를 빼겠다는 말이다. (즉 선택적 프로퍼티 해제와 같음) 타입스크립트의 매핑된 타입에서는 프로퍼티 한정자를 제거하거나 추가할 수 있다.
            - +? 또는 ?: 는 선택적 한정자 추가 (Partial<T>에서 사용)
            - -?: 선택적 한정자 제거 (선태적 -> 필수로 변환)
            - -readonly: 읽기 전용 한정자 제거

    #### Readonly<T>
    - 특정 객체 타입에서 모든 프로퍼티를 읽기 전용 프로퍼티로 만들어주는 타입

    ```ts
    const readonlyPost: Readonly<Post> = {
        title: '보호된 게시글',
        tags: ['ts'],
        content:'123',
    };

    readonlyPost.title = '수정'; // 에러 
    ```
    - readonlyPost와 같이 수정이 불가능한 게시글이 있다면 Readonly<Post>와 같이 사용할 수 있다. Post의 모든 프로퍼티를 readonly로 만들어준다.
        ```ts
        type Readonly<T> = {
            readonly [key in keyof T]: T[key];
        };
        ```
        - 위 Partial, Required와 동작 원리를 동일하다. 앞의 readonly 키워드만 붙었다.

    #### Pick<T, K>
    - 객체 타입으로부터 특정 프로퍼티만 딱 골라내는 타입
    ```ts
    const legacyPost: Pick<Post, 'title' | 'content'> = {
        title: '태그 기능이 없던 시절 만들어진 게시글',
        content: '123',
    }
    ```
    - Pick을 사용하면 위와 같이 Post 타입에서 title, content타입만 적용된 타입을 legacyPost 객체의 타입으로 지정해줄 수 있다. 동작원리는 다음과 같다.
        ```ts
        type Pick<T, K extends keyof T> = {
            [key in K]: T[key]; 
        }
        ```
        - 이 코드에서 K에 있는 속성 이름들이 실제로 T 타입에 존재하는지 확신할 수 없기에 K extends keyof T를 통해 K가 반드시 T 타입의 키들의 부분 집합이어야 함을 명시해야 오류가 사라진다. 즉, K에 있는 타입이 T에도 있어야하기에 extends keyof T를 통해 K 타입에 제약을 걸어준 것이다.

    #### Omit<T, K>
    - 객체 타입으로부터 특정 프로퍼티를 제거한 타입

    ```ts
    const noTitlePost: Omit<Post, 'title'> = {
        content: '제목 없는 게시글',
        tags:['ts'],
        thumbnailURL:'https://...',
    }
    ```
    - 이제 noTitlePost객체의 타입은 Post 타입으로부터 title 타입만 제거한 타입이 된다. Pick 타입으로도 작성할 수 있지만, 제거하지 않는 프로퍼티가 많아진다면 가독성이 좋지 않아지므로 Omit 타입을 사용하는게 좋다. 동작원리는 다음과 같다.
        ```ts
        type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>

        // T = Post, K = 'title'
        // Pick<Post, Exclude<keyof Post, 'title'>>
        // Pick<Post, Exclude<'title' | 'content' | 'tags' | 'thumbnialURL', 'title>>
        // Pick<Post, 'content' | 'tags' | 'thumbnialURL'>
        // 결과적으로 해당 타입은 Post의 'content' | 'tags' | 'thumbnialURL'만 갖게 되는 타입이 된다.
        ```

    #### Record<K, V>
    - 키 타입이 K의 유니온 타입이고, 값 타입이 T인 객체타입을 생성하는 타입 즉, 인덱스 시그니처의 조금 더 엄격한 버전이다.

    ```ts
    type ThumbnailLegacy = {
        large: {
            url: string;
            size: number;
        },
        medium: {
            url: string;
            size: number;
        },
        small: {
            url: string;
            size: number;
        },
        watch: {
            url: string;
            size: number;
        },
        ...: {
            ...
        }
    }

    type Thumbnail = Record<'large' | 'medium' | 'small' | 'watch', {url: string, size: number}>
    ```
    - 이처럼 인덱스 시그니처와 같이 K, 즉, 프로퍼티 키와, V, 해당 키가 가질 타입을 지정해주면 형식에 맞는 타입이 생성된다. Thumbnail과 ThumbnailLegacy은 같은 코드이다. 동작 원리는 다음과 같다.
        ```ts
        type Record<K extends keyof any, V> = {
            [key in K]: V
        }
        ```
        - 해당 K에는 extends keyof any가 있는데 이것은 어떤 객체 타입의 키를 추출한 유니온 타입이라고 말해주는 것이다. 따라서 그 추출한 유니온 타입 K:V 형태와 같이 인덱스 시그니처 형태로 정의해줄 수 있다.

    #### Exclude<T, U>
    - T에서 U를 제거하는 타입
    
    ```ts
    type A = Exclude<string | boolean, boolean>;
    ```
    - 이처럼 해당 string | boolean 유니온 타입에서 boolean 타입만 제거하는 것이다. A 타입은 string이 된다. 동작원리는 다음과 같다.
        ```ts
        type Exclude<T, U> = T extends U ? never : T;
        // 1단계
        // Exclude<string, boolean>
        // Exclude<boolean, boolean>

        // 2단계
        // string |
        // never

        // 최종적으로는
        // string | never 
        // -> string
        ```

    #### Extrack
    - T에서 U를 추출하는 타입

    ```ts
    type B = Extract<string, boolean, boolean>;
    ```
    - 여기서 B 타입은 boolean 타입이 된다. 동작원리는 다음과 같다.
        ```ts
        type Extract<T, U> = T extends U ? T : never;
        ```

    #### Return Type
    - 함수의 반환값 타입을 추출하는 타입

    ```ts
    function funcA() {
        return 'hello';
    }

    function funcB() {
        return 10;
    }

    type ReturnA = ReturnType<typeof funcA>
    type ReturnB = ReturnType<typeof funcB>
    ```

    - 여기서 ReturnA는 funcA의 반환값 타입인 string 타입이 되고, ReturnB는 funcB의 반환값 타입인 number 타입이 된다. 동작원리는 다음과 같다.

        ```ts
        type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => inter R ? R : never;
        ```
        - 여기서 T는 반드시 함수 타입이어야 한다는 제약 조건이 붙는다. 어떤 타입이든 반환하는 함수 타입이어야 함을 의미한다. 그리고 T가 infer R이 추론한 타입을 확장하도록 제약한다. 즉, infer R을 통해 T가 () => string이라면 R은 string으로 추론하는데, 이때 조건이 참이면 string, 거짓이면 never 타입을 반환하는 것이다. 즉, typeof funcA가 T가 되는데 이때 T는 () => string이 된다. 그리고 이걸 추론하는 R은 string이 되어서 결과적으로 ReturnA는 string 타입이 된다.

## section 11

### 타입스크립트 리액트 시작하기

- 타입스크립트를 리액트 프로젝트에 적용할 때는 다음과 같은 tsconfig.json 설정이 필요하다.

```json
{
  "compilerOptions": {
    // 1. React 필수 설정
    "jsx": "react-jsx", // 또는 "react" (레거시)
    "lib": ["dom", "dom.iterable", "esnext"], 
    "esModuleInterop": true,
    
    // 2. 모듈 및 코드 생성
    "module": "esnext", // 모듈 시스템을 ES Modules로 지정
    "target": "es2020", // 목표 JS 버전 (현대 브라우저 기준)
    "moduleResolution": "node", // 모듈 해석 방식 (Webpack, Vite 등 Node 생태계에 맞춰 설정)
    "allowSyntheticDefaultImports": true, // 기본 내보내기가 없는 모듈에서 기본 가져오기를 허용
    
    // 3. 타입 검사 및 엄격성
    "strict": true, // 모든 엄격한 타입 검사 옵션을 활성화 (권장)
    "skipLibCheck": true, // 라이브러리(.d.ts) 파일의 타입 검사를 건너뜀 (속도 향상)
    "forceConsistentCasingInFileNames": true, // 파일명 대소문자 일치 강제
    
    // 4. 출력 및 파일 지정
    "outDir": "./dist", // 컴파일된 JS 파일이 저장될 디렉터리 (필요하다면)
    "rootDir": "./src" // 소스 파일이 있는 루트 디렉터리
  },
  "include": ["src/**/*"], // 컴파일에 포함할 파일 경로 지정
  "exclude": ["node_modules", "dist"] // 컴파일에서 제외할 파일 경로 지정
}
```

- 요즘에는 vite로 프로젝트를 구성해서 tsconfig.json를 직접 건드리는일이 없었는데, js로 되어있는 프로젝트를 타입스크립트로 마이그레이션 할 때 알아두면 좋을 것 같다. 필수 설정은 다음과 같다.

- jsx: 'react-jsx' -> 이 설정은 import React from 'react' 없이도 jsx 코드를 사용할 수 있게 해준다.
- lib: [...] -> 이 설정은 React가 브라우저에서 실행되므로 DOM API 타입을 인식할 수 있도록 'dom'을 반드시 포함해야 한다.
- strict: true -> 타입 안정성을 위해 대부분의 경우 무조건 활성화하는 것을 권장한다.

### 상태관리와 Props

#### useState
- useState는 리액트에서 상태관리를 위해 필요한 훅이다. 해당 훅은 아래와 같이 사용한다.
```tsx
const [state, setState] = useState();
```
- 하지만 이렇게는 tsx파일에서 오류가 발생한다. useState에 초기값이 없기 때문인데, 마땅히 설정할 기본값이 없다면 이때는 useState<string>(); 과 같은 방식으로 타입 변수를 제네릭 형태로 넘겨줘야 한다. useState의 타입은 제네릭으로 구현되어있기 때문이다. 하지만 그렇게 되면 string | undefined 로 타입을 추론하기 때문에 초기값으로 어떤 값이든 넣는게 더 좋은 방식이다. 이유는 불필요한 undefined 체크를 피할 수 있어서 코드를 더 간결하고 안전하게 만들기 때문이다.
```tsx
const [state, setState] = useState(); // bad, error
const [state, setState] = useState<string>(); // not bad
const [state, setState] = useState(""); // good
```

#### onChange와 같은 이벤트 객체 타입
- 리액트에서는 이벤트객체 타입을 가져다 사용할 수 있다. 따라서 다음과 같이 작성할 수 있다.

```tsx
const [text, setText] = useState("");

const handleChangeInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    setText(e.target.value);
}
```