# **섹션 6. 클래스**

## **0. 자바스크립트의 클래스 소개**

### 실습 환경 세팅

```json
{
  "compilerOptions": {
	  ...
	  "allowJs": true    // src 디렉토리 내에 js 파일 존재 허용
	},
	"include": ["src"]
}
```

### **자바스크립트의 클래스**

- 클래스: 동일한 모양의 객체를 더 쉽게 생성하도록 도와주는 문법
- 학생을 객체로 표현 → 한명의 학생이 더 필요하다면 다음과 같이 새로운 변수를 만들어야 함 → 중복 코드 발생

### **클래스 선언하기**

- 클래스 선언은 Pascal 표기법 사용
- 클래스 안에서는 쉼표를 찍지 않음
- 필드
    - 클래스가 생성할 객체가 갖는 프로퍼티
- 생성자
    - 특수한 메서드로 실질적으로 객체를 생성하는 함수
    - 매개변수로 프로퍼티 값을 받아 this.프로퍼티의 값으로 할당

```jsx
class Student {
  // 필드
  name;
  grade;
  age;

  // 생성자
  constructor(name, grade, age) {
    this.name = name;
    this.grade = grade;
    this.age = age;
  }

  // 메서드
  study() {
    console.log("열심히 공부 함");
  }

  introduce() {
    console.log(`안녕하세요!`);
  }
}

// 클래스를 이용해서 만든 객체 -> 인스턴스
// Student 인스턴스
let studentB = new Student("홍길동", "A+", 27);

studentB.study(); // 열심히 공부 함
studentB.introduce(); // 안녕하세요!
```

### this 활용하기

- 클래스 내부에서 this: 현재 만들고 있는 객체를 의미

```jsx
class Student {
  (...)

  introduce() {
    console.log(`안녕하세요 ${this.name} 입니다!`);
  }
}

let studentB = new Student("홍길동", "A+", 27);

studentB.introduce(); // 안녕하세요 이정환 입니다!
```

### 상속

- super 메서드 호출 필요
- super를 호출하고 인수로 name, grade, age를 전달하면 슈퍼 클래스(확장 대상 클래스)의 생성자를 호출

```jsx
class StudentDeveloper extends Student {
  // 필드
  favoriteSkill;

  // 생성자
  constructor(name, grade, age, favoriteSkill) {
    super(name, grade, age);
    this.favoriteSkill = favoriteSkill;
  }

  // 메서드
  programming() {
    console.log(`${this.favoriteSkill}로 프로그래밍 함`);
  }
}
```

## **1. 타입스크립트의 클래스**

```jsx
{
  "compilerOptions": {
	  ...
	  "noImplicitAny": false    // any 허용, 안전하지 않음
	},
}
```

```jsx
class Employee {
  // 필드
  name: string = "";         // 생성자 함수에서 필드 값 잘 초기화 해 준다면 초기값 생략 가능
  age: number = 0;
  position?: string = "";    // 선택적 프로퍼티

  // 생성자
  constructor(name: string, age: number, position: string) {
    this.name = name;
    this.age = age;
    this.position = position;
  }

  // 메서드
  work() {
    console.log("일함");
  }
}
```

### **클래스는 타입**

타입스크립트의 클래스는 타입으로도 사용 가능

```jsx
class Employee {
  (...)
}

const employeeC: Employee = {
  name: "",
  age: 0,
  position: "",
  work() {},
};
```

### 상속

- super 메서드를 호출해 슈퍼 클래스(확장되는 클래스)의 생성자를 호출
- 호출 위치는 생성자의 최상단

```jsx
class ExecutiveOfficer extends Employee {
  officeNumber: number;

  constructor(
    name: string,
    age: number,
    position: string,
    officeNumber: number
  ) {
    super(name, age, position);
    this.officeNumber = officeNumber;
  }
}
```

## 2. 접근 제어자

- 클래스의 특정 필드나 메서드를 접근할 수 있는 범위를 설정하는 기능

### public

- 어디서든지 이 프로퍼티에 접근할 수 있음을 의미
- 아무 것도 안 쓰면 public

```jsx
class Employee {
  // 필드
  public name: string;
  public age: number;
  public position: string;

  ...
}

const employee = new Employee("이정환", 27, "devloper");

employee.name = "홍길동";
employee.age = 30;
employee.position = "디자이너";
```

### private

- 메서드의 접근 제어자를 private으로 설정하면 클래스 내부에서만 이 필드에 접근

```jsx
class Employee {
  // 필드
  private name: string; // private 접근 제어자 설정
  public age: number;
  public position: string;

  ...

  // 메서드
  work() {
    console.log(`${this.name}이 일함`); // 여기서는 접근 가능
  }
}

const employee = new Employee("이정환", 27, "devloper");

employee.name = "홍길동"; // ❌ 오류
employee.age = 30;
employee.position = "디자이너";
```

### protected

- 외부에서는 접근이 안되지만 클래스 내부와 파생 클래스에서 접근이 가능하도록 설정하는 접근 제어자

```jsx
class Employee {
  // 필드
  private name: string; // private 접근 제어자 설정
  protected age: number;
  public position: string;

  ...

  // 메서드
  work() {
    console.log(`${this.name}이 일함`); // 여기서는 접근 가능
  }
}

class ExecutiveOfficer extends Employee {
 // 메서드
  func() {
    this.name; // ❌ 오류 
    this.age; // ✅ 가능
  }
}

const employee = new Employee("이정환", 27, "devloper");

employee.name = "홍길동"; // ❌ 오류
employee.age = 30; // ❌ 오류
employee.position = "디자이너";
```

- 접근 제어자가 설정된 매개변수들은 `this.필드 = 매개변수가` 자동으로 수행

```jsx
class Employee {
  // 생성자
  constructor(
    private name: string,
    protected age: number,
    public position: string
  ) {
  /*
	  this.name = name;
    this.age = age;
    this.position = position;
  */
  }

  // 메서드
  work() {
    console.log(`${this.name} 일함`);
  }
}
```

## **3. 인터페이스와 클래스**

```jsx
interface CharacterInterface {
  name: string;
  moveSpeed: number;
  move(): void;
}

class Character implements CharacterInterface {
  constructor(
    public name: string,
    public moveSpeed: number,
    private extra: string
  ) {}

  move(): void {
    console.log(`${this.moveSpeed} 속도로 이동!`);
  }
}
```

# **섹션 7. 제네릭**

# **섹션 8. 타입 조작하기**

# **섹션 9. 조건부 타입**

# **섹션 10. 유틸리티 타입**
