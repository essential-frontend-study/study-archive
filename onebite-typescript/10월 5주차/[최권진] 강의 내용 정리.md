## section 1

### 타입스크립트의 특징
- 타입스크립트는 자바스크립트의 슈퍼셋이다.
- 타입스크립트는 독특한 타입 시스템(점진적 타입 시스템)을 갖는다. 따라서 직접 타입을 지정할 수도 있고 자동으로 타입을 추론하도록 타입스크립트에게 맡길 수 있다 (타입 추론)

### 타입스크립트의 동작원리
- 타입스크립트는 자바스크립트로 변환된다.
    - 타입스크립트로 작성된 코드를 컴파일 하면, 타입스크립트 코드가 AST로 변환되고, AST에서 타입 검사가 성공하면 자바스크립트 코드로 변환한다. 타입 검사가 실패하면 컴파일이 에러를 던지며 종료된다.
    - TS에서 JS로 변환된 코드는 브라우저/Node에서 일반 JS 코드처럼 실행된다. (JS -> AST -> Byte Code -> Run)
    - 즉, 타입스크립트에서 작성된 타입 관련 코드들은 컴파일 시 삭제된다.
        ```ts
        const a: number = 1;
        console.log(a);
        ```
        - 이 코드는 다음과 같이 변환된다.
        ```js
        var a = 1;
        console.log(a);
        ```
    - 컴파일을 하는 명령어는 다음과 같다.
        ```bash
        tsc src/index.ts
        ```
    - 이 명령어를 작성하면 index.ts파일을 컴파일 과정을 통해 자바스크립트로 변환하고 폴더에 index.js 파일이 생긴다.
    - 하지만 이런식으로 매번 컴파일 하고 컴파일 한 index.js를 실행하는 건 번거롭다. 다음 방법을 통해 쉽게 ts파일을 실행해보자
        ```bash
        tsx src/index.ts
        ```

### 컴파일러 설정

    ```bash
    tsc --init

    ```
- 이 명령어를 작성하면 tsconfig.json이 만들어지고 해당 파일에서 컴파일러 설정을 할 수 있다.
    ```bash
    {
        include: -> 컴파일할 폴더 및 파일 설정
        CompilerOptions: {
            "target": 컴파일 되는 자바스크립트 버전을 설정
            "module": module 옵션 설정
            "outdir": 컴파일된 파일들 경로 설정
            "strict": 엄격한 타입 검사
            "strictNullChecks": 엄격한 null 검사, 즉 다른 타입에 null값을 허용할 수 있는지 설정
            "moduleDetection": 각각의 파일을 독립 모듈로 설정
        }
    }

    ```
   
## section 2

### 기본 타입

#### 원시 타입
```ts
const a: number = 1;
const b: string = 'hello';
const c: boolean = true;
const d: null = null;
const e: undefined = undefined;
```
- 여기서 ": number"를 타입 주석 혹은 타입 어노테이션이라고 부른다. (타입을 정의하는 가장 기본적인 방식)

#### 리터럴 타입
- 리터럴 타입: 값으로도 타입을 정의할 수 있게 해준다.
```ts
const a: 10 = 10;
const b: 'hello' = 'hello';
const c: true = true;
```

### 배열 타입
```ts
const a: number[] = [1, 2, 3];
const b: string[] = ['1', '2', '3'];
const c: Array<boolean> = [true, false, true];

const d: (string | number)[] = [1, 'hello'];
const e: number[][] = [
    [1, 2, 3],
    [4, 5],
]
```

### 튜플 타입
```ts
const a: [number, number] = [1, 2];
```
- 튜플 타입을 이용해서 배열의 타입과 길이를 모두 정할 수 있다.
- 튜플 타입은 값을 넣는 순서가 중요할 때 유용하게 사용할 수 있다.
    ```ts
    const users: [string, number][] = [
        ['이정환', 1],
        ['김정환', 2],
        [3, '최정환'] // 에러
    ]
    ```
- 튜플 타입에서 배열 메서드를 이용해서 배열을 조작해도 타입스크립트는 이를 감지하지 못한다. 따라서 주의해서 사용해야 한다.

### 객체 타입
```ts
 const a: {
    id?: number;
    readonly name: string;
 } = {
    id: 1,
    name: '이정환',
 }
```
- 객체 타입을 정의할 땐 객체 리터럴 타입을 사용할 수 있다.
- 이떄 ?를 :앞에 붙이면 옵셔널 프로퍼티를 설정할 수 있다. 선택적으로 있어도 되고 없어도 되는 프로퍼티에 보통 사용한다.
- 또한 프로퍼티 앞에 readonly 키워드를 작성해주면 프로퍼티의 값을 바꾸지 못하게 막아준다.

#### 타입 별칭
```ts
type User = {
    id: number;
    name: string;
    bio: string;
}

const a: User = {
    id: 0,
    name: '이정환',
    bio: '안녕하세요',
}
```
- 이처럼 타입 별칭을 이용하면 User라는 타입을 사용하는 코드에 동일하게 적용할 수 있다.
- 즉 타입 정의에 대한 중복을 줄이고 재사용할 수 있게 된다.

#### 인덱스 시그니처
- key, value의 타입을 이용하여 규칙을 통해 타입을 정의하는 방식이다.
    ```ts
    type Country = {
        [key: string]: string;
    }

    const a: Country = {
        Korea: 'ko',
        UnitedState: 'us',
        UnitedKingdom: 'uk',
    }
    ```
    - 이렇게 작성하면 앞으로 추가 될 국가들의 key, value타입이 모두 string인지 검사하게 된다.

### Enum
- Enum 타입은 여러 개의 값에 이름을 부여해 열거형 상수 집합처럼 사용하는 타입이다.
    ```ts
    enum Role {
        ADMIN,
        USER,
        GUEST,
    }

    const user1: Role = {
        name: '이정환',
        role: Role.ADMIN,
    }
    ```
    - 이처럼 각 유저마다 권한을 설정할 때 사용할 수 있다. 하지만 enum은 단점이 존재한다.
    <details>
    <summary>enum 단점과 대체방법</summary>

    - 컴파일을 해도 enum은 사라지지 않고 런타임 코드에 남고, 트리쉐이킹이 잘 되지 않는다. 따라서 리액트 프로젝트에서는 다음과 같이 사용했었다.
        ```ts
        const Role = {
            ADMIN: 0,
            USER: 1,
            GUEST: 2,
        } as const;

        type Role = (typeof Role)[keyof typeof Role];
        // 바꿔 표현하면 type Role = (Role)["ADMIN" | "USER" | "GUEST"]
        // -> type Role = Role["ADMIN"] | Role["USER"] | Role["GUEST"]
        // -> type Role = 0 | 1 | 2;

        const user1: Role = {
            name: '이정환',
            role: Role.ADMIN,
        }
        ```
        - 먼저 Role 객체에 as const를 하는 이유는 객체의 모든 프로퍼티가 상수로 고정되고 readonly 속성이 붙어서 수정할 수 없게 된다. as const를 붙이지 않으면 타입스크립트는 자동 추론을 통해 number타입이라고 인식하기 때문에 as const를 붙이는 것이다. as const 결과는 아래와 같다.
            ```js
            const Role = {
                readonly ADMIN: 0,
                readonly USER: 1,
                readonly GUEST: 2,
            }
            ```
        - (typeof Role)[keyof typeof Role] 이 문법은 Role 객체의 값들로부터 타입을 전부 추출하는 문법이다.
            1. typeof Role을 하게 되면 Role 객체의 값의 타입을 가져올 수 있다. 
            2. keyof typeof Role을 하게 되면 keyof는 객체의 키들을 문자열 리터럴로 묶은 유니언 타입을 만들어준다.
            3. 즉 (typeof Role)[keyof typeof Role]이라는 문법은 Role 객체에서 모든 키의 값 타입을 꺼내서 하나의 유니언 타입으로 만드는 것이다.
            4. 최종적으로 type Role = 0 | 1 | 2 가 된다.
    </details>

### any
- any 타입은 타입 검사를 받지 않는 치트키 타입이다. 
    ```ts
    let a: any = 1;
    a = '1';
    a = {};
    a.toUpperCase();

    let b: string;

    a = 'hello'; // string -> any 가능
    b = a; // any -> string 가능
    ```
    - 이렇게 작성해도 타입스크립트에서 any는 타입 검사를 받지 않기 때문에 아무 문제 없어 보인다.
    - 또한 any는 모든 타입과 양방향으로 호환된다.
    - 하지만 코드를 실행하면 런타임에서 오류가 발생한다. 따라서 any타입을 사용하는것을 지양해야 한다.

### unknown
- unknown 타입도 any와 같이 어떤 타입의 값도 다 지정해줄 수 있다.
    ```ts
    let a: unknown = 1;
    a = '1';
    a = {};
    a.toUpperCase(); // 오류 발생 (타입 좁히기 필요)

    let b: string;

    a = 'hello'; // string -> unknown 가능
    b = a; // unknown -> string 불가능

    if (typeof a === 'string') {
        a.toUpperCase(); // 사용 가능
    }
    ```
    - 하지만 any와 다른점은 unknown 타입은 타입 좁히기를 통해 사용할 수 있기 때문에 any보다 더 안전하다.
    - 또한 any에서는 양방향 호환이 가능했지만 unknown에서는 타입을 받기만 할 수 있다.
    - 따라서 어떤 변수에 어떤 타입을 지정해야할지 모를때는 any 대신 unknown 타입을 사용하자.


### void
- void 타입은 아무런 값도 없음을 의미하는 타입이다. 보통 아무런 값도 반환하지 않는 함수의 반환값 타입을 정의할 때 사용한다.
    ```ts
    function fun1(): void {
        console.log(1);
    }
    ```
    - 이 함수는 아무런 값도 반환하고 있지 않다. 이러한 경우에 void 타입을 사용한다.
    - 변수 타입에서 void를 사용할 수 있는데 void 타입을 사용한 변수에는 undefined 이외에 아무 타입도 담을 수 없다.
        ```ts
        let a: void;
        a = undefined;
        a = 1; // 에러
        a = '1'; // 에러
        a = null; // strictNullChecks 옵션을 키면 null도 담을 수 있긴 하다.
        ```

### never
- never 타입은 불가능을 의미하는 타입이다. 보통 함수의 반환 값이 있을 수 없을 때(불가능) 사용한다.
    ```ts
    function fun1(): never {
        throw new Error('에러');
    }
    ```
    - 이처럼 에러를 발생시키는 함수는 반환값이 존재할 수가 없기 때문에 never 타입을 사용한다.
    - 변수에 never 타입을 지정하면 어떠한 값도 담을 수 없게된다.
        ```ts
        const a: never;
        a = 1; // 에러
        a = null; // 에러 strictNullChecks 옵션을 켜도 못담음
        ```

## section 3
### 슈퍼타입과 서브타입
```ts
let a: number = 1;
let b: 1 = 1;
```
- a 변수는 number 타입이다. b 변수는 number 리터럴 타입이다.
- 즉, number 리터럴 타입은 number 타입에 속한다고 볼 수 있다. (number 리터럴 타입 1은 number 타입의 가능한 값 중 하나로, 더 구체적인 값 집합을 가짐)
- 따라서 number 타입을 슈퍼타입, number 리터럴 타입을 서브 타입이라고 할 수 있다.

### 타입 호환성
```ts
let num1: number = 10;
let num2: 10 = 10;

num1 = num2; // 1번
num2 = num1; // 2번
```
- 타입스크립트는 구조적 타입 시스템을 사용해서, A 타입이 B 타입에 할당될 수 있는가를 값의 구조로 판단한다.
- 1번과 2번 코드는 어떨지 살펴보자. num1은 number 타입이고, num2는 number 리터럴 타입이다. 
- 즉 num1 = num2는 number 리터럴 타입(서브타입)을 number 타입(슈퍼타입)에 할당하는 것이기 때문에 가능하다.
- 반면에 num2 = num1은 number 타입을 number 리터럴 타입에 할당하는 것이기에 불가능하다.
- 결과적으로 서브 -> 슈퍼타입은 가능하지만 슈퍼 -> 서브타입으로 할당은 불가능하다. (단, 타입 단언, 타입 가드, 제네릭 등의 예외적인 경우에는 가능할 수 있다.)
- 서브 -> 슈퍼로 취급하는 것을 업 캐스팅이라고 하며, 슈퍼 -> 서브로 취급하는 것을 다운 캐스팅이라고 한다.

### 타입 계층도
![](https://buly.kr/G3E9vCM)
#### unknown
- unknown 타입은 타입 계층도의 최상단에 위치한다.
- 따라서 unknown 타입 변수에는 모든 타입의 값을 할당할 수 있다. 즉, 모든 타입은 unknown 타입으로 업 캐스트 할 수 있다.
```ts
let a: unknown = 1;
let a: unknown = '1';
let a: unknown = {};
let a: unknown = null;
```
- 등등 모든 타입을 unknown 타입에 할당 할 수 있다. (업 캐스팅)
- 반면 unknown 타입에 any를 제외한 모든 타입을 할당하는 것은 불가능하다. (다운 캐스팅)
```ts
let a: unknown = 5;
let b: number;
b = a // 에러
```

#### never
- never 타입은 계층도에서 최하위에 위치한다.
- 즉 모든 타입 -> never타입으로 다운 캐스팅은 불가능하지만, never -> 모든 타입으로 업 캐스팅은 가능하다.

#### void
- void 타입은 undefined의 슈퍼 타입이다.
    ```ts
    function noReturnFuncA(): void {
        return undefined;
    }
    ```
    - 이 코드가 오류가 나지 않는 이유는 void를 반환하는 함수가 undefined를 실제로 return 하더라도 undefined는 void의 서브 타입이기 때문에 오류가 나지 않는다고 볼 수 있다.
    ```ts
    let a: void;
    a = undefined; // undefined -> void 업 캐스팅 가능

    let b: never;
    b = a; // never -> void 업 캐스팅 가능  
    ```

#### any
- any 타입은 타입 계층도를 완전히 무시하는 치트키 타입이다. 즉, 모든 타입의 슈퍼 타입이 되거나, 모든 타입의 서브 타입이 될 수 있다.
    ```ts
    let any1: any;

    let num: number = any1; // any -> number 다운 캐스팅 가능
    let str: string = any1; // any -> string 다운 캐스팅 가능
    let bool: boolean = any1; // any -> boolean 다운 캐스팅 가능

    any1 = num; // number -> any 업 캐스팅 가능
    any1 = str; // string -> any 업 캐스팅 가능
    any1 = bool; // boolean -> any 업 캐스팅 가능
    ```

#### 객체 타입의 호환성
- 객체 타입의 호환성은 객체의 프로퍼티를 기준으로 판단한다.
    ```ts
    type Book = {
        name: string;
        price: number;
    };

    type ProgrammingBook = {
        name: string;
        price: number;
        skill: string;
    };

    let book: Book;
    let programmingBook: ProgrammingBook = {
        name: "한 입 크기로 잘라먹는 리액트",
        price: 33000,
        skill: "reactjs",
    }

    book = programmingBook; // OK
    programmingBook = book; // 에러
    ```
    - Book 타입은 name과 price을 가진다. ProgrammingBook 타입은 name, price, skill을 가진다.
    - 즉, ProgrammingBook 타입은 Book 타입이 될 수 있다. 하지만 Book 타입은 skill 프로퍼티가 없기 때문에 ProgrammingBook 타입이 될 수 없다.
    - Book 타입이 슈퍼 타입, ProgrammingBook 타입이 서브 타입이다.
        ```ts
        let book2: Book = {
            name: "한 입 크기로 잘라먹는 리액트",
            price: 33000,
            skill: "reactjs", // 에러
        }
        ```
    - 하지만 이렇게 설정했더니 오류가 난다. cat 변수에 Animal타입을 지정해줬고 breed 프로퍼티만 추가적으로 작성한 것은 업 캐스팅에 해당한다.
    - 그 원인은 타입스크립트의 초과 프로퍼티 검사이다. 초과 프로퍼티 검사란, 변수를 객체 리터럴로 초기화할 때 발동하는 타입스크립트의 특수 기능이다.
    - 이 기능은 타입에 정의된 프로퍼티 외에 다른 초과된 프로퍼티를 갖는 객체를 변수에 할당할 수 없도록 막는다.
    - 즉, 객체 리터럴을 사용하지만 않으면 된다는 의미이다.
        ```ts
        let book3: Book = programmingBook // OK
        ```
#### 대수 타입
- 대수 타입이란 여러개의 타입을 합성하여 새롭게 만들어낸 타입이다.
```ts
// 합집합 - Union 타입
let a: number | string = '1';
a = 1;

const arr: (number | string | boolean)[] = [1, 'hello', true];

type DogAndPerson = Dog | Person

const dogAndPerson1: DogAndPerson = {
    name: '나비',
    color: 'black',
}

const dogAndPerson2: DogAndPerson = {
    name: '나비',
    language: '멍언어',
}

const dogAndPerson3: DogAndPerson = {
    name: '나비',
    language: '멍언어',
    color: 'black',
}

// 교집합 - Intersection 타입
let a: number & string;

type Dog = {
    name: string;
    color: string;
}

type Person = {
    name: string;
    language: string;
}

type Intersection = Dog & Person

let intersection1: Intersection = {
    name: '나비',
    color: 'black',
    lanuage: '멍언어',
}
```

#### 타입 추론
- 타입스크립트는 자동으로 타입 추론을 통해 타입을 지정한다. 타입 추론이 잘 동작되는 상황과 예기치 않게 동작하는 상황은 다음과 같다.
    ```ts
    // 타입 추론이 잘 되는 경우
    let a = 10;
    let b = 'hello';
    let c = {
        id: 0,
        name: '이정환',
        profile: {
            nickName: 'winterlood',
        }
    }
    let {id, name, profile} = c;
    let [one, two, three] = [1, 'hello', true];

    function func(message = '10') {
        return 'hello';
    }

    // 타입 추론이 이상한 경우
    let d;
    d = 10; // d -> number 타입
    d = '10' // d -> string 타입
    // -> any 타입의 진화
    ```

#### 타입 단언
- 타입 단언은 타입스크립트에게 해당 타입으로 단언할거라고 이야기 해주는 것과 같다.
    ```ts
    type Person = {
        name: string;
        age: number;
    }

    const a = {} as Person;
    a.name = '이정환';
    a.age = 27;
    ```
    - a 객체를 {}으로 초기화하면 타입스크립트는 a의 타입을 빈 객체 리터럴로 추론하게 된다 따라서 a.name과 같이 프로퍼티를 추가할 수 없다
    - 이 문제를 해결하기 위해 타입스크립트에게 a의 타입을 Person으로 추론하게 시키는 것이다.
    - 타입 단언은 다음과 같은 규칙이 필요하다.
        - 값 as 단언 <- 이 처럼 타입 단언을 하는데, 값과 단언이 서로 슈퍼-서브타입 관계여야한다.
        - 즉, number, string 처럼 형제관계에 있는 경우에는 단언이 이루어지지 않는다.
    ```ts
    const cat = {
        name: '나비',
        color: 'yellow',
    } as const
    ``` 
    - 이렇게 작성해도 cat.name 속성은 바뀔 수 있고 타입스크립트도 name 프로퍼티를 string으로만 추론한다. 하지만 as const로 타입을 단언하면,
    readonly가 붙어서 프로퍼티를 수정할 수 없게하고 name 프로퍼티를 '나비'로 추론한다. 객체 값도 const 처럼 사용할 수 있다.
    ```ts
    type Post = {
        title: string;
        author?: string;
    }

    let post: Post = {
        title: '게시글1',
        author: '이정환',
    }

    const len: number = post.author?.length; // 에러, length가 없을 수 있기 때문에 len: number | undefined와 같이 작성하거나 non null 단언 필요
    const len: number = post.author!.length; // OK, 타입스크립트에게 length 값이 무조건 있을거라고 말해주는 것과 같다.
    ```

#### 타입 좁히기
- 조건문 등을 이용해서 넓은 타입에서 좁은 타입으로 타입을 상황에 맞게 좁히는 방법을 타입 좁히기라고 한다.
    ```ts
    type Person = {
        name: string;
        age: number;
    }

    function func(value: string | number | Date | null | Person) {
        if (typeof value === 'string') console.log(value.toUpperCase());
        else if (typeof value === 'number') console.log(value.toFixed());
        else if (value instanceof Date) console.log(value.getTime());
        else if (value && 'age' in value) console.log(value.getTime());
    }
    ```
    - instanceof를 이용하면 내장 클래스 타입을 보장할 수 있는 타입 가드를 만들 수 있다.
    - instanceof는 내장 클래스 또는 직접 만든 클래스에만 사용이 가능한 연산이다. 따라서 우리가 직접 만든 타입과 함께 사용할 수 없다.
    - 우리가 직접 만든 타입과 함께 사용하려면 instanceof 대신 in 연산자를 이용해야 한다.

#### 서로소 유니온 타입
- 서로소 유니온 타입이란 교집합이 없는 타입들로만 만든 유니온 타입을 말한다.
    ```ts
    type Admin = {
        name: string;
        kickCount: number;
    }

    type Member = {
        name: string;
        point: number;
    }

    type Guest = {
        name: string;
        visitCount: number;
    }

    type User = Admin | Member | Guest;

    function login(user: User) {
        if ('kickCount' in user) console.log(`${user.name}님 현재까지 ${user.kickCount}명 강퇴했습니다.`);
        else if ('point' in user) console.log(`${user.name}님 현재까지 ${user.point}p 모았습니다..`);
        else if ('visitCount' in user) console.log(`${user.name}님 현재까지 ${user.visitCount}번 오셨습니다.`);
    }
    ```
    - login 함수에서 작성한 타입 가드는 팀원들이 보기에 이해하기 힘들 수 있다. 따라서 다음과 같이 변경해볼 수 있다.
    ```ts
    // type에 각각 tag 프로퍼티 추가했다고 가정
    function login(user: User) {
        if (user.tag === 'ADMIN') console.log(`${user.name}님 현재까지 ${user.kickCount}명 강퇴했습니다.`);
        else if (user.tag === 'MEMBER') console.log(`${user.name}님 현재까지 ${user.point}p 모았습니다..`);
        else if (user.tag === 'GUEST') console.log(`${user.name}님 현재까지 ${user.visitCount}번 오셨습니다.`);
    }
    ```
    - 이렇게 작성하면 조금 더 이해하기 쉬운 코드가 된다. 또한 User는 서로소 유니온 타입이다.
    - 각 타입에 tag라는 string 리터럴 타입을 지정해줬기 때문에 각 type은 서로소 관계라고 볼 수 있다.

## section 4

### 함수 타입
```ts
function func(a: number, b: number): number {
    return a + b;
}

const a = (a: number, b: number) => {
    return a + b;
}

// 함수 타입 표현식
type Operation = (a: number, b: number) => number;

const add: (a: number, b: number) => number = (a, b) => a + b;
const sub: Operation = (a, b) => a - b;
const multi: Operation = (a, b) => a * b;
const divi: Operation = (a, b) => a / b;

// 호출(콜) 시그니처
type Operation2 = {
    (a: number, b: number): number;
    // name: string; 처럼 추가로 작성할 수도 있음 (하이브리드 타입)
}
```

#### 함수 타입의 호환성
- 함수 타입 호환성은 특정 함수 타입을 다른 함수 타입으로 취급해도 되는지 판단하는 것을 말한다.
- 함수 타입 호환성을 판단하는 기준은 다음과 같다.
- 두 함수의 반환값 타입이 호환되는지, 두 함수의 매개변수 타입이 호환되는지
    ```ts
    // 1. 반환값 타입 호환
    type A = () => number;
    type B = () => 10;

    let a: A = () => 10;
    let b: B = () => 10;

    a = b // 가능, 업 캐스팅
    b = a // 불가능, 다운 캐스팅

    // 2. 매개변수가 호환되는가
    // 2-1 매개변수의 개수가 같을 때
    type C = (value: number) => void
    type D = (value: 10) => void

    let c: C = (value) => {};
    let d: D = (value) => {};

    c = d // 에러, 업 캐스팅이라서 불가능
    d = c // OK, 다운 캐스팅이라서 가능
    ```
    - 이상하게도 업 캐스팅인 경우에 에러문구가 뜨고 다운 캐스팅인 경우에 정상처리된다.
    - 즉, 함수의 매개변수를 기준으로 호환성 여부를 검사하게 되면 업 캐스팅은 불가능하고, 다운 캐스팅은 가능하다
    ```ts
    // 2-2 매개변수의 개수가 다를 때
    type E = (a: number, b:number) => void; 
    type F = (a: number) => void;

    let e: E = (a, b) => {}
    let f: F = a => {}

    e = f // OK, 매개변수 개수가 f가 더 작기에 e로 취급 가능
    f = e // 에러, 매개변수 개수가 더 큰 e를 더 작은 f로 취급하는건 불가능
    ```
    - 매개변수의 개수가 다를 때는 매개변수의 갯수가 작은쪽이 큰쪽으로 취급 되는 것은 가능하지만 그 반대의 경우엔 불가능하다.

#### 함수 오버로딩
- 함수 오버로딩이란 하나의 함수를 매개변수의 개수나 타입에 따라 다르게 동작하도록 만드는 문법이다.
    ```ts
    // 오버로드 시그니처
    function func(a:number): void;
    function func(a: number, b: number, c: number): void;
    ```
    - 이렇게 구현부 없이 선언부만 만들어둔 함수를 오버로드 시그니처라고 한다.
    - 매개변수 하나만 받는 버전, 매개변수 세개를 받는 두 개의 버전이 있다고 알리는 것과 같다.
    - 이제 구현 시그니처를 만들어줘야 한다.
    ```ts
    function func(a: number, b?: number, c?: number) {
        if (typeof b === 'number' && typeof c === 'number') {
            console.log(a + b + c);
        } else console.log(a * 20);
    }

    func(1) // 버전 1 함수 실행
    func(1,2,3) // 버전 2 함수 실행
    ```
    - 이때 func의 매개변수 b와 c를 옵셔널로 만들어줘야 첫 번째 오버로드 시그니처가 의미가 있어지기 때문에 오버로드 시그니처와 구현 시그니처는
    서로 호환되도록 만들어줘야 한다.

#### 사용자 정의 가드
- 사용자 정의 가드란 참 또는 거짓을 반환하는 함수를 이용해 타입 가드를 직접 만들 수 있도록 해주는 문법이다.
    ```ts
    type Dog = {
        name: string;
        isBark: boolean;
    };

    type Cat = {
        name: string;
        isScratch: boolean;
    };

    type Animal = Dog | Cat;

    function warning(animal: Animal) {
        if ("isBark" in animal) {
            console.log(animal.isBark ? "짖습니다" : "안짖어요");
        } else if ("isScratch" in animal) {
            console.log(animal.isScratch ? "할큅니다" : "안할퀴어요");
        }
    }
    ```
    - 타입이 가지고 있는 프로퍼티를 가지고 타입을 좁히면 가독성이 좋지 않다.
    - 이러한 경우에서 사용자 정의 가드를 사용하면 다음과 같다.
        ```ts
        // Dog인지 확인하는 타입 가드
        function isDog(animal: Animal): animal is Dog {
            return (animnal as Dog).isBark !== undefined;
        }

        function isCat(animal: Animal): animal is Cat {
            return (animnal as Cat).isScratch !== undefined;
        }

        function warning(animal: Animal) {
            if (isDog(animal)) console.log(animal.isBark ? "짖습니다" : "안짖어요");
            else if (isCat(animal)) console.log(animal.isScratch ? "할큅니다" : "안할퀴어요");
        }
        ```
        - 이처럼 사용자 정의 타입 가드를 이용해서 타입 좁히기를 할 수 있다.

## section 5
### 인터페이스
- 인터페이스란 타입 별칭과 동일하게 타입에 이름을 지어주는 또 다른 문법이다.
    ```ts
    interface Person {
        readonly name: string;
        age?: number;
        sayHi(): void;
        // sayHi: () => void;
    }

    // 인터페이스 확장 (상속)
    interface Animal {
        name: string;
        color: string;
    }

    interface Dog extends Animal {
        name: 'hello'; // 프로퍼티 타입 재정의 가능, 단 상속받는 타입의 서브 타입이여야만 한다.
        isBark: boolean;
    }

    interface Cat extends Animal {
        isScratch: boolean;
    }

    interface Chicken extends Animal {
        isFly: boolean;
    }

    // 다중 확장
    interface DogCat extends Dog, Cat 

    // 선언 합침
    interface Animal {
        name: string;
    }

    interface Animal {
        color: string;
    }
    ```
    - 선언 합침을 할 때에는 프로퍼티 타입을 재정의 할 때 인터페이스 확장 처럼 서브 타입으로 재정의 하는것도 불가능하다.
    - 꼭 같은 타입으로만 재정의 할 수 있다.
