# 🎯 [한 입 크기로 잘라 먹는 타입스크립트] - 섹션 1: 강의 소개 및 타입스크립트 개론  
> 수강일: 2025.10.22

---

## 🧩 섹션 개요
- **섹션 목표:**
  - 타입스크립트의 기본 개념과 철학, 컴파일 구조를 이해하고 개발 환경을 세팅한다.
- **핵심 학습 포인트:**
  - 정적/동적 타입 시스템의 차이
  - 타입스크립트의 컴파일 원리
  - `tsconfig.json`의 주요 옵션 이해
  - 타입스크립트 개발 환경 구축
  
---

## 📌 강의별 정리

### 🔹 강의 1: 강의 소개
---

### 🔹 강의 2: 개발 환경 준비하기
---

### 🔹 강의 4: 타입스크립트를 소개합니다
- **핵심 내용:**
  - 타입스크립트는 **자바스크립트에 타입 기능을 추가한 오픈소스 언어**
  - 런타임이 아닌 **컴파일 타임에 오류를 미리 방지**할 수 있음
  - JS로 컴파일되어 브라우저나 Node 환경에서 동작
	![](https://velog.velcdn.com/images/iamsunwoo/post/bcdc1a3f-c0d9-4ac0-8030-580cb53006b7/image.png)
- **내가 이해한 포인트:**
  - 타입스크립트는 새로운 언어라기보다 **JS에 타입 안정성을 부여한 도구**
  
---

### 🔹 강의 5: 자바스크립트의 한계점과 타입스크립트
- **핵심 내용:**
  - **타입 시스템(Type System)**
    - 타입을 다루는 언어의 문법적 체계
    - **정적 타입 시스템**
      - 코드 실행 이전에 타입을 결정한다.
      - 엄격하고 고정적인 시스템
      - 모든 변수에 일일이 타입을 지정해주어야 한다.
      - 타이핑 양 증가, 유연하지 못하다.
      - C, Java
    - **동적 타입 시스템**
      - 코드 실행 도중에 타입을 결정한다.
      - 자유롭고 유연한 시스템
      - 코드의 타입 오류를 미리 검사할 수 없다.
      - 예기치 못한 오류가 발생할 수 있다.
      - Python, JavaScript
    - **문제점**
      - JS는 자유롭지만 타입 검사가 없어 런타임 오류가 잦음 
   - **타입스크립트의 타입 시스템**
     - 동적 타입 시스템 + 정적 타입 시스템
     - 변수의 타입을 실행 전에 결정한다.
     - 타입 오류를 실행 전에 검사한다.
     - 모든 변수에 타입을 일일이 지정할 필요 없다.
       - **점진적 타입 시스템**
         - 특정 변수가 특정 값으로 초기화 되었을 때 타입을 추론해준다.
- **코드 예제:**
  ```typescript
  let num = 1; // number 타입으로 추론
  num = "hello" // 컴파일 오류
  ```

---

### 🔹 강의 6: 타입스크립트의 동작 원리
- **핵심 내용:**
  - **컴파일**
    - 사람이 작성한 코드를 컴퓨터가 이해할 수 있는 코드로 변환
  - **일반적인 컴파일 과정**
    - `소스 코드` → `AST(추상 문법 트리)` → `바이트 코드`
    ![](https://velog.velcdn.com/images/iamsunwoo/post/dc97790b-8f48-4aac-b8b6-3f8497d22062/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/613c5bc1-3a98-4240-be78-cd32b39750e6/image.png)![](https://velog.velcdn.com/images/iamsunwoo/post/a838e25b-3aa9-4370-b8b0-a9d6608e594d/image.png)![](https://velog.velcdn.com/images/iamsunwoo/post/fe923450-f5e6-42cf-a248-01dff3127e1f/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/e7b71cba-a7b0-4cc5-a6eb-fe04184fd590/image.png)![](https://velog.velcdn.com/images/iamsunwoo/post/66c36e82-f95c-43bc-a91e-b25f115f5b76/image.png)
  - **TS의 컴파일 과정**
    1. `타입스크립트 소스코드` → `AST(추상 문법 트리) 생성`
    2. 타입 체크 수행
    3. 통과 시 JS 코드로 변환(`.js` 파일)
    4. 타입 오류 발생 시 컴파일 중단
    ![](https://velog.velcdn.com/images/iamsunwoo/post/43140de7-f9d9-46b0-b154-e0d27dc0566c/image.png)![](https://velog.velcdn.com/images/iamsunwoo/post/a5633f70-639b-4887-9da4-c08e12669a1d/image.png)![](https://velog.velcdn.com/images/iamsunwoo/post/58b76626-db5a-42e5-8db6-2ced0c85d066/image.png)

---

### 🔹 강의 7: Hello TS World!
- **핵심 내용:**
  - **패키지 초기화**
    - `npm init`
  - **타입스크립트 설치 및 실행**
    - `npm i @types/node`
  - **타입스크립트 컴파일러 전역 설치**
    - `sudo npm i typescript -g`
  - **타입스크립트 컴파일러(tsc) 정상 설치 여부 확인**
    - `tsc -v`
  - **타입스크립트 파일 컴파일**
    - `tsc src/index.ts`
  - **타입스크립트 컴파일 결과인 index.js 파일 실행**
    - `node src/index.js`
  - **타입스크립트 파일 실행**
    - `sudo npm i -g tsx`
    - `tsx src/index.ts`
- **내가 이해한 포인트:**
  - `tsc`는 타입스크립트 파일을 컴파일 후 `.js` 파일로 변환
  - `tsx`는 타입스크립트 파일을 실행
---

### 🔹 강의 8: 타입스크립트 컴파일러 옵션 설정하기
- **핵심 내용:**
  - `tsconfig.json`
    - TS를 컴파일할 때 얼마나 엄격하게 타입 체크를 할지 설정
    - TS 컴파일 결과인 JS 파일의 버전 관리
    - `tsc --init` 명령어 입력 시 생성됨
  - **주요 컴파일러 옵션**
    - `include`
      - 컴파일할 파일 범위 지정
    - `target`
      - 컴파일된 JS 버전 설정(예: `ES6`, `ES5` 등)
    - `module`
      - 사용할 모듈 시스템 설정(예: `CommonJS`, `ESModule` 등)
    - `outDir`
      - 컴파일 결과 파일의 저장 경로
    - `strict`
      - 타입 검사 강도 조절
      - `true`로 설정 시, 타입을 추론할 수 없는 변수(예. 매개변수)에 타입을 지정하지 않을 시 에러 발생 
    - `moduleDetection`
      - 독립 모듈 인식 방식 설정
      - 타입스크립트는 모든 타입스크립트 파일을 전역 모듈로 본다. ![](https://velog.velcdn.com/images/iamsunwoo/post/e00d6d54-b82a-4101-8a7d-5daf7ced89c8/image.png)
        - **해결 방법 1**
          - `.ts` 파일 내 `export`, `import`와 같은 모듈과 관련된 키워드를 한 번이라도 작성한다.
        - **해결 방법 2**
          - 해당 옵션의 값을 `"force"`로 설정한다.
    - `skipLibCheck`
      - 외부 라이브러리에서 주로 사용되는 타입 정의 파일(`.d.ts`)의 검사를 생략
    - `strictNullCheck`
      - `null` 관련 엄격 검사
- **코드 예제:**
  ```json
  {
    "compilerOptions": {
      "target": "ES6",
      "module": "CommonJS",
      "outDir": "./dist",
      "strict": true,
      "skipLibCheck": true,
    },
    "include": ["src"]
  }
  ```
- **내가 이해한 포인트:**
  - `tsconfig.json`은 프로젝트의 타입 안정성 수준을 정의하는 설계 문서
- **실무/프로젝트 적용 아이디어:**
  - 협업 시 `strict: true`로 통일하여 일관된 코드 품질 유지
  - `skipLibCheck`를 활용해 외부 라이브러리 오류로 인한 빌드 중단 방지

---

# 🎯 [한 입 크기로 잘라 먹는 타입스크립트] - 섹션 2: 타입스크립트 기본
> 수강일: 2025.10.22

---

## 🧩 섹션 개요
- **섹션 목표:**
  - 타입스크립트의 기본 타입 시스템과 구조적 타입 지정 방식을 이해한다.
- **핵심 학습 포인트:**
  - 원시 타입, 리터럴 타입, 배열, 튜플, 객체, 타입 별칭,
  - 인덱스 시그니처를 통한 유연한 객체 정의

---

## 📌 강의별 정리

### 🔹 강의 1: 기본 타입
- **핵심 내용:**
  - **기본 타입**
    - 타입스크립트가 자체적으로 제공하는 내장 타입(Primitive Type)
    - 대표적인 기본 타입: `number`, `string`, `boolean`, `null`, `undefined`, `any`, ...

---

### 🔹 강의 2: 원시타입과 리터럴타입
- **핵심 내용:**
  - **원시타입(Primitive Type)**
    - 단일 값 저장(예. `number`, `string`, `boolean`, `null`, `undefined`, ...)
  - **리터럴 타입(Literal Type)**
    - 값 자체가 타입이 되는 형태
  - 콜론(`:`)과 함께 타입을 지정하는 것을 타입 어노테이션이라고 한다.
- **코드 예제:**
  ```typescript
  let numA: number = 10;
  let strB: string = 'tyepscript'
  let boolC: boolean = true;

  // 리터럴 타입
  let numL: 10 = 10;
  let strL: 'hello' = 'hello';
  let boolL: true = true;
  ```
- **실무/프로젝트 적용 아이디어:**
  - 특정 상수 값만 허용해야 할 때(예. API 응답 상태 `'success' | 'fail'`) 리터럴 타입을 활용

---

### 🔹 강의 3: 배열과 튜플
- **핵심 내용:**
  - 배열: 여러 개의 데이터를 저장하는 자료형
  - 튜플: 배열과 달리 **길이와 타입이 고정된 배열**
  - 튜플도 배열이므로 `push`, `pop` 등의 메서드는 사용 가능하지만 주의가 필요하다.
- **코드 예제:**
  ```typescript
  // 배열
  let numArr: number[] = [1,2,3];
  let boolArr: Array<boolean> = [true, false, true]; // 제네릭

  // 배열에 들어가는 요소들의 타입이 다양할 경우
  let multiArr: (number | string)[] = [1, 'hello']; // 유니온

  // 다차원 배열의 타입을 정의하는 방법
  let doubleArr: number[][] = [[1, 2, 3], [4, 5]];

  // 튜플
  // 길이와 타입이 고정된 배열
  let tup1: [number, number] = [1, 2];
  let tup2: [number, string, boolean] = [1, '2', true];
  // 튜플을 유용하게 사용할 수 있는 순간
  // 인덱스의 순서와 위치를 고정시키고 싶을 때
  const users: [string, number][] = [
    ['이정환', 1],
    ['이아무개', 2],
    ['김아무개', 3],
    ['박아무개', 4],
  ];
  ```
- **내가 이해한 포인트:**
  - 튜플은 데이터 구조의 위치와 타입을 고정하고 싶을 때 유용하다.

---

### 🔹 강의 4: 객체
- **핵심 내용:**
  - 타입 지정 시 **객체 리터럴 형태**로 정의해야 한다. (`{id: number, name: string, ...}`)
  - **옵셔널 프로퍼티(`?`)**
    - 특정 프로퍼티가 존재하지 않아도 허용
  - **readonly**
    - 읽기 전용 속성으로 변경 불가
- **코드 예제:**
  ```typescript
  // type이 object일 때
  let user: object = {
    id: 1,
    name: '이정환',
  };

  user.id; // ❌ 에러 발생

  // type이 객체 리터럴 타입일 때
  let user: { id: number; name: string } = {
    id: 1,
    name: '이정환',
  };

  user.id; // 🅾️

  let config: { readonly apiKey: string } = {
    apiKey: 'MY API KEY',
  };

  config.apiKey = 'hacked'; // ❌ 에러 발생
  ```
---

### 🔹 강의 5: 타입 별칭과 인덱스 시그니처
- **핵심 내용:**
  - **타입 별칭(Type Alias)**
    - 타입 정의를 변수처럼 재사용할 수 있도록 하는 문법
    - `type` 키워드를 사용하며, 같은 스코프 내 중복 정의 불가
    - 파스칼 케이스로 작성한다.
  - **인덱스 시그니처**
    - 객체의 키와 값 타입 규칙을 정의
    - 추가 프로퍼티의 값도 반드시 시그니처 타입과 호환되어야 한다.
- **코드 예제:**
  ```typescript
  // 타입 별칭
  type User = {
    id: number;
    name: string;
    nickname: string;
    birth: string;
    bio: string;
    location: string;
  };

  const people: User = {
    id: 1,
    name: '이정환',
    nickname: 'winterlood',
    birth: '1997.01.07',
    bio: '안녕하세요',
    location: '부천시',
  };

  // 인덱스 시그니처
  type CountryCodes = {
    [key: string]: string;
  };

  let countryCodes: CountryCodes = {
    korea: 'ko',
    unitedState: 'us',
    unitedKingdom: 'uk ',
  };

  type CountryNumberCodes = {
    [key: string]: number;
    korea: string; // ❌ 에러 발생
  };
  ```

---

### 🔹 강의 6: Enum 타입
- **핵심 내용:**
  - `Enum`(열거형)
    - 여러 가지 값(상수)에 각각 이름을 붙여 **의미 있는 그룹으로 묶는 타입**
    - 타입 별칭(`type`)처럼 타입을 정의하지만, **실제 자바스크립트 코드로 변환되는 특징**이 있다.
    - **파스칼 케이스**로 작성하는 것이 관례
  - **숫자형 Enum**
    - 각 멤버에 숫자를 할당하지 않으면 0부터 자동 증가
    - 일부 멤버에만 값을 지정하면 나머지는 그 값을 기준으로 자동 증가
    - Enum 멤버는 양방향 매핑이 가능(숫자로부터 이름을, 이름으로부터 숫자를 얻을 수 있음)
  - **문자형 Enum**
    - 문자열을 직접 지정
    - 문자열 Enum은 양방향 매핑이 불가능(값에서 이름을 역으로 찾을 수 없음)
  - **컴파일 후 결과**
    - TS에서 `enum`은 JS로 컴파일 시, **즉시실행함수(IIFE)**로 감싸진 객체 형태로 변환된다.
    - JS에 `enum` 문법은 없으며, TS 전용 문법이다.
- **코드 예제:**
  ```ts
  enum NumberTypeEnum {
      ADMIN = 0,
      USER = 1,
      GUEST = 2
  }

  const a = NumberTypeEnum.ADMIN;
  const b = NumberTypeEnum[0]; // ⭕

  enum StringTypeEnum {
      'korean' = 'ko',
      'engilsh' = 'en'
  }

  const c = StringTypeEnum['ko']; // ❌

  ```
  - 컴파일 후 변환된 Enum
    ```js
    var NumberTypeEnum;
    (function (NumberTypeEnum) {
        NumberTypeEnum[NumberTypeEnum["ADMIN"] = 0] = "ADMIN";
        NumberTypeEnum[NumberTypeEnum["USER"] = 1] = "USER";
        NumberTypeEnum[NumberTypeEnum["GUEST"] = 2] = "GUEST";
    })(NumberTypeEnum || (NumberTypeEnum = {}));
    const a = NumberTypeEnum.ADMIN;
    const b = NumberTypeEnum[0];
    var StringTypeEnum;
    (function (StringTypeEnum) {
        StringTypeEnum["korean"] = "ko";
        StringTypeEnum["engilsh"] = "en";
    })(StringTypeEnum || (StringTypeEnum = {}));
    const c = StringTypeEnum['ko'];
    export {};
    ```
- **내가 이해한 포인트:**
  - enum`은 단순한 타입 정의가 아니라 **런타임에도 존재하는 객체**라는 점이 핵심이다.
  - 숫자형 Enum은 **양방향 참조 가능**, 문자형 Enum은 **단방향만 가능**
- **실무/프로젝트 적용 아이디어:**
  - 사용자 역할, 상태 코드, 언어 코드 등 **고정된 상수 집합을 관리할 때** 유용하다.
---

### 🔹 강의 7: Any와 Unknown 타입
- **핵심 내용:**
  - `any`
    - 모든 타입 검사에서 제외되는 타입(타입 안정성을 완전히 포기)
    - 컴파일 시 타입 에러가 발생하지 않아 런타임 에러를 유발할 수 있다.
    - "타입스크립트를 쓰지 않는 것과 같다"는 표현이 흔히 쓰인다.
  - `unknown`
    - `any`처럼 어떤 값도 담을 수 있지만, **사용 시에는 타입 검사가 필요**하다.
    - 다른 변수에 대입하거나 메서드 호출 시에는 **타입 단언** 또는 **조건문**으로 안전하게 처리해야 한다.
    - 런타임 때 에러를 유발하는 `any`보다 안전한 대안이다.
- **코드 예제:**
  ```ts
  // any
  let anyVar: any = 10;
  anyVar = "hello";
  anyVar = true;
  anyVar.toUpperCase(); // 가능 (런타임 에러 위험)

  let num: number = 10;
  num = anyVar;

  // unknown
  let unknownVar: unknown = "hello";
  unknownVar = 123;
  unknownVar = {};

  num = unknownVar // ❌ 타입 오류

  // 타입 좁히기를 사용한 안전한 사용
  if(typeof unknownVar === 'number') {
    num = unknownVar;
  }
  ```
- **내가 이해한 포인트:**
  - `unknown`은 모를 뿐, 아무거나는 아니다 → 타입 검증이 전제
  - `any`는 **타입스크립트의 보호막을 깨는 특수한 예외**이다.
- **실무/프로젝트 적용 아이디어:**
  - 외부 API 응답, `JSON.parse` 결과, `try-catch`의 `error` 등 타입이 확실치 않은 경우 `unknown`으로 선언 후 안전하게 분기 처리
  - `any`는 정말 불가피할 때만 사용
---

### 🔹 강의 8: Void와 Never 타입
- **핵심 내용:**
  - `void`
    - **아무것도 반환하지 않는다**는 의미의 타입
    - 주로 **함수의 리턴 타입**에서 사용
    - 기존에 undefined 타입이 있는데 `void`를 사용하는 이유
      - 타입스크립트 5.0.3 버전에서는 함수의 리턴 타입이 undefined인 경우 실제로 undefined를 반환했어야 했는데 이제는 그렇게 하지 않아도 됨
      - 단, `null`을 반환하는 경우에는 명시적으로 `null`을 리턴 타입에 지정해야 한다.
  - `never`
    - **함수가 끝나지 않거나 예외를 던져 정상적으로 종료되지 않을 때**
    - 함수가 정상 종료되지 않으므로 **리턴 타입이 존재할 수 없음**
    - `void`와 달리 `undefined`도 반환 불가능
- **코드 예제:**
  ```ts
  // void
  function func2(): void {
    console.log('hello');
  }

  let a: void;
  a = 1; // ❌
  a = 'hello'; // ❌
  a = {}; // ❌
  a = undefined; // ✅

  // never
  function func3(): never {
    while (true) {}
  }

  function func4(): never {
    throw new Error();
  }
  ```
- **내가 이해한 포인트:**
  - `void`는 단순히 리턴 없음이지만, `never`는 **끝나지 않음**을 의미한다.
  - `never`는 타입 체커가 **논리적 불가능성**을 보장할 때 사용된다.
- **실무/프로젝트 적용 아이디어:**
  - `void`는 이벤트 핸들러, 콜백 등 **리턴값이 중요하지 않은 함수 타입**에 자주 사용된다.
  
---

# 🎯 [인프런] - 섹션 3: 타입스크립트 이해하기
> 수강일: 2025.10.23 - 2025.10.24

---

## 🧩 섹션 개요
- **섹션 목표:**
  - 타입스크립트의 타입 시스템 원리를 이해하고, 타입 간 관계(집합적 사고, 호환성, 계층 구조, 추론 방식 등)를 깊이 있게 학습한다.
- **핵심 학습 포인트:**
  - "타입은 값의 집합이다" 라는 철학 이해
  - 타입 계층도의 구조적 의미
  - 객체 타입, 대수 타입의 호환 관계
  - 타입스크립트의 타입 추론 방식과 암묵적 any 진화 원리

---

## 📌 강의별 정리

### 🔹 강의 1: 타입스크립트 이해하기
- **핵심 내용:**
  - 타입스크립트를 이해한다는 것은 다음 3가지를 이해하는 것:
    1. 어떤 기준으로 타입을 정의하는가
    2. 어떤 기준으로 타입 간 관계를 정의하는가
    3. 어떤 기준으로 타입 오류를 검사하는가
---

### 🔹 강의 2: 타입은 집합이다
- **핵심 내용:**
  - 타입스크립트에서 타입은 **값의 집합**을 의미한다.
    - 예: `string` 타입은 가능한 모든 문자열의 집합, `number`는 가능한 모든 숫자의 집합
  - 슈퍼 타입: 더 넓은 집합(더 많은 값을 포함)
  - 서브 타입: 더 좁은 집합(일부만 포함)
  - 다른 타입에 포함되고 있는 타입을 서브 타입![](https://velog.velcdn.com/images/iamsunwoo/post/95616766-5e03-4699-87c9-771f57be2acf/image.png)
  - **타입 호환성**
    - 한 타입을 다른 타입으로 **대체해도 문제가 없는지** 판단하는 기준
    - 서브 타입 → 슈퍼 타입(**업 캐스팅**)
      - 모든 상황에서 가능하다.
    - 슈퍼 타입 → 서브 타입(**다운 캐스팅**)
      - 대부분의 상황에서 불가하다.
   ![](https://velog.velcdn.com/images/iamsunwoo/post/212629eb-316b-4fd9-9230-b005a3112635/image.png)![](https://velog.velcdn.com/images/iamsunwoo/post/3209977b-e93c-43dc-b82f-39bed236e37a/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/87948415-d757-49e5-8c0f-ce7c51b3845e/image.png)

- **코드 예제:**
  ```ts
  let unknownA: unknown = "10";
  let numA: number = 10;

  unknownA = numA; // ✅ 업 캐스팅
  numA = unknownA; // ❌ 다운 캐스팅
  ```
- **내가 이해한 포인트:**
  - 타입 간 관계를 포함 관계로 이해하면 훨씬 명확해진다.,
  - 즉, 타입 오류는 결국 집합 관계 위반으로 볼 수 잇다.

---

### 🔹 강의 3: 타입 계층도와 함께 기본타입 살펴보기
- **핵심 내용:**  ![](https://velog.velcdn.com/images/iamsunwoo/post/13f15d6c-20dd-4e08-b97d-aa7db28be6f0/image.png)
  - **unknown**
    - 모든 타입의 슈퍼 타입 → 어떤 값이든 대입 가능
    - 단, unknown을 다른 타입에 바로 대입할 수 없다.(다운 캐스팅 불가)
  - **never**
    - 모든 타입의 서브 타입(공집합 개념)
    - 어떤 값도 가질 수 없으며, 절대 반환되지 않는 함수의 반환 타입에 사용 
  - **any**
    - 타입 계층을 완전히 무시한다.
    - 모든 타입의 슈퍼/서브 타입 역할을 동시에 수행 → 타입 안정성 상실
- **코드 예제:**
  ```ts
  function neverExample(): never {
    throw new Error('에러 발생');
  }

  function unknownExample(value: unknown) {
    if (typeof value === 'string') {
      console.log(value.toUpperCase());
    }
  }

  function anyExample(value: any) {
    value.toUpperCase(); // 컴파일러가 오류를 잡지 못함 ❌
  }
  ```
---

### 🔹 강의 4: 객체 타입의 호환성
- **핵심 내용:**
  - 객체 타입의 호환성은 **프로퍼티 구조 기준**으로 판단된다.
    - 즉, 이름이 같고 타입이 호환되면 다른 타입이라도 대입 가능
  - **초과 프로퍼티 검사**
    - 객체 리터럴을 변수에 직접 대입할 때, 선언되지 않은 프로퍼티가 있으면 오류 발생
    - 하지만, 이미 정의된 객체를 대입하는 경우에는 검사하지 않는다.
- **코드 예제:**
  - 객체 타입의 호환성
    ```ts
    type Animal = {
      name: string;
      color: string;
    };

    type Dog = {
      name: string;
      color: string;
      breed: string;
    };

    let animal: Animal = {
      name: '기린',
      color: 'yellow',
    };

    let dog: Dog = {
      name: ' 돌돌이',
      color: 'brown',
      breed: '진도',
    };

    // 프로퍼티를 기준으로 부모/서브를 나눈다.
    // 따라서 Animal 타입이 부모 타입, Dog 타입이 서브 타입
    animal = dog; // ⭕
    dog = animal; // ❌
    ```
  
  - 초과 프로퍼티 검사
    ```ts
    type Book = {
      name: string;
      price: number;
    };

    type ProgrammingBook = {
      name: string;
      price: number;
      skill: string;
    };

    let book1: Book = {
      name: '한 입 크기로 잘라먹는 리액트',
      price: 33000,
      skill: 'react.js', // ❌(초과 프로퍼티 검사)
    };

    let programmingBook: ProgrammingBook = {
      name: '한 입 크기로 잘라먹는 리액트',
      price: 33000,
      skill: 'react.js',
    };

    let book2: Book = programmingBook; // ✅

    function func(book: Book) {}

    // ❌
    func({
      name: '한 입 크기로 잘라먹는 리액트',
      price: 33000,
      skill: 'react.js',
    });

    // ✅
    func(programmingBook);
    ```
- **내가 이해한 포인트:**
  - 타입스크립트는 명목적이 아닌 구조적 타입 시스템이다.
- **실무/프로젝트 적용 아이디어:**
  - 초과 프로퍼티 검사를 피하고 싶다면, 변수에 담아서 전달하거나 인덱스 시그니처 사용
---

### 🔹 강의 5: 대수 타입
- **핵심 내용:**
  - **대수 타입**
    - 여러 타입을 조합해서 새로운 타입을 만드는 방식
      - 합집합(Union): `A | B` → A 또는 B
      - 교집합(InterSection): `A & B` → A 이면서 B
  - 기본 타입끼리 교집합은 거의 `never`에 가깝다.
  - 객체 타입에서 주로 교집합 타입이 사용된다.
- **코드 예제:**
  ```ts
  type Dog = { name: string; color: string };
  type Person = { name: string; language: string };

  type UnionType = Dog | Person;
  type IntersectionType = Dog & Person;

  let union1: UnionType = { name: '멍멍이', color: 'brown' };
  let union2: UnionType = { name: '홍길동', language: 'ko' };
  let both: IntersectionType = { name: '철수', color: 'white', language: 'en' };
  ```
- **내가 이해한 포인트:**
  - Union은 "OR", Interection은 "AND" 개념이다.
---

### 🔹 강의 6: 타입 추론
- **핵심 내용:**
  - 타입스크립트는 **초기값을 기준으로 타입을 추론**한다.
  - **암묵적 `any` 타입**
    - 변수를 선언만 하고 초기화하지 않으면 any로 추론된다.
  - **타입 넓히기**
    - `const`가 아닌 `let`으로 선언된 값은 더 넓은 타입으로 추론된다.
  - **any의 진환**
    - 변수에 여러 타입의 값이 순차적으로 대입되면 점차 타입이 변화한다.
- **코드 예제:**
  ```ts
  let a = 10; // number
  let b = 'hello'; // string
  let c; // any (암묵적 any)

  c = 10; // number
  c = 'hi'; // string

  const nickname = 'sunny'; // 'sunny' (리터럴 타입)
  let title = 'TS';         // string (타입 넓히기)
  ```
- **내가 이해한 포인트:**
  - 함수 매개변수는 추론되지 않으므로 반드시 타입 지정이 필요하다.
- **실무/프로젝트 적용 아이디어:**
  - useState 초기값이 null인 경우 제네릭으로 명시적 타입을 지정해야 한다.
    - `useState<Type|null>(null)`
---

### 🔹 강의 7: 타입 단언
- **핵심 내용:**
  - **타입 단언**
    - TS가 추론한 타입보다 개발자가 더 잘 알고 있을 때, **개발자가 직접 타입을 단언(강제 지정)**하는 문법
    - **형식**
      ```ts
      A as B
      ```
      - 단, `A`와 `B`는 서로 슈퍼/서브 관계여야 한다.
      - 즉, 완전히 무관한 타입(예. `string` & `number`)끼리는 단언 불가능
    - **다중 단언**
      - `A as unknown as B` 형태로 중간에 `unknown`을 거쳐 강제로 단언 가능
      - 타입 안정성을 저하시키므로 되도록 **지양**하는 것이 좋다.
    - **const 단언(`as const`)**
      - 리터럴 타입을 갖게 된다.
      - 객체에 적용 시, 모든 프로퍼티를 `readonly`로 만들어준다.
      - `let num = 10;` → `num`의 타입: number
      - `let num = 10 as const;` → `num`의 타입: 10
    - **Non Null 단언(`!`)**
      - 옵셔널 체이닝(`?.`) 대신, **해당 값이 null/undefined가 아님을 확신할 때 사용**
  - 타입 단언은 TS의 타입 검사 우회 수단이므로, 오남용 시 런타임 오류로 이어질 수 있다.
- **코드 예제:**
  - 타입 단언 예제
    ```ts
    type Person = {
      name: string;
      age: number;
    };

    // ❌ 
    function badExample() {
      let person: Person = {}; // Person 타입에 필요한 프로퍼티를 모두 가지고 있지 않음
      person.name = '이정환';
      person.age = 27;
    }

    // ⭕️
    function exam2() {
      let person = {} as Person; // 타입 단언 사용
      person.name = '이정환';
      person.age = 27;
    }
    ```
  - 타입 단언 규칙 예제
    ```ts
    let num1 = 10 as never // ✅ number는 never의 슈퍼타입
    let num2 = 10 as unknown // ✅ number는 unknown의 서브타입
    // let num3 = 10 as string // ❌ number와 string은 무관
    let num4 = 10 as unknown as string // ⚠️ 가능하지만 안전하지 않음
    ```
  - const 단언 예제
    ```ts
    const num5 = 10 as const;
    const cat = {name: "야옹이", color: "yellow"} as const;
    // cat.name = '냥이' // ❌ readonly 속성으로 수정 불가
    ```
  - Non-Null 단언 예제
    ```ts
    type Post = {
      title: string;
      author?: string;
    };

    const post: Post = {
      title: '게시글1',
      author: '이정환'
    };

    const len: number = post.author!.length; // author가 존재한다고 단언
    ```
- **내가 이해한 포인트:**
  - 진짜로 값이 맞는지 검증하지 않기 때문에 조심히 사용해야 한다.
- **실무/프로젝트 적용 아이디어:**
  - React에서 `ref`로 DOM 요소 접근 시:
    ```ts
    const inputRef = useRef<HTMLInputElement>(null);
    inputRef.current!.focus();
    ```
---

### 🔹 강의 8: 타입 좁히기
- **핵심 내용:**
  - **타입 좁히기**
    - 조건문 등을 통해 넓은 타입을 상황에 따라 더 구체적인 타입으로 좁히는 기법이다.
    - 타입 가드
      - 특정 조건으로 타입을 판별하는 코드 패턴
      - 주요 연산자
        - `typeof` - 기본 타입 판별(`number`, `stirng`, `boolean`, `object`, ...)
        - `instanceof` - 객체 타입 판별(`Date`, `Error`, ...)
        - `in` - 객체 프로퍼티 존재 여부로 타입 판별
- **코드 예제:**
  ```ts
  type Person = {
    name: string;
    age: number;
  };

  function func(value: number | string | Date | null | Person) {
    // value.toUpperCase(); // ❌
    // value.toFixed(); // ❌

    // 타입 가드
    if (typeof value === 'number') {
      console.log(value.toFixed());
    } else if (typeof value === 'string') {
      console.log(value.toUpperCase());
      //   } else if (typeof value === 'object') { // ⚠️ null 값도 object이기 때문에 좋지 않은 코드
    } else if (value instanceof Date) {
      console.log(value.getTime());
    } else if (value && 'age' in value) {
      console.log(`${value.name}은 ${value.age}살 입니다.`);
    }
  }
  ```
- **내가 이해한 포인트:**
  - TS는 `typeof`, `instanceof`, `in` 결과릴 기반으로 자동으로 타입을 좁힌다.
  - null 체크(`value && ...`)가 중요하다.
  - `typeof null === 'object'`이다.
---

### 🔹 강의 9: 서로소 유니온 타입
- **핵심 내용:**
  - **서로소 유니온 타입(Taged Union Type)**
    - 교집합이 없는 여러 타입을 하나의 구분 가능한 프로퍼티로 구분하는 유니온 타입
    - 각 타입이 공통적으로 갖는 `tag`(또는 `state`) 프로퍼티의 리터럴 값으로 타입을 구분한다.
    - `switch` 문과 함께 사용 시 강력한 타입 추론을 제공한다.
    - 동시에 여러가지 상태를 표현해야 하는 객체의 상태를 정의할 때에는 선택적 프로퍼티가 아닌 각 타입을 잘게 쪼개어 서로소 유니온 타입을 만드는 게 좋다.
- **코드 예제:**
  ```ts
  type Admin = {
    tag: 'ADMIN';
    name: string;
    kickCount: number;
  };

  type Member = {
    tag: 'MEMBER';
    name: string;
    point: number;
  };

  type Guest = {
    tag: 'GUEST';
    name: string;
    visitCount: number;
  };

  type User = Admin | Member | Guest;

  // ❌ 비효율적: in 연산자로 각각 검사
  function login1(user: User) {
    // 1️⃣ user가 Admin인 경우
    if ('kickCount' in user) {
      console.log(`${user.name}님 현재까지 ${user.kickCount}명 강퇴했습니다.`);
    }
    // 2️⃣ user가 Member인 경우
    if ('point' in user) {
      console.log(`${user.name}님 현재까지 ${user.point}모았습니다.`);
    }
    // 3️⃣ user가 Guest인 경우
    if ('visitCount' in user) {
      console.log(`${user.name}님 현재까지 ${user.visitCount}번 방문했습니다.`);
    }
  }

  // ⭕️ 서로소 유니온 + switch 사용
  function login2(user: User) {
    switch (user.tag) {
      case 'ADMIN':
        console.log(`${user.name}님 현재까지 ${user.kickCount}명 강퇴했습니다.`);
        break;
      case 'MEMBER':
        console.log(`${user.name}님 현재까지 ${user.point}모았습니다.`);
        break;
      case 'GUEST':
        console.log(`${user.name}님 현재까지 ${user.visitCount}번 방문했습니다.`);
        break;
    }
  }
  ```

  - 추가 예시
  ```ts
  type LoadingTask = {
    state: 'LOADING';
  };

  type FailedTask = {
    state: 'FAILED';
    error: {
      message: string;
    };
  };

  type SuccessTask = {
    state: 'SUCCESS';
    response: {
      data: string;
    };
  };

  type AsyncTask = LoadingTask | FailedTask | SuccessTask;

  function processResult(task: AsyncTask) {
    switch (task.state) {
      case 'LOADING':
        console.log('LOADING...');
        break;
      case 'FAILED':
        console.log(task.error.message);
        break;
      case 'SUCCESS':
        console.log(task.response.data);
        break;
    }
  }
  ```
- **내가 이해한 포인트:**
  - `tag` 또는 `state`를 기준으로 안전하게 타입을 구분할 수 있다.
  - 선택적 프로퍼티(`?`)로 상태를 구분하는 것보다 안전하고 명확하다.

---

# 🎯 [한 입 크기로 잘라 먹는 타입스크립트] - 섹션 4: 함수와 타입
> 수강일: 2025.10.24

---

## 🧩 섹션 개요
- **섹션 목표:**
  - 함수의 타입 선언, 타입 호환성, 오버로딩, 사용자 정의 타입 가드를 통해 **함수 중심의 타입 안정성**을 확보하는 방법을 학습한다.
- **핵심 학습 포인트:**
  - 함수 선언 및 표현식의 타입 정의
  - 호출 시그니처의 이해
  - 함수 간의 타입 호환 규칙
  - 함수 오버로딩 구현 패턴
  - 사용자 정의 타입 가드 활용

---

## 📌 강의별 정리

### 🔹 강의 1: 함수 타입
- **핵심 내용:**
  - 함수 선언식과 화살표 함수에서 타입을 명시하는 방법
  - 선택적 매개변수(`?`)와 필수 매개변수의 위치 규칙
  - 나머지 매개변수(`...rest`)의 타입 선언
- **코드 예제:**
  - 함수 선언식과 화살표 함수 타입 정의 예제
    ```ts
    // 1) 함수 선언식
    function func(a: number, b: number): number {
      return a + b;
    }

    /**
     * 2) 화살표 함수
     */
    const add = (a: number, b: number): number => a + b;
    ```
  - 함수의 매개변수 위치 규칙 예제
    ```ts
    function introduce(name = '이정환', tall?: number) {
      console.log(`name: ${name}`);
      if (typeof tall === 'number') {
        console.log(`tall: ${tall}`);
      }
    }

    introduce('이정환', 175);
    introduce('이정환');
    ```
  - `...rest` 예제
    ```ts
    function getSum(...rest: number[]) {
      return rest.reduce((acc, cur) => acc + cur, 0);
    }

    getSum(1, 2, 3);
    getSum(1, 2, 3, 4, 5);

    ```
- **내가 이해한 포인트:**
  - TS에서는 함수의 매개변수와 반환값에 명시적으로 타입을 지정해야 한다.
  - 선택적 매개변수(`?`)는 필수 매개변수 뒤에 위치해야 한다.
  - 나머지 매개변수(`...rest`)는 배열 형태로 자동 추론되므로 타입을 지정할 때 `number[]`와 같이 선언한다.
---

### 🔹 강의 2: 함수 타입 표현식과 호출 시그니처
- **핵심 내용:**
  - `type` 키워드를 사용해 함수의 타입을 별도로 정의할 수 있다.
  - 호출 시그니처(Call Signature)는 객체 타입 문법으로 함수 타입을 표현하는 또 다른 방법이다.
- **코드 예제:**
  - 함수 타입 표현식 예제
    ```ts
    const add0 = (a: number, b: number) => a + b;
    // ⬇️
    type Operation = (a: number, b: number) => number;
    const add1: Operation = (a, b) => a + b;
    const sub1: Operation = (a, b) => a - b;
    const multiply1: Operation = (a, b) => a * b;
    const divide1: Operation = (a, b) => a / b;
    ```
  - 호출 시그니처 예제
    ```ts
    type Operation2 = {
      (a: number, b: number): number;
    };

    const add2: Operation2 = (a, b) => a + b;
    const sub2: Operation2 = (a, b) => a - b;
    const multipl2: Operation2 = (a, b) => a * b;
    const divide2: Operation2 = (a, b) => a / b;
    ```
- **내가 이해한 포인트:**
  - 함수의 타입을 재사용하기 위해 함수 타입 표현식을 사용한다.
  - 호출 시그니처는 **객체 타입 문법으로 함수 구조를 정의**하는 방식이며, 주로 **함수를 속성으로 갖는 객체 타입**에서 사용된다.
  - 두 방식 모두 함수의 시그니처(매개변수 타입, 반환 타입)를 명시할 수 있으며, 상황에 따라 가독성을 고려해 선택한다.

---

### 🔹 강의 3: 함수 타입의 호환성
- **핵심 내용:**
  - 두 함수가 서로 대입될 수 있는지를 판단할 때는 **매개변수 타입**과 **반환값 타입**을 기준으로 본다.
  - **반환값 호환성:**
    - 반환값은 서브타입 → 슈퍼타입(업캐스팅) 가능
    - 반대로 슈퍼타입 → 서브타입(다운캐스팅) 불가능
  - **매개변수 호환성:**
    - 매개변수는 반대로, 슈퍼타입 → 서브타입(다운캐스팅) 만 가능
  - 매개변수의 개수가 다른 경우, 매개변수가 적은 함수만 호환된다.
- **코드 예제:**
  - 반환값 호환성 예제
    ```ts
    type A = () => number;
    type B = () => 10;

    let a: A = () => 10;
    let b: B = () => 10;

    a = b; // ✅ 가능 (10은 number의 하위 타입)
    // b = a; // ❌ 불가능 (number는 10보다 상위 타입)
    ```
  - 매개변수 호환성 예제
    ```ts
    // 1. 매개변수의 개수가 같을 때
    type C = (value: number) => void;
    type D = (value: 10) => void;

    let c: C = (value) => undefined;
    let d: D = (value) => undefined;

    // c = d; // ❌ 업캐스팅 불가
    d = c; // ✅ 다운캐스팅 가능

    type Animal = {
      name: string;
    };

    type Dog = {
      name: string;
      color: string;
    };

    let animalFunc = (animal: Animal) => {
      console.log(animal.name);
    };

    let dogFunc = (dog: Dog) => {
      console.log(dog.name);
      console.log(dog.color);
    };

    // animalFunc = dogFunc; // ❌
    dogFunc = animalFunc; // ✅
    ```

    ```ts
    // 2. 매개변수의 개수가 다를 때
    type Func1 = (a: number, b: number) => void;
    type Func2 = (a: number) => void;

    let func1: Func1 = (a, b) => undefined;
    let func2: Func2 = (a) => undefined;

    func1 = func2; // ✅ 매개변수가 적은 쪽만 가능
    // func2 = func1; // ❌
    ```
- **내가 이해한 포인트:**
  - 함수 타입 호환은 할당 대상 함수가 더 많은 걸 받아도 괜찮은지 관점에서 판단한다.
  - 즉, 매개변수는 적은 쪽이 더 안전하고, 반환값은 넓은 쪽이 더 안전하다.

---

### 🔹 강의 4: 함수 오버로딩
- **핵심 내용:**
  - 오버로딩
    - 같은 함수 이름으로 **매개변수의 개수나 타입에 따라 다른 동작을 정의**하는 문법이다.
    - 구조
      1. 여러 개의 **오버로드 시그니처** 선언
      2. 하나의 구현부 작성
    - 호출 시 타입 검사는 **구현부가 아닌 오버로드 시그니처를 기준**으로 수행된다.
- **코드 예제:**
  ```ts
  // 오버로드 시그니처
  function func(a: number): void;
  function func(a: number, b: number, c: number): void;

  // 실제 구현부
  function func(a: number, b?: number, c?: number) {
    if (typeof b === 'number' && typeof c === 'number') {
      console.log(a + b + c);
    } else {
      console.log(a * 20);
    }
  }

  // func(); // ❌ 매개변수 누락
  func(1); // ✅ 20 출력
  // func(1, 2); // ❌ 정의되지 않은 시그니처
  func(1, 2, 3); // ✅ 6 출력
  ```
- **내가 이해한 포인트:**
  - 오버로드 시그니처는 실제 구현부보다 함수를 어떻게 호출할 수 있는가를 정의한다.
  - 구현부는 단 하나만 존재하며, 내부에서 조건문 등을 이용해 분기한다.
- **실무/프로젝트 적용 아이디어:**
  - 매개변수 타입에 따라 다른 반환 타입을 지정할 때 유용하다.
  예: `getData(id: number): User`, `getData(ids: number[]): User[]`

---


### 🔹 강의 5: 사용자 정의 타입 가드
- **핵심 내용:**
  - TS는 일반적인 조건문으로는 타입을 완벽히 좁히지 못하는 경우가 있다.
  - 이 때, 사용자 정의 타입 가드를 사용한다.
  - `animal is Dog` 형태의 반환 타입을 가지는 함수를 정의하면, TS가 함수 호출 결과를 기반으로 타입 좁히기를 수행한다.
- **코드 예제:**
  ```ts
  type Dog = {
    name: string;
    isBark: boolean;
  };

  type Cat = {
    name: string;
    isScratch: boolean;
  };

  type Animal = Dog | Cat;

  // 사용자 정의 타입 가드
  function isDog(animal: Animal): animal is Dog {
    return (animal as Dog).isBark !== undefined;
  }

  function isCat(animal: Animal): animal is Cat {
    return (animal as Cat).isScratch !== undefined;
  }

  function warning(animal: Animal) {
    if (isDog(animal)) {
      console.log(`${animal.name}는 짖을 수 있습니다!`);
    } else if (isCat(animal)) {
      console.log(`${animal.name}는 긁을 수 있습니다!`);
    }
  }
  ```
- **내가 이해한 포인트:**
  - `animal is Dog` 같은 반환 타입은 TS에게 이 함수가 true를 반환하면 `animal`은 `Dog` 타입임을 알려주는 역할을 한다.
  - `in` 연산자나 `typeof`로 구분하기 어려운 복합 유니언 타입에서 특히 유용하다.
---

# 🎯 한 입 크기로 잘라 먹는 타입스크립트 - 섹션 5: 인터페이스
> 수강일: 2025.10.24

---

## 🧩 섹션 개요
- **섹션 목표:**
  - 인터페이스의 개념과 문법을 이해하고, 타입 별칭과의 차이, 확장, 선언 합침 등을 통해 **객체 구조를 유연하고 안전하게 정의하는 방법**을 학습한다.
- **핵심 학습 포인트:**
  - 인터페이스와 타입 별칭의 차이
  - 함수 시그니처를 포함한 객체 구조 정의
  - 인터페이스 확장(`extends`)과 다중 상속
  - 인터페이스 선언 합침(Declaration Merging)
---

## 📌 강의별 정리

### 🔹 강의 1: 인터페이스
- **핵심 내용:**
  - **인터페이스**
    - 타입 별칭(`type`)처럼 타입에 이름을 붙이지만, **객체의 구조를 정의하는 데 특화된 문법**이다.
    - 인터페이스는 상속, 합침, 함수 시그니처 정의 등의 추가 기능을 지원한다.
    - 인터페이스 내에서 함수 타입은 두 가지 방식으로 표현이 가능하다.
      1. 함수 타입 표현식
      2. 호출 시그니처 - 오버로드 시그니처 사용 가능
  - 헝가리안 표기법(`Iperson`, `IDog`)은 선택 사항이며, 팀 컨벤션에 따라 사용한다.
- **코드 예제:**
  ```ts
  interface Person {
    name: string;
    age?: number;
    // 1️⃣ 함수 타입 표현식
    // sayHi?: () => void;
    // 2️⃣ 호출시그니처 이용(오버로드 지원)
    sayHi?(): void;
    sayHi?(a: number, b: number): void;
  }

  const person: Person = {
    name: '이정환',
    sayHi: () => {
      console.log('Hi');
    },
  };
  ```
- **내가 이해한 포인트:**
  - `interface`는 객체의 구조를 명확하게 표현할 수 있는 도구이며, 선택적 속성(`?`)도 선언 가능하다.
  - 함수 타입을 정의할 때 호출 시그니처를 사용하면 **오버로딩 시그니처**를 지원할 수 있다.

---

### 🔹 강의 2: 인터페이스 확장하기
- **핵심 내용:**
  - `extends` 키워드를 사용하면 인터페이스를 상속할 수 있다.
  - 확장된 인터페이스는 부모 인터페이스의 모든 속성을 포함하며, 필요한 경우 **서브 타입으로 재정의**할 수도 있다.
  - `type`으로 정의된 타입도 인터페이스가 상속(`extends`)할 수 있다.
  - 다중 상속도 가능하다.
- **코드 예제:**
  ```ts
  interface Animal {
    name: string;
    color: string;
  }

  interface Dog extends Animal {
    // name: number; ❌ // 원본 타입의 서브 타입으로만 재정의 가능
    isBark: boolean;
  }

  type Animal2 = {
    name: string;
    color: string;
  };

  // ⭕️ 타입별칭으로 정의한 타입도 상속받을 수 있다.
  interface Dog2 extends Animal2 {}

  const dog: Dog = {
    name: 'hello',
    color: '',
    isBark: true,
  };

  interface Cat extends Animal {
    isScratch: boolean;
  }

  interface Chicken extends Animal {
    isFly: boolean;
  }

  // 다중 확장
  interface DogCat extends Dog, Cat {}

  const dogCat: DogCat = {
    name: '댕냥이',
    color: 'white',
    isBark: true,
    isScratch: true,
  };
  ```
- **내가 이해한 포인트:**
  - `extends`를 통해 코드 중복을 줄이고, 계층적으로 타입을 구성할 수 있다.
  - 다중 확장은 여러 타입의 특성을 조합할 때 유용하지만, 속성 이름이 충돌하지 않도록 주의해야 한다.
- **실무/프로젝트 적용 아이디어:**
  - UI 컴포넌트 공통 Props 정의 예시
    ```ts
    interface BaseProps {
      id: string;
      className?: string;
    }

    interface ButtonProps extends BaseProps {
      onClick: () => void;
    }

    interface InputProps extends BaseProps {
      value: string;
      onChange: (v: string) => void;
    }

    ```
---

### 🔹 강의 3: 인터페이스 합치기
- **핵심 내용:**
  - 동일한 이름의 `interface`가 여러 번 선언되면, 자동으로 병합된다.
  - 단, 중복된 프로퍼티의 타입이 다르면 충돌이 발생한다.
  - 이 특성은 라이브러리 타입 보강 등에 자주 사용된다.
- **코드 예제:**
  - 선언 합침 예시
    ```ts
    interface Person {
      name: string;
    }

    interface Person {
      age: number;
    }

    const person: Person = {
      name: '',
      age: 27,
    };
    ```
  - 모듈 보강 예시
    ```ts
    interface Lib {
      a: number;
      b: number;
    }

    interface Lib {
      c: string;
    }

    const lib: Lib = {
      a: 1,
      b: 2,
      c: 'hello',
    };
    ```
- **내가 이해한 포인트:**
  - 인터페이스는 중복 선언 시 자동으로 병합되며, 모든 속성이 하나로 합쳐진다.
  - 같은 이름의 인터페이스를 여러 곳에서 확장하며 모듈 보강 형태로 사용 가능하다.
  - 반면 `type`은 동일한 이름으로 중복 선언이 불가능하다.
- **실무/프로젝트 적용 아이디어:**
  - 외부 라이브러리 타입 정의 보강 시 유용하다.
---




