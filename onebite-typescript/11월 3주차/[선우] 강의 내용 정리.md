# 🎯 [한 입 크기로 잘라 먹는 Next.js] - 섹션 3: Page Router 핵심 정리
> 수강일: 2025.11.03 ~ 2025.11.08

---

## 🧩 섹션 개요
- **섹션 목표:**
  - Next.js의 Page Router의 구조와 동작 원리를 명확히 이해하고, 라우팅﹒사전 렌더링﹒데이터 페칭﹒레이아웃 구성 등의 핵심 매커니즘을 체계적으로 익힌다.
  - SSR﹒SSG﹒ISR 등 렌더링 전략을 Page Router 환경에서 적절히 선택하고 적용할 수 있도록 한다.
  - App Router 대비 Page Router가 제공하는 장점﹒제약을 파악하며, 서비스 환경에 맞는 라우팅 설계를 수행할 수 있도록 한다.
- **핵심 학습 포인트:**
  - `pages/` 기반의 라우팅 방식과 동적 라우팅 규칙
  - `useRouter` 훅을 통한 클라이언트 네비게이션 및 쿼리 파라미터 처리 방식
  - `<Link>` 기반 CSR 전환과 Prefetching 매커니즘
  - Page Router에서의 전역 레이아웃 구성 방식
  - CSS Module 및 글로벌 스타일 적용 규칙
  - API Routes 구조와 서버 전용 코드 실행 방식
  - SSR/SSG/ISR 렌더링 전략의 적용 조건과 컴포넌트 실행 흐름
  - 동적 SSG에서 `getStaticPaths` 및 `fallback` 옵션을 통한 확장성 처리 방식
  - SEO 메타 태그 설정 시 fallback 페이지, SSG/SSR의 영향 고려
  - Page Router의 장단점 및 App Router와의 구조적 차이
---

## 📌 강의별 정리

### 🔹 강의 1: Page Router를 소개합니다
- **핵심 내용:**
  - **Page Router**
    - 안정적으로 검증된 Next.js 라우팅 방식(App Router 이전 세대)
    - `pages/` 폴더 구조 = 라우팅 구조
    ![](https://velog.velcdn.com/images/iamsunwoo/post/4e3a236b-3708-46e9-afed-9b870b9d4d7d/image.png) 
    - `[param].tsx` → 동적 라우팅 ![](https://velog.velcdn.com/images/iamsunwoo/post/b75045bd-d4cd-4310-9cf8-6207b26e0ea7/image.png)
    - `_app.tsx`
      - 모든 Page 컴포넌트의 루트 역할
      - 글로벌 레이아웃 / 글로벌 스타일 / 공통 로직 적용
    - `_document.tsx`
      - `<html>`, `<body>` 수준 레이아웃 설정
      - 메타 태그, 폰트, 초기 구조 지정
    - `next.config.mjs`
      - Next.js 전역 설정 파일
      - 개발 시에는 `reactStrictMode`를 `false`로 설정
    
- **코드 예제:**
  - **Page Router 기반의 Next 프로젝트 생성**
    ```bash
    npx create-next-app@14 [project-name]
    ```
  - `_app.tsx`
    ```typescript
    // Component: 페이지 역할을 할 컴포넌트
    // pageProps: Component에 전달할 속성들
    export default function App({ Component, pageProps }: AppProps) {
      return <Component {...pageProps} />;
    }
    ```
- **내가 이해한 포인트:**
  - Page Router는 `pages/`의 폴더ㆍ파일이 라우팅 기준
  - `_app`은 최상위 React 트리, `_document`는 HTML 레벨
  - App Router 등장 이후에도 Page Router는 여전히 운영 중인 레거시 서비스에서 중요
---

### 🔹 강의 2: 페이지 라우팅 설정하기
- **핵심 내용:**
  - `useRouter`
    - Page Router에서 사용 시 `next/router` 경로의 훅을 사용한다.
    - 해당 훅으로 query, path 파라미터에 접근할 수 있다.
    - CSR 환경이기 때문에 최초 렌더 시에는 `useRouter().query` 값이 아직 준비되지 않은 상태이며, hydration이 완료된 이후에 다시 렌더링되며 query 값이 주입된다.
  - **기본 동적 페이지**
    - `[id].tsx` → `/book/1`
  - **catch-all segment**
    - `[...slug].tsx` → 다단계 경로 수집
  - **optional catch-all segment**
    - `[[...slug]].tsx` → catch-all + 해당 경로 인덱스까지 대응
- **내가 이해한 포인트:**
  - CSR 특성으로 인해 `useRouter` 훅은 최초 렌더시에 `undefined` 일 수 있다.
- **실무/프로젝트 적용 아이디어:**
  - URL 기반 검색/필터 값 추출 시 `useRouter` 적극 활용
---

### 🔹 강의 3: 네비게이팅
- **핵심 내용:**
  - `<Link>`로 페이지 전환 시 CSR 방식으로 이동한다.
  - `useRouter().push()`, `useRouter().replace()`로 프로그래매틱 이동이 가능하다.
    - 브라우저 히스토리 사용 방식에 차이가 있다.
- **내가 이해한 포인트:**
  - a 태그로 페이지 이동 시 SSR 방식으로 새 요청이 이루어진다.
  - Link는 CSR 네비게이션 + prefetch 연계가 강하다.
- **실무/프로젝트 적용 아이디어:**
  - 로그인 완료 → `useRouter().replace()` 로 뒤로가기 이동이 불가능하게 만든다.

---

### 🔹 강의 4: 프리패칭
- **핵심 내용:**
  - **Prefetching**
    - 현재 사용자가 보고 있는 페이지에서 이동할 가능성이 있는 모든 페이지의 JS Bundle을 미리 불러온다.
    - `<Link>`가 뷰포트에 노출되면 자동으로 Prefetching이 진행된다.
    - 프로그래매틱한 이동은 자동으로 Prefetching이 되지 않으므로
  `useRouter`의 `prefetch` 함수의 매개변수로 Prefetch를 원하는 경로의 이름을 전달한다.
    - 개발 모드에서는 Prefetch가 되지 않으므로 빌드 후에 확인한다.
    - Prefetching을 원하지 않는 페이지의 경우 `Link` 컴포넌트의 `prefetch` 값을 `false`로 설정한다.
    ![](https://velog.velcdn.com/images/iamsunwoo/post/464ad907-5f72-4265-bfad-a1ff250dda16/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/fa2fe6d6-ed77-4869-b3d8-8a4744a3121c/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/7f3ced33-b733-4032-9946-2b69000ce6ea/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/79863249-028b-4515-9add-071fbb14792a/image.png)

- **코드 예제:**
  ```ts
  export default function App({ Component, pageProps }: AppProps) {
    const router = useRouter();

    useEffect(() => {
      router.prefetch('/test');
    }, []);

    const onClickButton = () => {
      router.push('/test');
    };
    return (
      <>
        <header>
          <Link href={'/'}>index</Link>
          <Link href={'/search'}>search</Link>
          <Link href={'/book/1'}>book/1</Link>
          <div>
            <button onClick={onClickButton}>/test 페이지로 이동</button>
          </div>
        </header>
        <Component {...pageProps} />
      </>
    );
  }
  ```
- **내가 이해한 포인트:**
  - Prefetching은 사용자의 다음 액션을 예측해 미리 JS bundle을 가져오는 기능이다.
---

### 🔹 강의 5: API Routes
- **핵심 내용:**
  - **API Routes**
    - Next.js에서 백엔드 API를 만들 수 있는 기능
    - `pages/api/*` 이하 파일은 서버에서만 실행된다.
    - 브라우저 요청 시 해당 파일의 코드가 실행되어 JSON 응답을 반환
    - 주로 Mock API, 간단한 서버 로직 등에 사용
  - `pages/api/hello.ts` 예시
  → `localhost:3000/api/hello/` 접속 시 JSON 응답
- **코드 예제:**
  ```ts
  import type { NextApiRequest, NextApiResponse } from 'next';

  export default function handler(req: NextApiRequest, res: NextApiResponse) {
    const date = new Date();
    res.json({ time: date.toLocaleString() });
  }
  ```
- **내가 이해한 포인트:**
  - 프론트 + 백엔드 기능을 동시에 제공해 작은 API는 별도 서버 없이 구현 가능
- **질문/토론거리:**
  - Next API Routes가 실제로 많이 사용 되는가? 보통 별도의 BE 서버로 분리되지 않나?

---

### 🔹 강의 6: 스타일링
- **핵심 내용:**
  - 글로벌 CSS(`*.css` 등)은 `_app.tsx`에서만 import 가능 (스타일 충돌 방지)
  ![](https://velog.velcdn.com/images/iamsunwoo/post/7fb53ac7-faa8-488b-b5f2-bb84ca5eca1b/image.png)
  - 페이지/컴포넌트 스타일은 **CSS Module(`*.module.css`)** 사용
  - CSS Module은 컴파일 시 className이 고유 해시값으로 매핑되어 충돌 방지
  ![](https://velog.velcdn.com/images/iamsunwoo/post/b0d800c9-953f-479c-8ace-22c63db9964e/image.png)
  - Next.js는 기본적으로 CSS/SCSS Module 지원

- **코드 예제:**
  ```ts
  import style from './index.module.css';

  export default function Home() {
    return (
      <>
        <h1 className={style.h1}>Index</h1>
        <h2 className={style.h2}>H2</h2>
      </>
    );
  }
  ```
- **내가 이해한 포인트:**
  - 글로벌 스타일은 ResetㆍTheme 수준에서만 사용해야 유지보수에 유리
- **질문/토론거리:**
  - 각자 선호하는 스타일링 라이브러리

---

### 🔹 강의 7: 글로벌 레이아웃 설정하기
- **핵심 내용:**
  - `_app.tsx`는 전체 페이지의 전역 Layout 및 Provider 등록 위치
  - 페이지 이동 시 `_app.tsx`는 유지되고 child만 바뀐다.
  - 전역 상태관리ㆍ스타일ㆍheader/footer 배치 위치
- **코드 예제:**
  - `pages/_app.tsx`
  ```ts
  import '@/styles/globals.css'

  export default function App({ Component, pageProps }) {
    return <Component {...pageProps} />
  }
  ```
---

### 🔹 강의 8: 페이지별 레이아웃 설정하기
- **핵심 내용:**
  - `_app.tsx`에서 각 페이지별로 다른 레이아웃 구성이 가능하다.
  - `Component.getLayout` 패턴 사용
  - 필요할 때만 페이지 독자 레이아웃을 적용한다.
- **코드 예제:**
  ```ts
  import GlobalLayout from '@/components/global-layout';
  import '@/styles/globals.css';
  import { NextPage } from 'next';
  import type { AppProps } from 'next/app';
  import { ReactNode } from 'react';

  type NextPageWithLayout = NextPage & {
    getLayout?: (page: ReactNode) => ReactNode;
  };

  export default function App({
    Component,
    pageProps,
  }: AppProps & { Component: NextPageWithLayout }) {
    const getLayout = Component.getLayout ?? ((page: ReactNode) => page);

    return <GlobalLayout>{getLayout(<Component {...pageProps} />)}</GlobalLayout>;
  }
  ```
- **내가 이해한 포인트:**
  - 관리자/사용자 화면 분리, 상세 페이지 독자 UI 등에 유용
---
### 🔹 강의 9: 한입북스 UI 구현하기
---

### 🔹 강의 10: 사전 렌더링과 데이터페칭
- **핵심 내용:**
  - Next.js는 데이터 준비 방식에 따라 사전 렌더링 전략 선택이 가능하다.
    - `SSR(getServerSideProps)` → 요청 때마다 사전 렌더링
    ![](https://velog.velcdn.com/images/iamsunwoo/post/e0a5c5b7-b82d-4d7c-96d9-637743175505/image.png)
    - `SSG(getStaticProps)` → 빌드 타임 HTML 생성(Fecthing할 데이터 양이 많을 때 사용)
    ![](https://velog.velcdn.com/images/iamsunwoo/post/97269553-e2cd-46b2-8a92-18e3fa28c238/image.png)
    - `ISR` → 빌드 후 주기적으로 페이지 재생성
- **내가 이해한 포인트:**
  - 페이지 특성에 따라 렌더링 전략을 선택하는 게 핵심이다.
  - 큰 데이터나 자주 변하는 데이터는 CSR/SSR 조합이 필요하다.

---

### 🔹 강의 11: SSR 1. 소개 및 실습
- **핵심 내용:**
  - **SSR(Server Side Rendering)**
    - Next.js의 대표적인 사전 렌더링 방식
    - **요청 시 마다 서버에서 HTML을 생성**하여 클라이언트에 전달
  - `getServerSideProps`
    - 요청이 들어오면 **페이지 컴포넌트보다 먼저 실행되는 함수**
    - 함수 내부에서 데이터를 fetch하고, 결과를 **props로 반환**
    - 서버에 환경에서 동작하기 때문에 Web API를 사용할 수 없다.
    - 반환 형식은 반드시 `{ props: { ... } }`로 `props` 프로퍼티를 포함한 객체여야 한다.
    - 페이지 컴포넌트 매개변수 타입 지정 시 `InferGetServerSidePropsType<typeof getServerSideProps>` 사용
    → getServerSideProps의 반환 타입을 자동 추론(`infer`)
  - **SSR 컴포넌트 실행 흐름**
    - 서버에서 한 번 렌더링(HTML 생성)
    - 클라이언트에서 다시 한 번 실행(Hydration)
- **코드 예제:**
  - `index.tsx`
    ```ts
    export const getServerSideProps = () => {
      const data = 'hello';
      return {
        props: {
          data,
        },
      };
    };
    export default function Home({
      props,
    }: InferGetServerSidePropsType<typeof getServerSideProps>) {
    ```
- **내가 이해한 포인트:**
  - SSR은 **요청 시점에 최신 데이터를 반영해야 하는 페이지에 적합**하다.
  - SEO가 중요한 페이지나 로그인 사용자 맞춤 데이터를 초기부터 내려야할 때 사용한다.
- **실무/프로젝트 적용 아이디어**
  - 로그인 후 사용자 대시보드 초기 데이터 SSR 제공
  - SEO가 중요한 콘텐츠 상세 페이지(블로그 글 등)

---


### 🔹 강의 12: SSR 2. 실습
- **핵심 내용:**
  - `Promise.all`
    - 여러 비동기 요청을 병렬로 실행하여 SSR 데이터 로딩 속도 최적화
  - `getServerSideProps`에서 동적 라우팅값 접근
    - 매개변수에 `context: GetServerSidePropsContext` 선언
    - `context.params` 또는 `context.query`로 URL 파라미터에 접근할 수 있다.
    - 인자로 받은 모든 함수를 동시에 실행한다.
  - SSR 컴포넌트의 getServerSideProps 함수 내에서 현재 페이지의 파라미터 값에 접근할 때에는 매개변수에 `context: GetServerSidePropsContext` 작성 후 `context`의 `params` 또는 `query`에 접근
- **코드 예제:**
  ```ts
  import { GetServerSidePropsContext, InferGetServerSidePropsType } from 'next';

  export const getServerSideProps = async (context: GetServerSidePropsContext) => {
    const { id } = context.params ?? {};

    const [post, comments] = await Promise.all([
      fetch(`https://example.com/posts/${id}`).then(res => res.json()),
      fetch(`https://example.com/posts/${id}/comments`).then(res => res.json()),
    ]);

    return {
      props: { post, comments },
    };
  };

  export default function PostPage({
    post,
    comments,
  }: InferGetServerSidePropsType<typeof getServerSideProps>) {
    return (
      <>
        <h1>{post.title}</h1>
        <ul>
          {comments.map((c: any) => (
            <li key={c.id}>{c.text}</li>
          ))}
        </ul>
      </>
    );
  }
  ```
- **내가 이해한 포인트:**
  - SSR 환경에서도 **동시 요청 최적화가 중요**하다.
  - 라우팅 파라미터를 통해 서버 단계에서 페이지 데이터를 결정할 수 있다.

---

### 🔹 강의 13: SSG 1. 소개
- **핵심 내용:**
  - `SSG(Static Site Generation, 정적 사이트 생성)`
    - **SSR의 단점을 보완하는 대표적인 사전 렌더링 방식**으로, 페이지를 매 요청마다 서버에서 렌더링하지 않는다.
    - 빌드 타임에 단 한 번 HTML을 사전 렌더링해두고, 이후 모든 요청에는 동일한 정적 파일을 즉시 반환한다.
    - 초기 렌더링 시간이 오래 걸리는 페이지라도, 사전 렌더링이 끝난 뒤에는 매우 빠른 속도로 응답할 수 있다.
    - 단, 모든 요청에 동일한 페이지를 제공하기 때문에 최신 데이터 반영이 어렵다.
    - 데이터 변경 주기가 잦는 페이지보다는, 콘텐츠가 고정적이거나 변경 빈도가 낮은 정적 페이지에 적합하다.
    - 즉, 성능 최적화 측면에서 한 번 생성 → 계속 재사용 패턴이 유리한 페이지에 사용하는 방식이다.
    ![](https://velog.velcdn.com/images/iamsunwoo/post/94b658c2-9395-4bf5-b79c-feeb0db8d642/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/7f3065fa-d240-4360-a6d2-0208b27207c3/image.png)
- **내가 이해한 포인트:**
  - SSG는 서버가 요청마다 렌더링하지 않기 때문에 **SSR 대비 비용﹒부하가 현저히 낮고**, 성능 측면에서 가장 유리하다.
  - 핵심은 **빌드 타임에 페이지가 렌더링 된다는 점**이다.
- **실무/프로젝트 적용 아이디어:**
  - 회사 소개, 서비스 소개, 이벤트 랜딩 페이지처럼 **변경이 거의 없고 방문 수는 많은 페이지**가 SSG로 동작하면 서버 비용과 성능이 크게 개선된다.
---

### 🔹 강의 14: SSG 2. 정적 경로에 적용하기
- **핵심 내용:**
  - 페이지 컴포넌트에 `getStaticProps`를 선언하면 해당 페이지는 **SSG** 방식으로 사전 렌더링된다.
  - SSG는 빌드 타임에 HTML을 생성하기 때문에, 개발 모드에서는 SSG 동작 여부를 확인할 수 없다.
  - 따라서, 빌드 후 Prod 모드에서 실제 SSG가 적용되는지 확인해야 한다.
  - **빌드 결과**
  ![](https://velog.velcdn.com/images/iamsunwoo/post/af817c30-2238-48d5-ba9b-33e4e95fa630/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/27cb175b-f6bb-4f29-b286-83c88b288087/image.png)
    - `Static`
      - SSR﹒SSG 설정이 없는 페이지는 Next.js에 의해 정적으로 사전 렌더링되며, 사실상 SSG에 가까운 정적 페이지로 처리된다.
    - `Dynamic`
      - 요청 시마다 서버에서 페이지를 생성한다는 의미로, 사실상 **SSR**로 동작하는 페이지를 말한다.
  - SSG는 빌드 타임에 HTML을 만들기 때문에, 쿼리 스트링에는 접근할 수 없다.
  - 따라서, 쿼리 스트링 기반 UI는 사전 렌더링을 포기하고, 클라이언트 측에서 컴포넌트 마운트 시 `useEffect` 등을 통해 직접 처리하는 방식이 필요하다.

- **코드 예제:**
  ```ts
  export const getStaticProps = async () => {
    const [allBooks, recoBooks] = await Promise.all([
      fetchBooks(),
      fetchRandomBooks(),
    ]);

    return {
      props: {
        allBooks,
        recoBooks,
      },
    };
  };
  ```
- **내가 이해한 포인트:**
  - `getStaticProps`가 선언된 순간, 해당 페이지는 빌드 타임 렌더링이 확정된다.
  - 개발 환경에서는 항상 SSR처럼 동작하기 때문에, 실제 SSG가 잘 되었는지 확인하려면 빌드(`npm run build`) → 실행(`npm run start`) 해야 한다.
---

### 🔹 강의 15: SSG 3. 동적 경로에 적용하기
- **핵심 내용:**
  - 도서 상세 페이지(`book/1`)처럼 **URL Parameter(동적 경로)**를 사용하는 페이지에 SSG를 적용하려면, **빌드 타임에 미리 생성할 수 있는 모든 경로를 사전에 정의**해야 한다.
  - 이 역할을 담당하는 함수가 `getStaticPaths`이며, 해당 함수에서 SSG로 생성할 경로 목록을 선언한다.
  - `getStaticPaths`
    - 해당 함수의 반환값은 두 가지 속성을 포함하는 하나의 객체이다.
    - `paths`
      - `{ params: { ... } }` 형태의 객체 배열로, **빌드 시 생성할 경로 목록**을 나타낸다.
    - `fallback`
      - **정의되지 않은 경로로 접근했을 때 어떻게 동작할지를 설정**하는 옵션이다.
    - URL 파라미터는 모두 문자열로 처리되므로, 숫자여도 문자열로 넘겨야 한다.
  ![](https://velog.velcdn.com/images/iamsunwoo/post/f49c2db4-2c9a-429a-be9e-d837e7feb9ff/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/fd5a85ba-db8d-47af-ae5e-2d87fb830868/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/786144c7-8533-495b-a6ba-eaf643872d50/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/067943e1-bdc5-4ecb-b555-13c5309ce509/image.png)
- **코드 예제:**
  ```ts
  export const getStaticPaths = () => {
    return {
      // 빌드 시 사전 렌더링할 URL 경로 목록
      paths: [
        { params: { id: '1' } },
        { params: { id: '2' } },
        { params: { id: '3' } },
      ],
      // fallback 옵션
      fallback: false,
    };
  };
  ```
- **내가 이해한 포인트:**
  - `getStaticPaths`는 사전 렌더링 가능한 모든 동적 경로를 선언하는 곳이며, SSG 방식이 동적 페이지에 적용되려면 반드시 필요하다.
  - Next.js는 `paths`에 지정된 경로만 SSG로 미리 생성하고, 그 외 경로는 `fallback` 옵션에 따라 다르게 처리한다.
  - URL 파라미터 기반 페이지에서는 **쿼리 스트링이 아닌 Query Parameter**만 **SSG로 대응**할 수 있다.
- **실무/프로젝트 적용 아이디어:**
  - 상품 상세 페이지, 게시글 상세 페이지처럼 **id** 값이 명확히 존재하고, 목록도 예측 가능한 경우 SSG를 적극 적용할 수 있다.
---

### 🔹 강의 16: SSG 4. 폴백옵션 설정하기
- **핵심 내용:**
  - `fallback`
    - `getStaticPaths`에 등록되지 않은 경로를 들어왔을 때의 동작 방식을 정의하는 옵션이다.
    - `false`
      - 정의되지 않은 경로 접근 시 즉시 **404 Not Found**를 반환한다.
      - 모든 경로를 paths에 미리 정의할 수 있을 때 사용한다.
      ![](https://velog.velcdn.com/images/iamsunwoo/post/8c27b663-6288-49a3-9d52-0833ec835a40/image.png)
    - `blocking`
      - paths에 없는 경로에 접근하면 **SSR**처럼 서버에서 즉시 페이지를 생성한 후 완성된 HTML을 반환한다.
      - 최초 한 번만 SSR로 생성되고, 이후 요청부터는 SSG 페이지처럼 캐싱된 정적 파일을 사용한다.
      - 새로운 데이터가 계속 추가되는 서비스(상품 상세, 게시글 상세 등)에 적합하다.
      - 다만 페이지 생성에 시간이 오래 걸릴 경우, 사용자 입장에서 첫 요청이 느려질 수 있다.
      ![](https://velog.velcdn.com/images/iamsunwoo/post/bf764c1c-6115-4902-976b-43eb1cf4f1a4/image.png)
    - `true`
      - `blocking`과 동일하게 paths에 없는 경로를 실시간으로 생성한다.
      - 빌드 타임에 존재하지 않는 경로 접근 시 먼저 비어 있는 빌드된 페이지(SSR 없이 렌더된 최소 HTML)을 반환하고, 클라이언트 측에서 props 로딩이 완료되면 해당 페이지를 다시 hydration하여 완성한다.
      - 즉, 빈 페이지(또는 로딩 화면) → 데이터 fetch 완료 → hydration 순서로 페이지가 완성된다.
      - `blocking`보다 사용자에게 더 빠르게 피드백을 줄 수 있다.
      ![](https://velog.velcdn.com/images/iamsunwoo/post/1451c400-b41b-452e-aee3-a5f1781832b1/image.png)
      - 사전에 정의되지 않은 경로에 진입하면, 데이터가 비어 있는 fallback 상태의 페이지가 먼저 보여진다.
      - 이후 `getStaticProps`가 실행되어 props가 채워지고, 페이지가 완성된다.
      ![](https://velog.velcdn.com/images/iamsunwoo/post/ec3ec78b-78dd-4de2-a876-45f6ef505638/image.png)
- **코드 예제:**
  - **페이지가 fallback 상태일 때**
    ```ts
      const router = useRouter();

      if (router.isFallback) {
        return '로딩중입니다.';
      }
    ```
  - **입력한 경로가 잘못되었을 때**
    ```ts
    export const getStaticProps = async (context: GetStaticPropsContext) => {
      const bookId = context.params!.id as string;
      const book = await fetchOneBook(+bookId);

      if (!book) {
        return {
          notFound: true,
        };
      }

      return {
        props: {
          book,
        },
      };
    };
    ```
- **내가 이해한 포인트:**
  - fallback 옵션은 **SSG 기반 동적 라우팅의 확장성**을 위해 반드시 이해해야 하는 핵심 개념이다.
  - `false`는 정적인 페이지에만 적합하고, `blocking/true`는 무한히 늘어날 수 있는 동적 데이터에 대응하는 실용적인 전략이다.
  - fallback 상태에서 SEO가 문제가 발생할 수 있으므로, `true`를 사용하는 페이지에서는 로딩 화면이나 **기본 메타 태그 설정이 필수**이다.
- **실무/프로젝트 적용 아이디어:**
  - `true`를 사용할 때는 Skeleton UI 또는 Loader를 적용하여 UX를 개선할 수 있다.

---

### 🔹 강의 17: ISR 1. 소개 및 실습
- **핵심 내용:**
  - `ISR(Incremental Static Regeneration, 증분 정적 재생성)`
    - **기존 SSG로 생성된 정적 페이지를 일정 주기마다 다시 생성하는 기술**이다.
    - 즉, 정적 페이지가 그대로 고정되는 SSG의 단점을 해결하기 위해 등장한 방식이다.
    ![](https://velog.velcdn.com/images/iamsunwoo/post/fc5bcc8f-9ca7-4adc-95d7-63f86ce8c072/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/e8e75a6e-34e2-4115-8a6d-5b972783946a/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/e9df6b34-531e-4659-96f4-8e58ab4500af/image.png)
    - SSG처럼 아주 빠른 응답 속도를 유지하면서도, SSR처럼 데이터 최신성을 주기적으로 확보할 수 있다.
    - ISR은 `getStaticProps`의 반환값에 `revalidate`(초 단위)를 설정하는 것으로 활성화한다.
      - 설정된 시간이 지나면, 다음 사용자가 요청하는 시점에 백그라운드에서 페이지를 다시 생성한다.
      ![](https://velog.velcdn.com/images/iamsunwoo/post/6f04e79e-0110-4ac0-89de-fb1902cd2b75/image.png)
    - SSR﹒SSG﹒CSR 중 **가장 강력하고 범용성이 높은 사전 렌더링 방식**으로 평가된다.
- **코드 예제:**
  ```ts
  export const getStaticProps = async (context: GetStaticPropsContext) => {
    const bookId = context.params!.id as string;
    const book = await fetchOneBook(+bookId);

    if (!book) {
      return {
        notFound: true,
      };
    }

    return {
      props: {
        book,
      },
      revalidate: 3,
    };
  };
  ```
- **내가 이해한 포인트:**
  - ISR은 SSG의 정적 페이지 한계를 해결하기 위해 설계된 방식으로, **정적 + 최신성을 동시에 만족하는 유일한 사전 렌더링 기술**이다.
  - 설정된 revalidate 시간이 지나면 다음 요청이 들어올 때 페이지를 새로운 데이터로 다시 생성하고, 이후 요청부터는 다시 새롭게 생성된 정적 파일을 제공한다.
  - 즉, 매 요청마다 렌더링하는 SSR과 달리, ISR은 데이터가 변경될 필요가 있을 때만 정적 페이지를 업데이트한다.
- **실무/프로젝트 적용 아이디어:**
  - 인기글 리스트처럼 짧은 주기로 데이터가 변하는 페이지에서 SSR보다 훨씬 효율적이다.
---

### 🔹 강의 18: ISR 2. 주문형 재 검증
- **핵심 내용:**
  - 시간 기반의 ISR을 적용하기 어려운 페이지도 존재한다.
  - 예를 들어, 시간과 무관하게 사용자의 행동(수정/삭제/생성)에 의해 즉시 업데이트되어야 하는 페이지가 있다.
    - 커뮤니티 사이트의 게시글 상세 페이지, 댓글이 자주 업데이트되는 페이지 등
  - 이처럼, 지금 당장 업데이트가 필요한 페이지를 위해 등장한 방식이 **On-Demand ISR(요청 기반 ISR)이다.**![](https://velog.velcdn.com/images/iamsunwoo/post/448d40be-8da2-4562-9b22-0226c3973e4d/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/6217d6f7-5f5b-4cfc-9b74-eed6ce43606c/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/825cf5c9-1042-42b5-9426-af8a39528059/image.png)
  - On-Demand ISR은 Next.js의 **API Routes**를 통해 구현하며, API 핸들러 내부에서 `res.revalidate(경로)`를 호출하여 특정 페이지의 정적 파일을 즉시 재생성한다.
  - 즉, 특정 이벤트가 발생하면 백엔드 또는 CMS에서 On-Demand ISR API를 호출하여 해당 페이지만 업데이트할 수 있다.
- **코드 예제:**
  - `/api/revalidate.ts`
    ```ts
    import { NextApiRequest, NextApiResponse } from 'next';

    export default async function handler(
      req: NextApiRequest,
      res: NextApiResponse
    ) {
      try {
        await res.revalidate('/');
        return res.json({ revalidate: true });
      } catch (err) {
        res.status(500).send('Revalidation failed');
      }
    }
    ```
- **내가 이해한 포인트:**
  - On-Demand ISR은 **사용자 행동 기반으로 정적 페이지를 즉시 갱신하는 기능**으로, 시간 기반 ISR보다 훨씬 정밀한 제어가 가능하다.
  - 페이지 변경이 언제 일어날지 예측할 수 없거나, 변경 즉시 반영이 필수인 페이지에서 특히 유용하다.

---

### 🔹 강의 19: SEO 설정하기
- **핵심 내용:**
  - 페이지별로 서로 다른 메타 태그를 설정하여 기본적인 **SEO(Search Engine Optimization)**를 적용할 수 있다.
  - 메타 태그 설정은 `next/head`에서 제공하는 `Head` 컴포넌트를 사용하며, 이 안에 `<title>`, `<meta />`, `<link />`등을 정의한다.
  - 정적 페이지(SSG), SSR 페이지는 서버에서 완성된 HTML을 반환하므로 SEO 적용이 잘 이루어진다.
  - 하지만, Dynamic SSG + fallback 옵션(true) 조합에서는 주의가 필요하다.
  → fallback 상태에서는 데이터가 아직 준비되지 않은 반쪽짜리 HTML이 먼저 반환되기 때문에, **의도한 메타 태그가 즉시 반영되지 않아 SEO가 약해질 수 있다.**
  - 따라서, fallback 상태에서도 최소한의 기본 메타 태그(타이틀, og 기본 이미지 등)를 설정해두어야 한다.
- **코드 예제:**
  - **기본적인 메타태그 설정**
    ```ts
    export default function Home({
      allBooks,
      recoBooks,
    }: InferGetStaticPropsType<typeof getStaticProps>) {
      return (
        <>
          <Head>
            <title>한입북스</title>
            <meta property='og:image' content='/thumbnail.png' />
          </Head>
        </>
        ...
      )
    }
    ```
  - **fallback 상태일 때 메타태그 설정**
    ```ts
     const router = useRouter();

      if (router.isFallback) {
        return (
          <>
            <Head>
              <title>한입북스</title>
              <meta property='og:image' content='/thumbnail.png' />
              <meta property='og:title' content='한입북스' />
              <meta
                property='og:description'
                content='한입북스에 등록된 도서들을 만나보세요'
              />
              <div>로딩중입니다.</div>
            </Head>
          </>
        );
      }
    ```
- **내가 이해한 포인트:**
  - SEO는 초기 HTML에 어떤 정보가 담겨 있느냐로 결정되기 때문에, 사전 렌더링(SSR/SSG)과 궁합이 좋다.
  - 그러나 Dynamic SSG에서 `fallback: true`를 사용하는 경우, 첫 번째 요청 시 HTML은 비어 있고, 메타 데이터 역시 완성되지 않은 페이지가 먼저 반환된다.
  → 이 HTML을 크롤러가 가져가면 SEO가 정상적으로 적용되지 않는다.
  - 따라서, fallback 상태일 때도 기본 메타 태그를 넣어두는 것이 중요하다.

---

### 🔹 강의 20: 배포하기
---

### 🔹 강의 21: 페이지 라우터 정리
- **핵심 내용:**
  - **Page Router의 장점**
    - **파일 시스템 기반 라우팅 제공**
      - `pages/` 디렉토리 구조만으로 라우팅이 자동 구성되기 때문에 설정이 매우 간단하다.
    ![](https://velog.velcdn.com/images/iamsunwoo/post/c86de67f-a649-4c9c-a08c-c2e60c8e0370/image.png)
    - **여러가지 사전 렌더링 전략 지원**
      - 서비스의 특성에 맞춰, SSR, SSG, ISR을 조합해 사용할 수 있으며, 각 렌더링 방식은 다음과 같다.
      - **SSR(Server-Side-Rendering)**
        - 요청 시마다 서버에서 HTML을 생성하여 최신 데이터를 보장한다.
        ![](https://velog.velcdn.com/images/iamsunwoo/post/8bdcd005-07c7-425e-bee8-5c5f1fc5872b/image.png)
      - **SSG(Static-Site-Generation)**
        - 빌드 타임에 정적 페이지를 생성하여 빠른 응답을 제공한다.
        ![](https://velog.velcdn.com/images/iamsunwoo/post/9dd0a87a-8a12-42f1-8275-9fb9904c2e58/image.png)
      - **ISR(Incremental Static Regeneration)**
        - 정적 페이지를 주기적 또는 요청 기반으로 재생성하여 최신성과 성능을 모두 확보한다.
      ![](https://velog.velcdn.com/images/iamsunwoo/post/220a4be6-8899-4f0b-b31f-f7cc84a2270c/image.png)
   - **Page Router의 단점**
     - **페이지별 레이아웃 설정이 번거롭다.**
       - App Router의 Layout 구조와 달리, Page Router에서는 각 페이지에 반복적으로 레이아웃을 import 해야한다.
     ![](https://velog.velcdn.com/images/iamsunwoo/post/c002cacb-1841-4d86-a07a-ad5b083aa4d2/image.png)
     - **데이터 페칭 로직이 페이지 컴포넌트에 집중된다.**
       - 데이터 페칭 로직이 `getServerSideProps`·`getStaticProps`에 강하게 결합되어 있어, 페이지 컴포넌트의 책임이 커지고 재사용성이 떨어진다.
       ![](https://velog.velcdn.com/images/iamsunwoo/post/c035152a-7752-4fd0-a8f3-b0b4bd1f64c3/image.png)
     - **불필요한 컴포넌트들도 JS 번들에 포함될 수 있다.**
       - Page Router는 라우트 단위에서 tree-shaking(사용되지 않는 코드를 자동으로 제거하는 번들 최적화 기술)이 제한적이며, 일부 import는 페이지 번들에 그대로 포함되어 초기 로딩 속도를 저하시킬 수 있다.
      ![](https://velog.velcdn.com/images/iamsunwoo/post/90467ef0-a951-489f-8583-0e8c1871368d/image.png)![](https://velog.velcdn.com/images/iamsunwoo/post/c983dbd5-ebcb-4fdd-82e4-7fa3120d6312/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/2fe8536f-5214-436a-a41f-7de072dfee68/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/1f94b752-c7ca-45c2-92d5-74895bdffdba/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/79154c80-e783-4dd1-af4d-7151e29f5d6e/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/10b7e1bd-4cde-4d19-aaa4-f65f861460d5/image.png) ![](https://velog.velcdn.com/images/iamsunwoo/post/3ea07415-4f33-4f0b-8207-1d9b2f451dce/image.png)
- **내가 이해한 포인트:**
  - Page Router는 구조가 단순하고 러닝커브가 낮아 초기에 프로젝트를 진행하기 쉬운 라우팅 체계이다.
  - Page Router는 페이지 중심 설계, App Router는 컴포넌트 트리 중심 설계이다.
    - 이 차이 때문에 Page Router는 레이아웃﹒데이터 페칭 구조가 분리되지 않고 페이지에 집중된다.
  - 사전 렌더링 방식을 상황에 맞게 고를 수 있는 유연함은 큰 장점이지만, 구조적 확장성은 App Router에 비해 떨어지는 편이다.
---
